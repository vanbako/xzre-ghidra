# Progress Log

Document notable steps taken while building out the Ghidra analysis environment for the xzre artifacts. Add new entries in reverse chronological order and include enough context so another analyst can pick up where you left off.

## 2025-11-06
- Added `ghidra_scripts/ExportUnmappedFunctionSummaries.py` and ran it headlessly to emit `reports/unmapped_functions.json`; the report captures four unmapped extern thunks (`lzma_alloc`/`lzma_free`/`lzma_check_init`/`__tls_get_addr`) with parameter/storage details plus brief descriptions so we can reconcile their prototypes against upstream before the next typing pass — next: decide whether to fold those externs into the linker map or treat them as imported helpers when applying argument names.
- Extended the exporter to append mapped-but-missing functions from `xzre_locals.json`; the report now notes `backdoor_symbind64` (with its source path and locals) so the same pipeline can track future gaps when we start replaying local-variable fixes — next: repeat the run after each refresh to keep the missing-function list in sync.
- Built `ghidra_scripts/ApplyFunctionAnnotationsFromJson.py` and ran it with `reports/unmapped_functions.json`; the headless pass updated parameter datatypes for the four extern thunks and re-exported `ghidra_projects/xzre_ghidra_portable.zip`, giving us a reproducible way to replay these annotations once additional function bodies arrive — next: expand the JSON entries with local-variable shapes as we ingest more objects so the script can rename stack slots automatically.
- Added `ghidra_scripts/ExportFunctionDecompilations.py` and dumped every function to `xzregh/` (one `.c` file per entry point, with prototype metadata) so we can diff decomp output or hand-edit variable cues without launching Ghidra — next: wire this exporter into future refresh runs if we want a rolling textual snapshot for version control.

## 2025-11-05
- Added a quick headless helper (`ghidra_scripts/PrintFunctionDecompile.py`) to dump decompiler output plus raw instructions so we could sanity-check `backdoor_entry`; confirmed the binary writes the `_cpuid_gcc` EAX result to the local at `[rbp-0x4c]` and returns it, matching the source even though the applied locals currently label that slot as `b` — next: adjust the locals mapping (or tweak the apply script) so `a/b/c/d` land on their intended stack slots and avoid future confusion.
- Reworked the locals pipeline so `map_locals.py` keeps declaration order stable and `ApplyMappedLocals.py` now stages conflicting renames through temporary placeholders; reran both scripts and confirmed `backdoor_entry` decompiles with `_cpuid_gcc(...,&a,&b,&c,&state)` and `return a` again — next: audit other functions with overlapping stack reuse to make sure the new rename logic doesn’t need additional heuristics.

## 2025-11-04
- Adjusted `scripts/map_locals.py` so register-only locals defer to the dedicated matcher instead of the generic type-mismatch fallback, then ran `python scripts/map_locals.py --limit 200` to regenerate `reports/variable_mapping_report.json`; register temporaries now pick up confident matches without caveats — next: extend the alias heuristics again if future binaries surface new register edge cases.
- Replayed `ApplyMappedLocals.py` headlessly with the refreshed report (`~/tools/ghidra_11.4.2_PUBLIC/support/analyzeHeadless ... mapping=reports/variable_mapping_report.json`); 51 locals updated and 52 noted for follow-up, lining up the remaining register-only names with the `c_strnlen::len` fix — next: audit the skipped entries to decide whether additional heuristics or manual reviews are warranted.
- Ported the GUI rename flow into `ApplyMappedLocals.py` by invoking `HighFunctionDBUtil.updateDBVariable` for high-level symbols, re-ran the targeted `c_strlen` mapping, and then replayed the full report; register-only locals (including return-value temporaries) now rename cleanly and the global apply pass dropped to 12 skips — next: spot-check the remaining skips to see if they need new heuristics or manual intervention.
- Expanded `scripts/map_locals.py` heuristics (size hints, signed/unsigned aliasing, pointer-depth guard) and taught `ApplyMappedLocals.py` to preserve stack-array types during renames; regenerated the mapping report and re-applied locals (diagnostic run now reports only the expected low-confidence skips plus the missing `backdoor_symbind64`) — next: decide whether to tune array-length matching further or leave those manual.

## 2025-10-31
- Expanded `ghidra_scripts/RenameFromLinkerMap.py` so it now captures `.rodata*` and other non-text sections, which let the refresh pipeline stamp the branch-table symbols (`dasm_*`, `string_action_data`, `string_mask_data`, etc.) straight from `xzre.lds.in` — next: add explicit coverage for any data not represented in the linker script if we bring in additional objects.
- Added `ghidra_scripts/InstallEnumEquates.py` and wired it into `scripts/refresh_xzre_project.sh`; each refresh now parses `xzre_types_import_preprocessed.h` to install equates for `EncodedStringId` and the `CommandFlags{1,2,3}` enums so constant operands decompile with names instead of raw hex — next: consider extending the parser to cover additional flag enums if we expand the signature coverage.

## 2025-10-31
- Enhanced `ghidra_scripts/RenameFromLinkerMap.py` to parse section metadata so `.data*`/`.bss*` entries from `xzre/xzre.lds.in` now create or rename the corresponding globals, then reran `scripts/refresh_xzre_project.sh` to regenerate `ghidra_projects/xzre_ghidra_portable.zip` with the new labels applied (headless log shows 7 data symbols updated) — next: decide whether to bring the `.rodata` branch-table labels in through the same path.

## 2025-10-31
- Removed the automated locals extraction/apply steps from `scripts/refresh_xzre_project.sh` and re-ran the refresh so the headless pipeline now stops after signatures/parameter fixes; this keeps Ghidra’s SSA-local naming untouched for manual curation while still exporting an updated portable project — next: revisit locals application once a reliable merge strategy is scripted.

## 2025-10-31
- Hardened `ghidra_scripts/ApplyLocalsFromXzreSources.py` to clear conflicting stack slots safely, grow frames for large arrays, and only reuse candidates when they closely match the requested type; the refreshed headless pass now applies all 75 mapped locals without skips (only `backdoor_symbind64` remains absent from the object) — next: fold the new heuristics into `scripts/refresh_xzre_project.sh` runs so future imports keep the locals aligned automatically.
- Added `ghidra_scripts/VerifyLocalsAgainstMapping.py` for a headless sanity check that cross-references `ghidra_scripts/generated/xzre_locals.json`; verification shows full coverage aside from the expected missing `backdoor_symbind64` — next: ingest the binary providing that symbol or map an alias so the locals report stays clean.

## 2025-10-31
- Reworked `ghidra_scripts/ApplyLocalsFromXzreSources.py` to purge conflicting stack slots, generate fresh locals from `ghidra_scripts/generated/xzre_locals.json`, and resolve type strings via inline C parsing; `scripts/refresh_xzre_project.sh` now reports 75 locals applied with zero skips (only `backdoor_symbind64` is absent from the compiled object) and the exported `ghidra_projects/xzre_ghidra_portable.zip` carries the update — next: ingest the object or alias that defines `backdoor_symbind64` so the locals map reaches full coverage.
- Added `ghidra_scripts/DumpFunctionLocals.py` for headless spot-checks of stack layouts and used it to verify `elf_parse` and `rsa_key_hash` after the refresh, keeping regressions easy to triage without launching the GUI — next: fold the script into review steps whenever `ghidra_scripts/generated/xzre_locals.json` changes.
- Eliminated the `WARNING: Variable defined which should be unmapped` spam by teaching `ApplySignaturesFromHeader.py` to mark functions with imported prototypes as using custom variable storage and wiring a new `FixAllParamStorage.py` pass into `scripts/refresh_xzre_project.sh`; parameters now report assigned register storage across the board, and `ListProblemVariables.py`/`DumpFunctionParams.py` give a quick sanity check when the headers change — next: keep an eye on future imports that introduce new entry points so the custom-storage fix stays in place.

## 2025-10-31
- Hooked `RenameFromLinkerMap.py` into the refresh pipeline before signature replay (and hardened `ApplyLocalsFromXzreSources.py` for array types) so re-importing the object no longer strips the xzre symbol names; signature coverage is back to 100%, and the locals script now applies cleanly (31 locals updated, 1 function missing because it lacks locals in this build) — next: watch for any future object drops that omit those symbols so we can decide whether to gate the locals step.
- Added `scripts/extract_local_variables.py` plus the headless helper `ghidra_scripts/ApplyLocalsFromXzreSources.py`, regenerated the local-variable JSON map, and wired both into `scripts/refresh_xzre_project.sh` so every refresh replays the xzre decompiled locals; functions without compiler-emitted locals are skipped automatically, but the generated map is ready for richer objects if/when we import them — next: bring in the object that contains the remaining backdoor routines (or reconcile their symbol names) to expand coverage further.
- Created `scripts/refresh_xzre_project.sh` and documented it in `AGENTS.md` so every headless refresh re-imports the object, reapplies xzre headers, invokes `ApplySignaturesFromHeader.py`, and exports the portable archive in one step — next: wire the helper into any CI/automation that rebuilds the investigation workspace.
- Extended `ghidra_scripts/ApplySignaturesFromHeader.py` so every headless signature refresh now assigns the compiler's default System V AMD64 calling convention to any remaining `unknown` functions, keeping ABI warnings suppressed automatically — next: consider pruning the standalone `SetDefaultCallingConvention.py` once downstream workflows have migrated to the integrated path.
- Confirmed the `x86:LE:64` gcc compiler spec maps its default `__stdcall` prototype to the System V AMD64 ABI, added helper scripts (`ListCallingConventionNames.py`, `ListUnknownCallingConventions.py`, `SetDefaultCallingConvention.py`), fixed 125 functions with unknown conventions, verified the cleanup headlessly, and refreshed `ghidra_projects/xzre_ghidra_portable.zip` — next: fold the default-convention script into any future signature import workflows so reimports stay warning-free.
- Added `ghidra_scripts/ListFunctionSignatures.py` and ran it headlessly to dump all `liblzma_la-crc64-fast.o` prototypes, then diffed the output against `ghidra_scripts/xzre_types_import_preprocessed.h` — uncovered 31 mismatches (missing const qualifiers, typedef drift like `uint` vs `unsigned int`, and the `secret_data_append_items` appender callback type) that still need to be resolved before the database matches upstream.
- Built `ghidra_scripts/InspectFunctionTypes.py` plus scratch script `TestParseConst.py` to inspect the active signature datatypes; reapplying the header definitions confirmed that the remaining gaps are cosmetic quirks in Ghidra’s C parser (it canonicalises `const` away, folds `struct` tags into typedef names, and renders function-pointer callbacks as typedef pointers). No functional mismatches remain, so further changes would require upstream adjustments to the parser or accepting alternative renderings — Next: document the acceptable deltas in any downstream comparison tooling if strict textual equality is required.

## 2025-10-30
- Added the nine missing extern prototypes (`__tls_get_addr`, `elf_contains_vaddr_impl`, `elf_find_rela_reloc`, `elf_find_relr_reloc`, `hook_EVP_PKEY_set1_RSA`, `hook_RSA_get0_key`, `j_tls_get_addr`, `lzma_check_init`, `lzma_free`) into `xzre/xzre.h`, regenerated `ghidra_scripts/xzre_types_import_preprocessed.h`, reran the import/signature pass, and refreshed the portable archive — Ghidra now reports zero missing prototypes with the OpenSSL hooks now typed against forward-declared structs for const-correctness.
- Ran `ImportXzreTypes.py` headlessly against `ghidra_scripts/xzre_types_import_preprocessed.h` so every xzre function signature and related typedef now lives in the `liblzma_la-crc64-fast.o` program — this aligns Ghidra’s database with the upstream headers for cleaner decompilation.
- Regenerated `ghidra_projects/xzre_ghidra_portable.zip` via `ExportProjectArchive.py` to capture the refreshed project state — next: review the decompiler output for comment/annotation passes.
- Added helper scripts (`ghidra_scripts/ListDefaultNamedFunctions.py`, `ghidra_scripts/ListAllFunctions.py`, `ghidra_scripts/RenameFromLinkerMap.py`) and ran the rename pass so every function now matches its identifier from `xzre/xzre.lds.in` (default-name count dropped to zero) — next: extend `xzre.h`/import headers for the remaining `// FIXME: prototype` entries and annotate high-priority routines.
- Created `ghidra_scripts/ApplySignaturesFromHeader.py` (plus `ListFunctionDefinitions.py` for sanity checks) and applied header prototypes to 116 functions via headless Ghidra.

## 2025-10-29
- Imported sanitized xzre headers via `ghidra_scripts/ImportXzreTypes.py` to register typedefs/enums/structs for the program in `liblzma_la-crc64-fast.o` — ensures Ghidra has all backdoor type information needed for signature work — Next: align the actual function prototypes with these imported data types.
- Added headless export script (`ghidra_scripts/ExportProjectArchive.py`) and generated `ghidra_projects/xzre_ghidra_portable.zip` to snapshot the project without committing live `.rep` state.
- Created the headless Ghidra project `xzre_ghidra` under `ghidra_projects/` and imported `xzre/liblzma_la-crc64-fast.o` using `~/tools/ghidra_11.4.2_PUBLIC/support/analyzeHeadless`.

## Update Template
- `YYYY-MM-DD`: <What changed?> — <Why it was done?> — <Next action if applicable>
