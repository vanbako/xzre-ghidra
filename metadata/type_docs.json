{
  "lzma_check": "Subset of liblzma integrity-check identifiers the implant cares about when faking encoder state so we only accept payloads signed with CRC32/CRC64/SHA256.",
  "X86_OPCODE": "Literal opcode values consumed by the lightweight disassembler so pattern-matching routines can locate MOV/LEA/CALL sequences without pulling in a full decoder.",
  "X86_REG": "Normalized register identifiers that the decoder uses when it needs to refer to architectural registers (only RBP is currently required).",
  "InstructionFlags": "Bitmask describing which optional instruction prefixes (LOCK/REP, segment overrides, operand/address-size hints, VEX, REX and ModRM) were observed while decoding an x86 instruction.",
  "InstructionFlags2": "Secondary flag set emitted by the decoder that captures which addressing features (displacement, immediates, 64-bit immediates) are present for the current instruction.",
  "ElfFlags": "Bitmask describing which relocation tables, version records, and hardening features were discovered while parsing an ELF image.",
  "ModRm_Mod": "Categorization of the ModRM byte modes that the instruction search helpers check when scanning for register or displacement based operands.",
  "FuncFindType": "High-level opcode families the scanner can search for; currently only used to distinguish ENDBR64 sequences from padding NOPs.",
  "ElfId": "Stable identifiers for each ELF image we track (main executable, ld.so, libc, liblzma, libcrypto) so helpers can index into shared arrays without raw pointers.",
  "StringXrefId": "Enumerated handles for the small set of sshd status strings we care about when locating code and data references inside the binary.",
  "EncodedStringId": "Indexes into the deduplicated string table embedded in xzre’s rodata dump; the values double as offsets into the `string_mask_data` array.",
  "PayloadState": "State machine for the payload download/decrypt workflow (only INITIAL is defined so far while the rest of the states are discovered dynamically).",
  "dasm_modrm_mask": "Convenience masks for projecting a decoded ModRM byte into its RM/REG/MOD fields or for retrieving the raw byte from the bit-packed representation.",
  "LogLevel": "Mirror of sshd’s syslog verbosity levels so the hook can translate its own severity decisions into whatever the daemon expects.",
  "CommandFlags1": "Interpretation of the first byte of the `cmd_arguments_t` block (packet sizing hints, PAM disablement, socket index encoding, etc.).",
  "CommandFlags2": "Second command flag byte which governs impersonation behaviour, monitor request overrides, auth bypass toggles, and which socket descriptor is referenced.",
  "CommandFlags3": "Final command flag byte indicating the numeric socket identifier plus monitor request value derived from the payload.",
  "SocketMode": "Direction selector the socket helpers use to know whether we should fetch the readable or writable monitor file descriptor.",
  "got_ctx_t": "Tracks the GOT slot that is currently being patched while hijacking liblzma’s resolver.\nHolds the slot pointer itself, the original return site, the cpuid trampoline, and the signed displacement so we can roll back or advance the hook safely.",
  "elf_entry_ctx_t": "Lightweight record describing the symbol import we are about to tamper with.\nBundles the loader-provided symbol pointer, the `got_ctx_t` used for the patch, and the caller’s stack frame for later restoration.",
  "dasm_ctx_t": "Hand-written x86 decoder used throughout the project to find instructions without shipping a full disassembler.\nIt records prefix bits, VEX/REX state, ModRM/SIB breakdowns, computed operands, and scratch fields so pattern searchers can share one structure.",
  "elf_info_t": "Parsed view of an ELF image that exposes the headers, relocation tables, version info, code/data segments, and GNU hash metadata needed by the import fix-ups.",
  "libc_imports_t": "Resolved libc entrypoints used by the implant (pselect/read/write/setresgid/etc.) along with the book-keeping counters for how many symbols were patched successfully.",
  "imported_funcs_t": "All non-libc function pointers the payload needs (RSA/EVP/BN helpers, chacha decrypt, etc.) plus access to the owning `libc_imports_t` so callers can reach both sets via one pointer.",
  "sshd_ctx_t": "Snapshot of the sshd monitor state that tracks where each `mm_answer_*` handler lives, whether it has already been hooked, and which request IDs correspond to the sensitive operations we intercept.",
  "sshd_log_ctx_t": "Captures the moving pieces required to hook sshd’s logging path, including the original handler, replacement trampolines, format strings, and guard booleans to keep syslog stable.",
  "sshd_offsets_kex_t": "Compressed description of where the interesting fields live inside `struct kex` (qword index plus byte offset) so we can adjust to layout shifts between builds.",
  "sshd_offsets_sshbuf_t": "Same idea as `sshd_offsets_kex_t` but for the sshbuf backing storage; stores the indices of the data pointer and size field we need to rewrite.",
  "sshd_offsets_fields_t": "Convenience wrapper that groups the individual offset unions for simultaneous propagation from the scanning routines into the runtime context.",
  "sshd_offsets_t": "32-bit union that packs the discovered offsets and exposes them both as structured fields and as a raw integer when we need atomic updates.",
  "sshd_payload_ctx_t": "Decrypted command blob staged by `mm_answer_keyallowed`: starts with a length, 0x3a-byte signed header (ending in the payload type), a 0x72-byte Ed448 signature, and then the attacker-controlled body beginning at offset 0xae with a caller-supplied payload_data_offset.",
  "global_context_t": "Authoritative runtime state for the backdoor.\nIt wires together imported function tables, sshd metadata, decrypted payload buffers, socket scratch space, and secret shift operations so every hook can reach consistent data.",
  "backdoor_shared_globals_t": "Tiny structure that stage-one drops into `.bss` so later stages can find the `global_context_t`, the active hooks, and the exported helper thunks without re-scanning memory.",
  "ldso_ctx_t": "All of the state we steal from the dynamic loader when we patch the audit interfaces: pointers to `_dl_audit_symbind_alt`, link-map fields, cached audit bitmasks, and copies of the hooked GOT entries.",
  "backdoor_hooks_data_t": "Blob that actually lives inside liblzma’s data segment and holds the loader context (`ldso_ctx_t`), `global_context_t`, resolved imports, sshd/log contexts, and the signed payload bytes the implant enforces.",
  "backdoor_hooks_ctx_t": "Ephemeral orchestrator that stage one reuses while replaying the GOT patches: `hooks_data_slot_ptr` hands back liblzma’s resident blob, the symbind/RSA/mm_* entries point at the trampolines we splice into sshd, and the scratch/placeholder slots keep the structure ABI stable between bootstrap attempts.",
  "backdoor_setup_params_t": "Argument bundle handed to `backdoor_setup` so the second stage has references to the shared globals, hook descriptors, dummy lzma state, and the entry context it should continue from.",
  "elf_handles_t": "Pointers to each parsed ELF info block (main binary, ld.so, libc, liblzma, libcrypto) so helper routines can iterate the fleet without repeating lookups.",
  "main_elf_t": "Lightweight bootstrap record containing the `elf_handles_t`, ld.so’s header, and a pointer to `__libc_stack_end`; used while pivoting into the loader context.",
  "backdoor_data_handle_t": "Pairs the monolithic `backdoor_data_t` blob with its `elf_handles_t` so loader helpers can take one argument yet still access both structures.",
  "string_item_t": "Single entry in the string-reference table that records which encoded string we matched along with the function bounds and the exact xref address.",
  "string_references_t": "Fixed-size array of `string_item_t` records covering the 27 status strings we track inside sshd to anchor later scans.",
  "backdoor_data_t": "Master structure built during the loader pass that holds every `link_map`, the parsed `elf_info_t` objects for key libraries, resolved libc imports, string references, and the fake allocator we expose to liblzma.",
  "backdoor_shared_libraries_data_t": "Scratch arguments passed around while iterating dependent libraries; stitches together the master data blob, elf handles, resolved PLT stubs, and pointers back to the hook data so each pass can install the necessary trampolines.",
  "secret_data_shift_cursor_t": "Bit-packed cursor (3-bit bit index + 29-bit byte index) used when reconstructing the obfuscated secret data stream stored inside the RSA payload.",
  "secret_data_item_t": "One decoded chunk of the secret data stream including the original code reference, the shift cursor, the operation index, and bookkeeping counters.",
  "backdoor_payload_hdr_t": "First 16 bytes of every encrypted payload chunk. The stride/index/bias triple stays in plaintext so decrypt_payload_message can reuse it as the ChaCha nonce, and run_backdoor_commands collapses it into monitor_data.cmd_type via (stride * index + bias) before committing to the payload.",
  "u_cmd_arguments_t": "Two-byte overlay that lets us treat the final argument byte pair as either raw data or as a little-endian size value when computing payload lengths.",
  "cmd_arguments_t": "Command flags (three flag bytes plus the variable-size union) that describe how the monitor thread should interpret the decrypted payload.",
  "backdoor_payload_body_t": "Decrypted payload body: a 0x72-byte Ed448 signature protecting the cmd flag bytes plus the attacker-supplied monitor payload staged at offset 0x87 of the modulus.",
  "backdoor_payload_t": "Full 0x228-byte decrypted payload buffer exposed both as a raw byte array for hashing and as the parsed {header, body} pair consumed by the RSA hooks.",
  "key_payload_t": "Outer frame for each streamed chunk: ChaCha ciphertext that carries the plaintext header + length prefix + body, giving decrypt_payload_message enough structure to stage the decrypted command bytes.",
  "key_ctx_t": "Working context for RSA-related operations; caches the modulus/exponent pointers, parsed command flags, decrypted payload, IV, and Ed448 key material extracted from the host key.",
  "monitor_data_t": "Structure passed into the monitor thread once a payload is decrypted; exposes the decoded command, RSA key pointers, payload body pointer/size, and the sshd RSA handle.",
  "backdoor_runtime_data_t": "Union that either exposes the fully-populated `monitor_data_t` or lets the caller treat the same memory as a flat 608-byte scratch buffer during staging.",
  "run_backdoor_commands_data_t": "Large bookkeeping record backing `run_backdoor_commands`; maintains payload sizing, hostkey metadata, socket input buffers, per-command runtime state, and the embedded `key_ctx_t` used across iterations.",
  "backdoor_cpuid_reloc_consts_t": "Constant offsets harvested from liblzma that describe where the cpuid GOT slot and stage-two trampoline live so the hook can update them without rescanning instructions.",
  "backdoor_tls_get_addr_reloc_consts_t": "Similar relocation constants for the `__tls_get_addr` thunk so we can locate the PLT stub and randomized GOT slot at runtime.",
  "elf_functions_t": "Mini vtable exported back into liblzma that holds callable helpers (initializing hook structs, parsing an ELF header, resolving symbols) so the stage-two code can reuse our C helpers.",
  "fake_lzma_allocator_t": "Dummy `lzma_allocator` instance that mimics the original callback table; used when the implant needs to satisfy allocation requests without delegating to libc.",
  "instruction_search_ctx_t": "Shared context for the instruction-search helpers; tracks the scan range, the byte pattern we expect, the output register captures, and provides access to hook/import state during complex searches.",
  "tls_index": "Standard glibc TLS index pair (module + offset) used when calling the loader’s `__tls_get_addr` trampoline from within the implant."
}
