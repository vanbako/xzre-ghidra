{
  "lzma_check": "Subset of liblzma integrity-check identifiers the implant cares about when faking encoder state so we only accept payloads signed with CRC32/CRC64/SHA256.",
  "X86_OPCODE": "Normalized opcode values stored in `dasm_ctx_t::opcode_window` so pattern-matching routines can locate MOV/LEA/CALL sequences without pulling in a full decoder. For one-byte opcodes `x86_decode_instruction` stores `raw_opcode + 0x80` (subtract 0x80 to recover the architectural opcode byte).",
  "X86_REG": "Normalized register identifiers that the decoder uses when it needs to refer to architectural registers (only RBP is currently required).",
  "InstructionFlags": "Bitmask describing which optional instruction prefixes (LOCK/REP, segment overrides, operand/address-size hints, VEX, REX and ModRM) were observed while decoding an x86 instruction.",
  "InstructionFlags2": "Secondary flag set emitted by the decoder that captures which addressing features (displacement, immediates, 64-bit immediates) are present for the current instruction.",
  "ElfFlags": "Bitmask describing which relocation tables, version records, and hardening features were discovered while parsing an ELF image.",
  "ModRm_Mod": "Categorization of the ModRM byte modes that the instruction search helpers check when scanning for register or displacement based operands.",
  "FuncFindType": "High-level opcode families the scanner can search for; currently only used to distinguish ENDBR64 sequences from padding NOPs.",
  "ElfId": "Stable identifiers for each ELF image we track (main executable, ld.so, libc, liblzma, libcrypto) so helpers can index into shared arrays without raw pointers.",
  "StringXrefId": "Enumerated handles for the small set of sshd status strings we care about when locating code and data references inside the binary.",
  "EncodedStringId": "Indexes into the deduplicated string table embedded in xzre\u2019s rodata dump; the values double as offsets into the `string_mask_data` array.",
  "PayloadState": "State machine for the payload download/decrypt workflow (only INITIAL is defined so far while the rest of the states are discovered dynamically).",
  "dasm_modrm_mask": "Convenience masks for projecting a decoded ModRM byte into its RM/REG/MOD fields or for retrieving the raw byte from the bit-packed representation.",
  "LogLevel": "Mirror of sshd\u2019s syslog verbosity levels so the hook can translate its own severity decisions into whatever the daemon expects.",
  "CommandFlags1": "Interpretation of the first byte of the `cmd_arguments_t` block (packet sizing hints, PAM disablement, socket index encoding, etc.).",
  "CommandFlags2": "Second command flag byte which governs impersonation behaviour, monitor request overrides, auth bypass toggles, and which socket descriptor is referenced.",
  "CommandFlags3": "Final command flag byte indicating the numeric socket identifier plus monitor request value derived from the payload.",
  "SocketMode": "Direction selector the socket helpers use to know whether we should fetch the readable or writable monitor file descriptor.",
  "got_ctx_t": "Bookkeeping for the cpuid/TLS GOT patch: seeds the expected __tls_get_addr displacement, caches the resolved GOT anchor, the cpuid slot pointer/index, and the offset back to the randomized GOT base so stage one can rewrite and later restore the cpuid entry.",
  "elf_entry_ctx_t": "Lightweight record describing the hijacked cpuid import: the runtime address of `cpuid_random_symbol`, the GOT patch context (tls anchor + cpuid slot pointer/index + GOT offset), and the resolver frame pointer reused to stash the cpuid GOT slot.",
  "dasm_ctx_t": "Hand-written x86 decoder used throughout the project to find instructions without shipping a full disassembler.\nIt records prefix bits, VEX/REX state, ModRM/SIB breakdowns, computed operands, and scratch fields so pattern searchers can share one structure.",
  "elf_info_t": "Parsed view of an ELF image that exposes the headers, relocation tables, version info, code/data segments, and GNU hash metadata needed by the import fix-ups.",
  "libc_imports_t": "Resolved libc entrypoints used by the implant (pselect/read/write/setresgid/etc.) along with the book-keeping counters for how many symbols were patched successfully.",
  "imported_funcs_t": "All non-libc function pointers the payload needs (RSA/EVP/BN helpers, chacha decrypt, etc.) plus access to the owning `libc_imports_t` so callers can reach both sets via one pointer.",
  "sshd_ctx_t": "Snapshot of the sshd monitor state that tracks where each `mm_answer_*` handler lives, whether it has already been hooked, and which request IDs correspond to the sensitive operations we intercept.",
  "sshd_log_ctx_t": "Tracks the validated log_handler/log_handler_ctx slots, saved originals, syslog mask toggle, and the rodata/sshlogv pointers needed to rewrite sshd log lines safely.",
  "sshd_offsets_kex_t": "Compressed description of the monitor\u2192kex layout used by sshd_find_forged_modulus_sshbuf: kex_sshbuf_qword_index selects the qword inside `struct kex` that is treated as a candidate `sshbuf *`, while monitor_pkex_table_dword_index selects the dword slot inside `struct monitor` that points at the active `kex **` pointer.",
  "sshd_offsets_sshbuf_t": "Same idea as `sshd_offsets_kex_t` but for the sshbuf backing storage; stores the indices of the data pointer and size field we need to rewrite.",
  "sshd_offsets_fields_t": "Convenience wrapper that groups the individual offset unions for simultaneous propagation from the scanning routines into the runtime context.",
  "sshd_offsets_t": "32-bit union that packs the discovered offsets and exposes them both as structured fields and as a raw integer when we need atomic updates.",
  "sshd_hostkey_index_t": "Tiny wrapper around the zero-based host_pubkeys[] ordinal used while iterating sshd host keys; keeping it as a named struct stops Ghidra from emitting anonymous unions whenever we compare or store the raw index.",
  "sshd_payload_ctx_t": "Decrypted command blob staged by `mm_answer_keyallowed`: starts with a length, 0x3a-byte signed header (ending in the payload type), a 0x72-byte Ed448 signature, and then the attacker-controlled body beginning at offset 0xae with a caller-supplied payload_data_offset.",
  "global_context_t": "Authoritative runtime state for the backdoor: resolved libc/libcrypto imports, sshd monitor/log metadata, code/data bounds for scans, payload streaming buffers/state, and the secret-data attestation flags so every hook can share consistent context.",
  "backdoor_shared_globals_t": "Tiny structure that stage-one drops into `.bss` so later stages can find the `global_context_t`, the active hooks, and the exported helper thunks without re-scanning memory.",
  "ldso_ctx_t": "All of the state we steal from the dynamic loader when we patch the audit interfaces: pointers to `_dl_audit_symbind_alt`, link-map fields, cached audit bitmasks, and copies of the hooked GOT entries.",
  "backdoor_hooks_data_t": "Blob that actually lives inside liblzma\u2019s data segment and holds the loader context (`ldso_ctx_t`), `global_context_t`, resolved imports, sshd/log contexts, and the signed payload bytes the implant enforces.",
  "backdoor_hooks_ctx_t": "Ephemeral orchestrator that stage one reuses while replaying the GOT patches: `hooks_data_slot_ptr` hands back liblzma\u2019s resident blob, the symbind/RSA/mm_* entries point at the trampolines we splice into sshd, and the scratch/placeholder slots keep the structure ABI stable between bootstrap attempts.",
  "backdoor_setup_params_t": "Argument bundle handed to `backdoor_install_runtime_hooks`: zeroed scratch + the shared-globals pointer, hook context, dummy lzma_check_state, and the active `elf_entry_ctx_t` describing the hijacked cpuid GOT slot.",
  "elf_handles_t": "Pointers to the parsed ELF descriptors for sshd, ld.so, libc, liblzma, and libcrypto so helpers can share metadata without re-parsing each image.",
  "main_elf_t": "Lightweight bootstrap record containing the `elf_handles_t`, ld.so\u2019s header, and a pointer to `__libc_stack_end`; used while pivoting into the loader context.",
  "link_map": "Prefix of glibc's link_map used by loader helpers; only l_addr/l_name/l_ld/l_next/l_prev are modeled here.",
  "lookup_t": "Alias for `struct link_map *` used by ld.so audit hooks (e.g., `_dl_audit_symbind_alt`).",
  "backdoor_data_handle_t": "Pairs the monolithic `backdoor_data_t` blob with its `elf_handles_t` so loader helpers can take one argument yet still access both structures.",
  "string_item_t": "Per-string entry storing the encoded literal ID (with padding for alignment), the bounded function range that references it, and the LEA xref.",
  "string_references_t": "Ordered set of 27 `string_item_t` slots keyed by `StringXrefId` for the sshd/PAM/log anchors (xcalloc, monitor RPCs, sshlogv/syslog helpers) that drive the recon heuristics.",
  "backdoor_data_t": "Master structure built during the loader pass that holds every `link_map`, the parsed `elf_info_t` objects for key libraries, resolved libc imports, string references, and the fake allocator we expose to liblzma.",
  "backdoor_shared_libraries_data_t": "Scratch arguments passed around while iterating dependent libraries; stitches together the master data blob, elf handles, resolved PLT stubs, and pointers back to the hook data so each pass can install the necessary trampolines.",
  "secret_data_shift_cursor_t": "Cursor for the secret-data bitstream: bit_position tracks the absolute offset, signed_bit_position is used for arithmetic, and the intra_byte_bit/byte_offset view exposes the decomposed byte+bit for callers that need to poke global_ctx->secret_data directly.",
  "secret_data_item_t": "Descriptor for a single secret-data attestation entry: anchor_pc identifies the helper, bit_cursor selects the target slot in the obfuscated stream, operation_slot gates once-only execution, bits_to_shift feeds the accounting counter, and ordinal tracks the batch-assigned slot.",
  "backdoor_payload_hdr_t": "First 16 bytes of every encrypted payload chunk. The stride/index/bias triple stays in plaintext so payload_stream_decrypt_and_append_chunk can reuse it as the ChaCha nonce, and rsa_backdoor_command_dispatch collapses it into monitor_data.cmd_type via (stride * index + bias) before committing to the payload.",
  "u_cmd_arguments_t": "Two-byte overlay that lets us treat the final argument byte pair as either raw data or as a little-endian size value when computing payload lengths.",
  "cmd_arguments_t": "control_flags/monitor_flags/request_flags plus a two-byte payload_hint that collectively drive log-hook installs, PAM disablement, socket selection, monitor request IDs, and whether sshd_monitor_cmd_dispatch should stream payloads or patch ctx->sshd_offsets.",
  "backdoor_payload_body_t": "Decrypted payload body: a 0x72-byte Ed448 signature protecting the cmd flag bytes plus the attacker-supplied monitor payload staged at offset 0x87 of the modulus.",
  "backdoor_payload_t": "Full 0x228-byte decrypted payload buffer exposed both as a raw byte array for hashing and as the parsed {header, body} pair consumed by the RSA hooks.",
  "key_payload_t": "Outer frame for each streamed chunk: ChaCha ciphertext that carries the plaintext header + length prefix + body, giving payload_stream_decrypt_and_append_chunk enough structure to stage the decrypted command bytes.",
  "key_payload_cmd_frame_t": "Stack scratch wrapper used by rsa_backdoor_command_dispatch: a 5-byte cmd_arguments_t prefix followed by the key_payload_t ciphertext chunk copied from the RSA modulus stream.",
  "key_ctx_t": "Working context for RSA-related operations; caches the cloned modulus/exponent, parsed cmd flags, decrypted payload bytes, the 32-byte host-key digest slot, ChaCha nonce/IV snapshots, and the attacker\u2019s unwrapped Ed448 key (whose low 32 bytes double as the ChaCha key) so rsa_backdoor_command_dispatch can replay decryptions without re-reading secret_data.",
  "monitor": "Privsep-side state that exposes the RPC pipes (auth + logging), the pkex table pointer, and the monitor PID so helpers such as sshd_get_monitor_comm_fd/sshd_find_forged_modulus_sshbuf can operate on the live monitor struct.",
  "monitor_data_t": "Argument bundle that `rsa_backdoor_command_dispatch` hands to `sshd_monitor_cmd_dispatch`: it carries the decoded cmd opcode, parsed cmd_arguments_t flags, cloned RSA modulus/exponent, payload body pointer/size, and the RSA handle borrowed from OpenSSL.",
  "backdoor_runtime_data_t": "Union that either exposes the fully-populated `monitor_data_t` or lets the caller treat the same memory as a flat 608-byte scratch buffer during staging.",
  "run_backdoor_commands_data_t": "Full stack frame for `rsa_backdoor_command_dispatch`: tracks payload body/cipher sizing, the RSA hook\u2019s do_orig flag, host key iteration counters, the staging union (socket receive buffers vs. staged Ed448 key material), plus the runtime monitor_data_t scratch and embedded `key_ctx_t` reused across commands.",
  "backdoor_cpuid_reloc_consts_t": "Constant offsets harvested from liblzma that describe where the cpuid GOT slot and stage-two trampoline live so the hook can update them without rescanning instructions.",
  "backdoor_tls_get_addr_reloc_consts_t": "Similar relocation constants for the `__tls_get_addr` thunk so we can locate the PLT stub and randomized GOT slot at runtime.",
  "elf_functions_t": "Mini vtable overlay stored in liblzma's encoders table; slots 1/4/6 are repurposed for init_hook_functions, elf_gnu_hash_lookup_symbol_addr, and elf_info_parse while the remaining slots stay unused to preserve the original layout.",
  "fake_lzma_allocator_t": "Dummy `lzma_allocator` instance that mimics the original callback table; used when the implant needs to satisfy allocation requests without delegating to libc.",
  "instruction_search_ctx_t": "Shared context for the instruction-search helpers; tracks the scan range, the byte pattern we expect, the output register captures, and provides access to hook/import state during complex searches.",
  "tls_index": "Standard glibc TLS index pair (module + offset) used when calling the loader\u2019s `__tls_get_addr` trampoline from within the implant."
}
