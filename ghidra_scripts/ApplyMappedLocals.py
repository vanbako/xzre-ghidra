# Applies confident local-variable mappings generated by scripts/map_locals.py
# onto the active program.
# @category xzre

import json
import os

from ghidra.app.decompiler import DecompInterface  # type: ignore
from ghidra.app.util.cparser.C import CParser  # type: ignore
from ghidra.program.model.data import Undefined  # type: ignore
from ghidra.program.model.pcode import HighFunctionDBUtil  # type: ignore
from ghidra.program.model.listing import VariableStorage  # type: ignore
from ghidra.program.model.symbol import SourceType  # type: ignore
from ghidra.util.task import ConsoleTaskMonitor  # type: ignore
from ghidra.util.exception import (
    DuplicateNameException,
    InvalidInputException,
    UsrException,
)  # type: ignore
from ghidra.util.task import ConsoleTaskMonitor  # type: ignore


def _build_local_map(func):
    mapping = {}
    try:
        for local_var in func.getLocalVariables():
            mapping[local_var.getName()] = local_var
    except Exception:
        pass
    return mapping


def _build_high_symbol_map(symbol_map):
    mapping = {}
    if symbol_map is None:
        return mapping
    try:
        symbols = symbol_map.getSymbols()
    except Exception:
        return mapping
    for symbol in symbols:
        try:
            if symbol.isParameter():
                continue
        except Exception:
            pass
        mapping[symbol.getName()] = symbol
    return mapping


def _generate_placeholder_name(counter_ref, func_locals, high_symbols):
    while True:
        candidate = "__tmp_local_{}".format(counter_ref[0])
        counter_ref[0] += 1
        if candidate in func_locals:
            continue
        if candidate in high_symbols:
            continue
        return candidate


def _attempt_rename(func, symbol_map, func_locals, high_symbols, target_var, new_name, data_type, is_high):
    renamed = False
    high_update_used_local = False
    if is_high:
        try:
            HighFunctionDBUtil.updateDBVariable(
                target_var,
                new_name,
                data_type,
                SourceType.USER_DEFINED,
            )
            renamed = True
            high_update_used_local = True
        except (DuplicateNameException, InvalidInputException, UsrException, Exception, Throwable):
            renamed = False
            high_update_used_local = False
    if not renamed and is_high and symbol_map is not None:
        try:
            symbol_map.renameSymbol(target_var, new_name, SourceType.USER_DEFINED)
            renamed = True
        except (Exception, Throwable):
            renamed = False
    if not renamed:
        rename_attempts = [
            lambda obj: obj.setName(new_name, SourceType.USER_DEFINED),
            lambda obj: obj.setName(new_name),
            lambda obj: obj.rename(new_name, SourceType.USER_DEFINED),
            lambda obj: obj.rename(new_name),
        ]
        for attempt in rename_attempts:
            try:
                attempt(target_var)
                renamed = True
                break
            except (Exception, Throwable):
                continue
    if not renamed and is_high:
        try:
            storage = target_var.getStorage()
            data_type_local = data_type or target_var.getDataType()
            if data_type_local is None:
                size = 1
                try:
                    size = storage.size()
                except Exception:
                    try:
                        size = storage.getSize()
                    except Exception:
                        size = 1
                data_type_local = Undefined.getUndefinedDataType(size)
            func.createLocalVariable(
                new_name,
                data_type_local,
                storage,
                SourceType.USER_DEFINED,
            )
            func_locals = _build_local_map(func)
            target_var = func_locals.get(new_name, target_var)
            is_high = False
            renamed = True
        except (Exception, Throwable):
            renamed = False
    if renamed:
        if is_high or (symbol_map is not None and new_name in high_symbols):
            high_symbols = _build_high_symbol_map(symbol_map)
            updated = high_symbols.get(new_name, target_var)
            return True, updated, True, high_update_used_local, func_locals, high_symbols
        func_locals = _build_local_map(func)
        updated = func_locals.get(new_name, target_var)
        return True, updated, False, high_update_used_local, func_locals, high_symbols
    return False, target_var, is_high, high_update_used_local, func_locals, high_symbols

try:
    from java.lang import Throwable  # type: ignore
except ImportError:  # pragma: no cover
    class Throwable(Exception):
        pass


def _parse_args(raw_args):
    mapping_path = None
    dry_run = False
    diagnose = False
    for arg in raw_args:
        if arg.startswith("mapping="):
            mapping_path = os.path.abspath(arg.split("=", 1)[1])
        elif arg == "dryrun":
            dry_run = True
        elif arg == "diagnose":
            diagnose = True
    if not mapping_path:
        raise RuntimeError("mapping=/path/to/variable_mapping_report.json is required")
    if not os.path.exists(mapping_path):
        raise RuntimeError("mapping file not found: {}".format(mapping_path))
    return mapping_path, dry_run, diagnose


def _find_function_by_name(function_manager, name):
    for func in function_manager.getFunctions(True):
        if func.getName() == name:
            return func
    return None


def _datatype_display(dt):
    if dt is None:
        return None
    try:
        return dt.getDisplayName()
    except Exception:
        try:
            return dt.getName()
        except Exception:
            return None


class TypeResolver(object):
    def __init__(self, dtm):
        self._parser = CParser(dtm)
        self._counter = 0

    def parse(self, type_str):
        if not type_str:
            return None
        typedef_name = "__mapped_type_{}".format(self._counter)
        self._counter += 1
        typedef_snippet = "typedef {} {};\n".format(type_str, typedef_name)
        try:
            parsed = self._parser.parse(typedef_snippet)
            if parsed is None:
                return None
            if hasattr(parsed, "getDataType"):
                inner = parsed.getDataType()
                if inner is not None:
                    return inner
            return parsed
        except Throwable:
            return None
        except Exception:
            return None


def _storage_repr(storage):
    if storage is None:
        return None
    try:
        return str(storage)
    except Exception:
        return None


def _find_local_variable(func_locals, high_symbols, target_name, storage_repr=None):
    var = func_locals.get(target_name)
    if var is not None:
        if storage_repr:
            try:
                if _storage_repr(var.getVariableStorage()) != storage_repr:
                    pass
            except Exception:
                pass
        return var, False
    symbol = high_symbols.get(target_name)
    if symbol is not None:
        if storage_repr:
            try:
                if _storage_repr(symbol.getStorage()) != storage_repr:
                    pass
            except Exception:
                pass
        return symbol, True
    return None, False


def main():
    mapping_path, dry_run, diagnose = _parse_args(getScriptArgs())
    with open(mapping_path, "r") as infile:
        mapping = json.load(infile)

    program = currentProgram  # type: ignore  # noqa: F821
    function_manager = program.getFunctionManager()
    dtm = program.getDataTypeManager()
    resolver = TypeResolver(dtm)
    interface = DecompInterface()
    try:
        interface.openProgram(program)
    except Exception as exc:
        raise RuntimeError("Failed to open program for decompilation: {}".format(exc))

    applied = 0
    skipped = 0
    diagnostics = []

    def record_skip(message):
        if diagnose:
            diagnostics.append(message)
    transaction = program.startTransaction("ApplyMappedLocals")
    try:
        for entry in mapping.get("results", []):
            func_name = entry.get("function")
            func = _find_function_by_name(function_manager, func_name)
            if func is None:
                skipped_count = sum(len(match.get("assigned", [])) for match in entry.get("matches", []))
                skipped += skipped_count
                record_skip("Function {} missing from program ({} assignment(s) skipped)".format(func_name, skipped_count))
                continue

            func_locals = _build_local_map(func)

            symbol_map = None
            try:
                decomp_results = interface.decompileFunction(func, 60, ConsoleTaskMonitor())
            except Exception:
                decomp_results = None
            if decomp_results is not None and decomp_results.decompileCompleted():
                high_func = decomp_results.getHighFunction()
                if high_func is not None:
                    try:
                        symbol_map = high_func.getLocalSymbolMap()
                    except Exception:
                        symbol_map = None
            high_symbols = _build_high_symbol_map(symbol_map)

            assignment_tasks = []
            processed_match_ids = set()

            for match in entry.get("matches", []):
                notes = match.get("notes") or []
                if notes:
                    count = len(match.get("assigned", []))
                    skipped += count
                    record_skip("Function {}: skipped {} low-confidence assignment(s) for source {}".format(func_name, count, match.get("source", {}).get("name")))
                    continue

                source_type = match.get("source", {}).get("type")
                target_dt = resolver.parse(source_type) if source_type else None

                for assignment in match.get("assigned", []):
                    assignment_tasks.append(
                        {
                            "match": match,
                            "assignment": assignment,
                            "target_dt": target_dt,
                        }
                    )

            temp_name_counter = [0]

            from_names = {
                task["assignment"].get("ghidra_name")
                for task in assignment_tasks
                if task["assignment"].get("ghidra_name")
            }

            def _needs_delay(task):
                assignment = task["assignment"]
                ghidra_name = assignment.get("ghidra_name")
                suggested = assignment.get("suggested_name")
                if not ghidra_name or not suggested:
                    return False
                return suggested in from_names and suggested != ghidra_name

            sorted_tasks = sorted(
                enumerate(assignment_tasks),
                key=lambda pair: (_needs_delay(pair[1]), pair[0]),
            )

            task_records = []

            for _, task in sorted_tasks:
                match = task["match"]
                assignment = task["assignment"]
                ghidra_name = assignment.get("ghidra_name")
                suggested = assignment.get("suggested_name")
                storage_repr = None
                storage_info = assignment.get("storage")
                if storage_info:
                    storage_repr = storage_info.get("repr")

                if not ghidra_name or not suggested:
                    skipped += 1
                    record_skip("Function {}: missing ghidra/suggested name in mapping {}".format(func_name, match.get("source", {}).get("name")))
                    continue

                var, is_high_symbol = _find_local_variable(func_locals, high_symbols, ghidra_name, storage_repr)
                if var is None:
                    skipped += 1
                    record_skip("Function {}: could not locate target variable '{}'".format(func_name, ghidra_name))
                    continue

                preserve_data_type = False
                dt_for_update = task["target_dt"]
                target_len = None
                if task["target_dt"] is not None and hasattr(task["target_dt"], "getLength"):
                    try:
                        target_len = task["target_dt"].getLength()
                    except Exception:
                        target_len = None
                var_len = None
                try:
                    if hasattr(var, "getLength"):
                        var_len = var.getLength()
                    elif hasattr(var, "getSize"):
                        var_len = var.getSize()
                except Exception:
                    var_len = None
                storage_obj = None
                try:
                    storage_obj = var.getStorage()
                except Exception:
                    storage_obj = None
                if (
                    dt_for_update is not None
                    and target_len is not None
                    and var_len is not None
                    and target_len != var_len
                    and storage_obj is not None
                    and hasattr(storage_obj, "hasStackStorage")
                    and storage_obj.hasStackStorage()
                ):
                    preserve_data_type = True
                    dt_for_update = None

                record = {
                    "match": match,
                    "var": var,
                    "is_high": is_high_symbol,
                    "current_name": ghidra_name,
                    "suggested": suggested,
                    "dt_for_update": dt_for_update,
                    "preserve_data_type": preserve_data_type,
                    "storage_repr": storage_repr,
                    "rename_needed": (suggested != ghidra_name),
                    "rename_possible": True,
                    "high_update_used": False,
                }
                task_records.append(record)
                processed_match_ids.add(id(match))

            if not dry_run:
                for record in task_records:
                    if not record["rename_needed"]:
                        continue
                    placeholder = _generate_placeholder_name(temp_name_counter, func_locals, high_symbols)
                    (
                        staged,
                        updated_var,
                        updated_is_high,
                        high_used,
                        func_locals,
                        high_symbols,
                    ) = _attempt_rename(
                        func,
                        symbol_map,
                        func_locals,
                        high_symbols,
                        record["var"],
                        placeholder,
                        None,
                        record["is_high"],
                    )
                    if not staged:
                        skipped += 1
                        record_skip(
                            "Function {}: rename failed for '{}' while staging placeholder '{}'".format(
                                func_name, record["current_name"], placeholder
                            )
                        )
                        record["rename_possible"] = False
                        continue
                    record["var"] = updated_var
                    record["is_high"] = updated_is_high
                    record["current_name"] = placeholder
                    record["high_update_used"] = record["high_update_used"] or high_used

                for record in task_records:
                    if not record["rename_needed"] or not record["rename_possible"]:
                        continue
                    (
                        success,
                        updated_var,
                        updated_is_high,
                        high_used,
                        func_locals,
                        high_symbols,
                    ) = _attempt_rename(
                        func,
                        symbol_map,
                        func_locals,
                        high_symbols,
                        record["var"],
                        record["suggested"],
                        None,
                        record["is_high"],
                    )
                    if not success:
                        skipped += 1
                        record_skip(
                            "Function {}: rename failed for placeholder '{}' -> '{}'".format(
                                func_name, record["current_name"], record["suggested"]
                            )
                        )
                        record["rename_possible"] = False
                        continue
                    record["var"] = updated_var
                    record["is_high"] = updated_is_high
                    record["current_name"] = record["suggested"]
                    record["high_update_used"] = record["high_update_used"] or high_used

                for record in task_records:
                    if record["dt_for_update"] is None or record["preserve_data_type"]:
                        continue
                    if not record["rename_possible"]:
                        continue
                    if record["is_high"]:
                        if record["high_update_used"]:
                            continue
                        try:
                            record["var"].setDataType(record["dt_for_update"])
                        except (Exception, Throwable):
                            continue
                    else:
                        attempts = [
                            lambda obj: obj.setDataType(record["dt_for_update"], SourceType.USER_DEFINED),
                            lambda obj: obj.setDataType(record["dt_for_update"]),
                        ]
                        for attempt in attempts:
                            try:
                                attempt(record["var"])
                                break
                            except (Exception, Throwable):
                                continue

            applied += len(processed_match_ids)
    finally:
        commit = not dry_run
        try:
            program.endTransaction(transaction, commit)
        except Exception:
            pass
        try:
            interface.dispose()
        except Exception:
            pass

    if dry_run:
        print("Dry run: {} mappings would be applied, {} skipped".format(applied, skipped))
    else:
        print("Applied {} confident local mappings; skipped {}".format(applied, skipped))
    if diagnose and diagnostics:
        print("Skipped details:")
        for entry in diagnostics:
            print("  - {}".format(entry))


if __name__ == "__main__":
    main()
