# Applies confident local-variable mappings generated by scripts/map_locals.py
# onto the active program.
# @category xzre

import json
import os

from ghidra.app.decompiler import DecompInterface  # type: ignore
from ghidra.app.decompiler import DecompInterface  # type: ignore
from ghidra.app.util.cparser.C import CParser  # type: ignore
from ghidra.program.model.data import Undefined  # type: ignore
from ghidra.program.model.listing import VariableStorage  # type: ignore
from ghidra.program.model.symbol import SourceType  # type: ignore
from ghidra.util.task import ConsoleTaskMonitor  # type: ignore
from ghidra.util.exception import DuplicateNameException, InvalidInputException  # type: ignore
from ghidra.util.task import ConsoleTaskMonitor  # type: ignore

try:
    from java.lang import Throwable  # type: ignore
except ImportError:  # pragma: no cover
    class Throwable(Exception):
        pass


def _parse_args(raw_args):
    mapping_path = None
    dry_run = False
    for arg in raw_args:
        if arg.startswith("mapping="):
            mapping_path = os.path.abspath(arg.split("=", 1)[1])
        elif arg == "dryrun":
            dry_run = True
    if not mapping_path:
        raise RuntimeError("mapping=/path/to/variable_mapping_report.json is required")
    if not os.path.exists(mapping_path):
        raise RuntimeError("mapping file not found: {}".format(mapping_path))
    return mapping_path, dry_run


def _find_function_by_name(function_manager, name):
    for func in function_manager.getFunctions(True):
        if func.getName() == name:
            return func
    return None


def _datatype_display(dt):
    if dt is None:
        return None
    try:
        return dt.getDisplayName()
    except Exception:
        try:
            return dt.getName()
        except Exception:
            return None


class TypeResolver(object):
    def __init__(self, dtm):
        self._parser = CParser(dtm)
        self._counter = 0

    def parse(self, type_str):
        if not type_str:
            return None
        typedef_name = "__mapped_type_{}".format(self._counter)
        self._counter += 1
        typedef_snippet = "typedef {} {};\n".format(type_str, typedef_name)
        try:
            parsed = self._parser.parse(typedef_snippet)
            if parsed is None:
                return None
            if hasattr(parsed, "getDataType"):
                inner = parsed.getDataType()
                if inner is not None:
                    return inner
            return parsed
        except Throwable:
            return None
        except Exception:
            return None


def _storage_repr(storage):
    if storage is None:
        return None
    try:
        return str(storage)
    except Exception:
        return None


def _find_local_variable(func_locals, high_symbols, target_name, storage_repr=None):
    var = func_locals.get(target_name)
    if var is not None:
        if storage_repr:
            try:
                if _storage_repr(var.getVariableStorage()) != storage_repr:
                    pass
            except Exception:
                pass
        return var, False
    symbol = high_symbols.get(target_name)
    if symbol is not None:
        if storage_repr:
            try:
                if _storage_repr(symbol.getStorage()) != storage_repr:
                    pass
            except Exception:
                pass
        return symbol, True
    return None, False


def main():
    mapping_path, dry_run = _parse_args(getScriptArgs())
    with open(mapping_path, "r") as infile:
        mapping = json.load(infile)

    program = currentProgram  # type: ignore  # noqa: F821
    function_manager = program.getFunctionManager()
    dtm = program.getDataTypeManager()
    resolver = TypeResolver(dtm)
    interface = DecompInterface()
    try:
        interface.openProgram(program)
    except Exception as exc:
        raise RuntimeError("Failed to open program for decompilation: {}".format(exc))

    applied = 0
    skipped = 0
    transaction = program.startTransaction("ApplyMappedLocals")
    try:
        for entry in mapping.get("results", []):
            func_name = entry.get("function")
            func = _find_function_by_name(function_manager, func_name)
            if func is None:
                skipped += sum(len(match.get("assigned", [])) for match in entry.get("matches", []))
                continue

            func_locals = {}
            try:
                for local_var in func.getLocalVariables():
                    func_locals[local_var.getName()] = local_var
            except Exception:
                func_locals = {}

            high_symbols = {}
            symbol_map = None
            try:
                decomp_results = interface.decompileFunction(func, 60, ConsoleTaskMonitor())
            except Exception:
                decomp_results = None
            if decomp_results is not None and decomp_results.decompileCompleted():
                high_func = decomp_results.getHighFunction()
                if high_func is not None:
                    try:
                        symbol_map = high_func.getLocalSymbolMap()
                        for symbol in symbol_map.getSymbols():
                            try:
                                if symbol.isParameter():
                                    continue
                            except Exception:
                                pass
                            high_symbols[symbol.getName()] = symbol
                    except Exception:
                        high_symbols = {}
                        symbol_map = None

            for match in entry.get("matches", []):
                notes = match.get("notes") or []
                if notes:
                    # Skip low-confidence matches.
                    skipped += len(match.get("assigned", []))
                    continue

                source_type = match.get("source", {}).get("type")
                target_dt = resolver.parse(source_type) if source_type else None

                for assignment in match.get("assigned", []):
                    ghidra_name = assignment.get("ghidra_name")
                    suggested = assignment.get("suggested_name")
                    storage_repr = None
                    storage_info = assignment.get("storage")
                    if storage_info:
                        storage_repr = storage_info.get("repr")

                    if not ghidra_name or not suggested:
                        skipped += 1
                        continue

                    var, is_high_symbol = _find_local_variable(func_locals, high_symbols, ghidra_name, storage_repr)
                    if var is None:
                        skipped += 1
                        continue

                    if not dry_run and suggested != ghidra_name:
                        renamed = False
                        if is_high_symbol and symbol_map is not None:
                            try:
                                symbol_map.renameSymbol(var, suggested, SourceType.USER_DEFINED)
                                renamed = True
                            except (Exception, Throwable):
                                renamed = False
                        if not renamed:
                            rename_attempts = [
                                lambda obj: obj.setName(suggested, SourceType.USER_DEFINED),
                                lambda obj: obj.setName(suggested),
                                lambda obj: obj.rename(suggested, SourceType.USER_DEFINED),
                                lambda obj: obj.rename(suggested),
                            ]
                            for attempt in rename_attempts:
                                try:
                                    attempt(var)
                                    renamed = True
                                    break
                                except (Exception, Throwable):
                                    continue
                        if not renamed and is_high_symbol:
                            try:
                                storage = var.getStorage()
                                data_type = target_dt or var.getDataType()
                                if data_type is None and hasattr(var, "getDataType"):
                                    data_type = var.getDataType()
                                if data_type is None:
                                    size = 1
                                    try:
                                        size = storage.size()
                                    except Exception:
                                        try:
                                            size = storage.getSize()
                                        except Exception:
                                            size = 1
                                    data_type = Undefined.getUndefinedDataType(size)
                                func.createLocalVariable(suggested, data_type, storage, SourceType.USER_DEFINED)
                                # Refresh our local cache so subsequent operations see the new variable.
                                try:
                                    for local_var in func.getLocalVariables():
                                        if local_var.getName() == suggested:
                                            func_locals[suggested] = local_var
                                            var = local_var
                                            is_high_symbol = False
                                            break
                                except Exception:
                                    pass
                                renamed = True
                            except (DuplicateNameException, InvalidInputException, Exception, Throwable):
                                renamed = False
                        if not renamed:
                            skipped += 1
                            continue

                    if not dry_run and target_dt is not None:
                        if is_high_symbol:
                            try:
                                var.setDataType(target_dt)
                            except (Exception, Throwable):
                                pass
                        else:
                            data_attempts = [
                                lambda obj: obj.setDataType(target_dt, SourceType.USER_DEFINED),
                                lambda obj: obj.setDataType(target_dt),
                            ]
                            for attempt in data_attempts:
                                try:
                                    attempt(var)
                                    break
                                except (Exception, Throwable):
                                    continue

                applied += 1
    finally:
        commit = not dry_run
        try:
            program.endTransaction(transaction, commit)
        except Exception:
            pass
        try:
            interface.dispose()
        except Exception:
            pass

    if dry_run:
        print("Dry run: {} mappings would be applied, {} skipped".format(applied, skipped))
    else:
        print("Applied {} confident local mappings; skipped {}".format(applied, skipped))


if __name__ == "__main__":
    main()
